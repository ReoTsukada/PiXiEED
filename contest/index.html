<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no, viewport-fit=cover"/>
  <meta name="robots" content="noai,noimageai,nosnippet,noarchive"/>
  <title>PiXiEED ドットギャラリー</title>
  <meta name="description" content="ドット絵制作・pixel art commission、ブラウザゲーム用アセット、ツールとゲームをまとめたPiXiEED公式サイト。"/>
  <meta property="og:type" content="website"/>
  <meta property="og:site_name" content="PiXiEED"/>
  <meta property="og:title" content="PiXiEED | ドット絵専用総合サイト"/>
  <meta property="og:description" content="ドット絵制作の外注・pixel art commission、ブラウザゲーム用アセット制作、ツールとゲームを紹介するPiXiEED公式サイト。"/>
  <meta property="og:url" content="https://pixieed.jp/contest/index.html"/>
  <meta property="og:image" content="https://pixieed.jp/PiXiEEDogp.png"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <link rel="icon" type="image/png" href="../character-dots/mao1.png"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Fredoka:wght@600&display=swap" rel="stylesheet">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9801602250480253" crossorigin="anonymous"></script>
  <style>
    :root{
      color-scheme: dark;
      --header-offset:64px;
      --bottom-nav:68px;
    }
    *{
      box-sizing:border-box;
      user-select:none;
      -webkit-user-select:none;
      -ms-user-select:none;
    }
    body{
      margin:0;
      font-family:'Fredoka', 'DotGothic16', system-ui, sans-serif;
      background:radial-gradient(circle at 20% 20%, rgba(59,130,246,0.22), rgba(15,23,42,1)),
                 radial-gradient(circle at 80% 0%, rgba(236,72,153,0.18), rgba(15,23,42,1)),
                 #0b1224;
      color:#e5e7eb;
      min-height:100vh;
      padding:0 14px 120px;
      display:block;
    }
    .page{ width:100%; max-width:1200px; min-width:0; display:grid; gap:14px; position:relative; margin:0 auto; }
    header{
      position:sticky;
      top:0;
      z-index:70;
      background:rgba(11,18,36,0.94);
      backdrop-filter:blur(8px);
      border-bottom:1px solid rgba(255,255,255,0.08);
      margin:-20px -14px 8px;
      padding:10px 14px;
    }
    .header-inner{
      width:100%;
      max-width:1200px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .ad-banner{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:0;
      padding:10px;
      box-shadow:0 10px 30px rgba(0,0,0,0.28);
      max-width:100%;
      overflow:hidden;
    }
    .ad-banner ins{
      display:block;
      width:100%;
      height:90px;
      max-width:100%;
      overflow:hidden;
    }
    .ad-banner__label{
      margin:6px 0 0;
      color:#cbd5e1;
      font-size:12px;
      letter-spacing:0.06em;
      text-align:center;
      display:block;
    }
    @media(max-width:640px){
      .ad-banner ins{ height:60px; }
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:800;
      letter-spacing:0.01em;
    }
    .brand-icon{
      width:34px;
      height:34px;
      border-radius:10px;
      background:rgba(255,255,255,0.12);
      padding:4px;
      border:1px solid rgba(255,255,255,0.2);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .brand-icon img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    .brand-text{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand-title{ margin:0; font-size:16px; color:#f9fafb; }
    .brand-sub{ margin:0; font-size:12px; color:#9ca3af; }
    .header-actions{
      display:flex;
      align-items:center;
      gap:10px;
    }
    h1{ margin:0; font-size:22px; letter-spacing:0.02em; color:#f9fafb; }
    .subtitle{ margin:0; color:#cbd5e1; font-size:12px; }
    .card{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:0;
      padding:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.3);
    }
    .grid{ display:grid; gap:14px; grid-template-columns:1fr; }
    .prompt{ display:flex; flex-direction:column; gap:6px; }
    .prompt-title{ margin:0; font-size:15px; color:#f9fafb; }
    .prompt-text{
      padding:10px;
      border-radius:10px;
      background:rgba(59,130,246,0.18);
      border:1px solid rgba(59,130,246,0.35);
      color:#e0f2fe;
      font-family:'DotGothic16', monospace;
    }
    .button{
      appearance:none;
      border:0;
      border-radius:10px;
      padding:10px 14px;
      font:700 14px/1.2 'Fredoka', system-ui, sans-serif;
      cursor:pointer;
      color:#ffffff;
      background:linear-gradient(135deg, #ff719a, #ff9f43);
      box-shadow:0 4px 0 #e35c82, 0 8px 16px rgba(255,113,154,0.35);
      transition:transform 0.1s ease, filter 0.1s ease;
    }
    .button:hover,
    .button:focus-visible{ transform:translateY(-1px); filter:brightness(1.05); }
    form{ display:flex; flex-direction:column; gap:10px; }
    .field{ display:flex; flex-direction:column; gap:4px; }
    label{ font-weight:700; color:#e5e7eb; }
    input[type="text"], input[type="file"], input[type="search"]{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.35);
      color:#f9fafb;
      padding:10px 12px;
      font-size:14px;
      font-family:'DotGothic16', monospace;
    }
    .static-input{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.35);
      color:#f9fafb;
      padding:10px 12px;
      font-size:14px;
      font-family:'DotGothic16', monospace;
    }
    .helper{ color:#cbd5e1; font-size:12px; margin:0; }
    .status{ min-height:20px; color:#fef3c7; font-size:12px; margin:4px 0 0; }
    .tag-input{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .tag-input input{
      flex:1;
      min-width:0;
    }
    .tag-add-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#e5e7eb;
      border-radius:10px;
      padding:8px 12px;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    .tag-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:28px;
    }
    .download-settings{
      display:grid;
      gap:8px;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:700;
      color:#e5e7eb;
    }
    .toggle input{
      width:18px;
      height:18px;
      accent-color:#ff9f43;
    }
    .download-passcode{
      display:grid;
      gap:8px;
    }
    .tag-chip{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#e5e7eb;
    }
    .tag-chip .tag-remove{
      font-weight:800;
      opacity:0.7;
    }
    .tag-search{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    .tag-search label{
      font-weight:700;
      color:#e5e7eb;
    }
    .tag-search input{
      flex:1;
      min-width:180px;
    }
    .entry-tags{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .gallery{
      display:grid;
      gap:12px;
      grid-template-columns:repeat(3, minmax(0, 1fr));
    }
    .load-more{
      display:flex;
      justify-content:center;
      margin-top:14px;
    }
    .load-more-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#e5e7eb;
      border-radius:10px;
      padding:10px 16px;
      font-weight:800;
      cursor:pointer;
    }
    .load-more-btn:disabled{
      opacity:0.6;
      cursor:not-allowed;
    }
    .tabs{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .tab-btn{
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.06);
      color:#e5e7eb;
      border-radius:10px;
      padding:8px 12px;
      font-weight:700;
      cursor:pointer;
    }
    .tab-btn.is-active{
      background:linear-gradient(135deg,#ff719a,#ff9f43);
      border-color:transparent;
      color:#0b1224;
    }
    .sort-tabs{
      display:flex;
      gap:6px;
      align-items:center;
      margin-left:auto;
      flex-wrap:wrap;
    }
    .sort-btn{
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#e5e7eb;
      border-radius:8px;
      padding:6px 10px;
      font-weight:700;
      cursor:pointer;
    }
    .sort-btn.is-active{
      background:rgba(251,191,36,0.22);
      border-color:rgba(251,191,36,0.6);
      color:#0b1224;
    }
    .entry-card{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      box-shadow:0 8px 24px rgba(0,0,0,0.26);
      position:relative;
      text-decoration:none;
      color:inherit;
      -webkit-touch-callout:none;
      -webkit-user-select:none;
      user-select:none;
    }
    .entry-card--ad{
      border-radius:10px;
      align-items:center;
      justify-content:center;
      padding:12px;
      min-height:220px;
      gap:10px;
      max-width:100%;
    }
    .entry-ad-slot{
      width:100%;
      max-width:100%;
      min-width:0;
    }
    .entry-ad-slot ins{
      display:block;
      width:100%;
      height:90px;
      overflow:hidden;
    }
    .entry-ad-note{
      margin:0;
      color:#cbd5e1;
      font-size:12px;
      text-align:center;
    }
    @media(max-width:640px){
      .entry-ad-slot ins{ height:60px; }
    }
    .entry-imgwrap{
      padding:0;
      background:transparent;
      display:block;
      position:relative;
      aspect-ratio:1/1;
      border-radius:12px;
      overflow:hidden;
      -webkit-touch-callout:none;
    }
    .entry-imgwrap img{
      width:100%;
      height:100%;
      object-fit:cover;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      -ms-interpolation-mode:nearest-neighbor;
      border:0;
      background:transparent;
      position:relative;
      z-index:1;
      pointer-events:none;
      -webkit-user-drag:none;
      -webkit-touch-callout:none;
      user-select:none;
    }
    .entry-watermark{
      position:absolute;
      color:rgba(255,255,255,0.04);
      font-weight:800;
      font-size:14px;
      letter-spacing:0.08em;
      text-shadow:0 0 12px rgba(0,0,0,0.18);
      z-index:2;
      pointer-events:none;
    }
    .heart-btn{
      position:absolute;
      right:4px;
      bottom:4px;
      border:none;
      background:transparent;
      padding:0;
      width:32px;
      height:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:2;
    }
    .heart-btn img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
    }
    .heart-btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    .entry-meta{ padding:10px; display:flex; flex-direction:column; gap:6px; }
    .entry-meta__top{ display:flex; align-items:center; justify-content:space-between; gap:6px; }
    .entry-title{ font-weight:800; color:#f9fafb; }
    .entry-like{ color:#fbbf24; font-weight:800; }
    .entry-author{ margin:0; color:#cbd5e1; font-size:12px; }
    .entry-info{ margin:0; color:#94a3b8; font-size:11px; }
    .like-btn{
      border:1px solid rgba(251,191,36,0.5);
      background:rgba(251,191,36,0.12);
      color:#fbbf24;
      border-radius:8px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:700;
      font-family:'DotGothic16', monospace;
    }
    .like-btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .empty{ color:#cbd5e1; text-align:center; margin:8px 0 0; font-family:'DotGothic16', monospace; }
    .feed-subtitle{
      margin:0;
      color:#9ca3af;
      font-size:12px;
    }
    .top-bar{
      display:flex;
      flex-direction:column;
      gap:4px;
      width:100%;
    }
    .quick-tools{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .quick-tools .button{
      padding:8px 12px;
      font-size:13px;
    }
    .button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.2);
      color:#e5e7eb;
      box-shadow:none;
    }
    .auth-chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.16);
      color:#fff;
      cursor:pointer;
      font-weight:700;
    }
    .auth-chip__status{
      font-size:12px;
      color:#cbd5e1;
    }
    .auth-panel{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.65);
      backdrop-filter:blur(4px);
      padding:calc(12px + env(safe-area-inset-top)) calc(12px + env(safe-area-inset-right)) calc(12px + env(safe-area-inset-bottom) + 76px) calc(12px + env(safe-area-inset-left));
      z-index:70;
    }
    .auth-panel.is-open{ display:flex; }
    .auth-card{
      width:100%;
      max-width:420px;
      max-height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 84px);
      background:rgba(15,23,42,0.95);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:16px;
      padding:clamp(12px, 2vh, 16px);
      box-shadow:0 18px 40px rgba(0,0,0,0.45);
      display:grid;
      gap:clamp(8px, 1.6vh, 12px);
      box-sizing:border-box;
      overflow:hidden;
    }
    @supports (height: 100dvh){
      .auth-card{
        max-height:calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 84px);
      }
    }
    .auth-input{
      min-width:0;
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#fff;
      padding:clamp(8px, 1.4vh, 10px) clamp(10px, 1.6vh, 12px);
      font-size:clamp(12px, 1.6vh, 14px);
    }
    .auth-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:linear-gradient(135deg,#4f46e5,#7c3aed);
      color:#fff;
      border-radius:12px;
      padding:clamp(8px, 1.4vh, 10px) clamp(12px, 1.6vh, 14px);
      font-weight:800;
      cursor:pointer;
      text-align:center;
      font-size:clamp(12px, 1.6vh, 14px);
    }
    .auth-btn.logout{
      background:rgba(255,255,255,0.08);
      border-color:rgba(255,255,255,0.2);
    }
    .auth-status{
      font-size:12px;
      color:#cbd5e1;
      min-height:16px;
    }
    .auth-details{
      border:1px solid rgba(255,255,255,0.16);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(255,255,255,0.04);
    }
    .auth-details summary{
      list-style:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:800;
      color:#e5e7eb;
    }
    .auth-details summary::-webkit-details-marker{ display:none; }
    .auth-details__status{
      margin-left:auto;
      font-size:12px;
      color:#93c5fd;
      font-weight:700;
    }
    .auth-details summary::after{
      content:'+';
      color:#94a3b8;
      font-weight:800;
    }
    .auth-details[open] summary::after{ content:'-'; }
    .auth-details__body{
      display:grid;
      gap:8px;
      margin-top:10px;
    }
    .bottom-nav{
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      height:68px;
      background:rgba(11,18,36,0.96);
      border-top:1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:space-around;
      align-items:center;
      z-index:80;
      backdrop-filter:blur(8px);
    }
    .bottom-nav__item{
      flex:1;
      text-align:center;
      color:#cbd5e1;
      text-decoration:none;
      font-weight:700;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      font-size:12px;
      padding:8px 0;
    }
    .bottom-nav__item .icon{
      width:22px;
      height:22px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .bottom-nav__item .icon img{
      width:100%;
      height:100%;
      object-fit:contain;
      image-rendering:pixelated;
    }
    .bottom-nav__item.is-active{
      color:#f9fafb;
    }
    .profile-block{
      display:grid;
      gap:clamp(8px, 1.4vh, 10px);
      padding:clamp(8px, 1.4vh, 12px);
      border-radius:12px;
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.08);
    }
    .profile-row{
      display:flex;
      align-items:flex-end;
      gap:10px;
    }
    .profile-name{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .avatar-toggle{
      width:48px;
      height:48px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(0,0,0,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .avatar-toggle__img{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .avatar-toggle__img img{
      width:80%;
      height:80%;
      object-fit:contain;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    .avatar-panel{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:6px;
      background:rgba(0,0,0,0.2);
    }
    .avatar-grid{
      display:grid;
      grid-template-columns:repeat(5, minmax(0, 1fr));
      gap:clamp(4px, 1vh, 6px);
      max-height:clamp(120px, 20vh, 160px);
      overflow-y:auto;
      padding-right:4px;
      -webkit-overflow-scrolling:touch;
    }
    .avatar-option{
      width:100%;
      aspect-ratio:1;
      border-radius:12px;
      border:2px solid transparent;
      background:rgba(255,255,255,0.08);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:800;
      transition:border-color 0.15s ease, transform 0.1s ease;
    }
    .avatar-option.is-active{
      border-color:#7c3aed;
      transform:translateY(-1px);
    }
    .fab-menu{
      position:fixed;
      right:18px;
      bottom:86px;
      width:56px;
      height:56px;
      z-index:60;
    }
    .fab-toggle{
      width:56px;
      height:56px;
      border-radius:50%;
      background:linear-gradient(135deg, #ff719a, #ff9f43);
      color:#fff;
      font:800 28px/1 'Fredoka', system-ui, sans-serif;
      border:0;
      box-shadow:0 8px 20px rgba(0,0,0,0.25);
      cursor:pointer;
      transition:transform 0.18s ease, box-shadow 0.18s ease;
    }
    .fab-toggle:focus-visible{ outline:3px solid rgba(255,255,255,0.4); }
    .fab-menu.is-open .fab-toggle{
      transform:rotate(45deg);
    }
    .fab-actions{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .fab-menu.is-open .fab-actions{
      pointer-events:auto;
    }
    .fab-action{
      position:absolute;
      left:50%;
      top:50%;
      width:46px;
      height:46px;
      padding:0;
      border-radius:50%;
      border:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font:800 12px/1 'Fredoka', system-ui, sans-serif;
      color:#fff;
      text-decoration:none;
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      opacity:0;
      pointer-events:none;
      transform:translate(-50%, -50%) scale(0.86);
      transition:transform 0.18s ease, opacity 0.18s ease;
    }
    .fab-action__icon{
      width:70%;
      height:70%;
      object-fit:contain;
      display:block;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    .fab-action__text{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0, 0, 0, 0);
      white-space:nowrap;
      border:0;
    }
    .fab-action:focus-visible{ outline:3px solid rgba(255,255,255,0.4); }
    .fab-menu.is-open .fab-action{
      opacity:1;
      pointer-events:auto;
      transform:translate(calc(-50% + var(--fab-x)), calc(-50% + var(--fab-y))) scale(1);
    }
    .fab-action--post{ background:linear-gradient(135deg, #34d399, #22c55e); }
    .fab-action--draw{ background:linear-gradient(135deg, #60a5fa, #3b82f6); }
    .fab-action--lite{ background:linear-gradient(135deg, #f472b6, #fb7185); }
    .post-panel{
      position:fixed;
      inset:0;
      display:none;
      align-items:flex-end;
      justify-content:center;
      background:rgba(0,0,0,0.65);
      backdrop-filter:blur(4px);
      padding:calc(16px + env(safe-area-inset-top, 0px) + var(--header-offset)) 16px calc(16px + env(safe-area-inset-bottom, 0px) + var(--bottom-nav));
      z-index:95;
    }
    .post-panel.is-open{ display:flex; }
    .post-card{
      width:100%;
      max-width:560px;
      background:rgba(15,23,42,0.92);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px;
      padding:14px;
      box-shadow:0 12px 40px rgba(0,0,0,0.4);
      max-height:calc(100vh - (env(safe-area-inset-top, 0px) + env(safe-area-inset-bottom, 0px) + var(--bottom-nav) + var(--header-offset) + 32px));
      overflow:auto;
    }
    @supports (height: 100dvh){
      .post-card{
        max-height:calc(100dvh - (env(safe-area-inset-top, 0px) + env(safe-area-inset-bottom, 0px) + var(--bottom-nav) + var(--header-offset) + 32px));
      }
    }
    .post-preview{
      width:100%;
      height:clamp(160px, 32vw, 240px);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background-color:#0f172a;
      background-image:
        linear-gradient(45deg, rgba(255,255,255,0.07) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.07) 75%, rgba(255,255,255,0.07)),
        linear-gradient(45deg, rgba(255,255,255,0.07) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.07) 75%, rgba(255,255,255,0.07));
      background-size:16px 16px;
      background-position:0 0, 8px 8px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px;
    }
    .post-preview img{
      width:100%;
      height:100%;
      display:none;
      object-fit:contain;
      image-rendering:pixelated;
      border-radius:8px;
      box-shadow:0 6px 16px rgba(0,0,0,0.4);
    }
    .post-preview.is-filled img{ display:block; }
    .post-preview__empty{
      color:#94a3b8;
      font-size:12px;
    }
    .post-preview.is-filled .post-preview__empty{ display:none; }
    .post-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }
    .post-title{ margin:0; font-size:16px; color:#f9fafb; }
    .close-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#fff;
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
    }
  </style>
  <style id="ads-safe">
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .adsbygoogle,
    ins.adsbygoogle {
      display: block !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box;
      overflow: hidden;
    }
    .adsbygoogle iframe,
    ins.adsbygoogle iframe {
      display: block;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
  </style>
  <style id="interaction-guard">
    * {
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    input,
    textarea,
    [contenteditable] {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  <script id="interaction-guard-js">
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    document.addEventListener('dragstart', (event) => {
      event.preventDefault();
    });
  </script>
  <script id="ads-lazy">
    (function() {
      if (window.pixieedObserveAds) return;
      const pending = [];
      const hasObserverSupport = 'IntersectionObserver' in window;
      let observer = null;
      const isLoaded = (ins) => (
        ins.dataset.adsLazyLoaded === '1' ||
        ins.getAttribute('data-adsbygoogle-status') === 'done' ||
        ins.getAttribute('data-ad-status') === 'filled'
      );
      const loadAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyLoaded = '1';
        try {
          (window.adsbygoogle = window.adsbygoogle || []).push({});
        } catch (err) {
          ins.dataset.adsLazyLoaded = '';
        }
      };
      const observeAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (ins.dataset.adsLazyObserved === '1') return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyObserved = '1';
        if (!observer) {
          if (!hasObserverSupport) {
            loadAd(ins);
          } else {
            pending.push(ins);
          }
          return;
        }
        observer.observe(ins);
      };
      const observeAds = (root) => {
        const scope = root && root.querySelectorAll ? root : document;
        scope.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
      };
      window.pixieedObserveAds = observeAds;
      const setupObserver = () => {
        if (hasObserverSupport) {
          observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting || entry.intersectionRatio > 0) {
                const target = entry.target;
                if (observer) observer.unobserve(target);
                loadAd(target);
              }
            });
          }, { rootMargin: '200px 0px', threshold: 0.01 });
        }
        const queued = pending.splice(0);
        queued.forEach((ins) => {
          if (observer) {
            observer.observe(ins);
          } else {
            loadAd(ins);
          }
        });
        observeAds(document);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
      const mo = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (!(node instanceof HTMLElement)) return;
            if (node.matches && node.matches('ins.adsbygoogle')) {
              observeAd(node);
              return;
            }
            if (node.querySelectorAll) {
              node.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
            }
          });
        });
      });
      const startObserver = () => {
        if (!document.body) return;
        mo.observe(document.body, { childList: true, subtree: true });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startObserver);
      } else {
        startObserver();
      }
    })();
  </script>
</head>
<body>
  <div class="page">
    <header aria-label="top-nav">
      <div class="header-inner">
        <button class="brand" id="openProfilePanel" type="button" style="background:none;border:0;cursor:pointer;padding:0;">
          <span class="brand-icon" id="brandAvatar">
            <img src="../character-dots/mao1.png" alt="logo">
          </span>
          <div class="brand-text">
            <p class="brand-title">PiXiEED</p>
            <p class="brand-sub" id="brandUser">ユーザー</p>
          </div>
        </button>
        <div class="header-actions"></div>
      </div>
    </header>
    <section class="card ad-banner" aria-label="広告">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-9801602250480253"
           data-ad-slot="2141591954"
           data-ad-format="horizontal"></ins>
      <small class="ad-banner__label">広告</small>
    </section>
    <section class="card">
      <div class="top-bar">
        <h1>ドットギャラリー</h1>
        <p class="subtitle">みんなのドットを眺めよう。元サイズ512x512以内 / 256色以内のPNGを投稿もできます。</p>
        <p class="feed-subtitle">最新→いいね順で並びます</p>
        <div class="quick-tools">
          <a class="button" href="../pixiedraw/index.html" rel="noopener" target="_blank">PiXiEEDraw</a>
          <a class="button secondary" href="../jerin-maker/index.html" rel="noopener" target="_blank">PiXiEEDraw Lite</a>
        </div>
      </div>
    </section>
    <section class="card">
      <div class="tabs">
        <div id="filterTabs" style="display:flex; gap:8px;">
          <button class="tab-btn is-active" data-filter="all" type="button">すべて</button>
          <button class="tab-btn" data-filter="timed10" type="button">10m</button>
          <button class="tab-btn" data-filter="px32" type="button">32px</button>
        </div>
        <div class="sort-tabs" id="sortTabs">
          <span class="helper" style="margin-right:4px;">並び替え:</span>
          <button class="sort-btn is-active" data-sort="new" type="button">新着</button>
          <button class="sort-btn" data-sort="popular" type="button">人気</button>
        </div>
      </div>
      <div class="tag-search">
        <label for="tagSearch">タグ検索</label>
        <input id="tagSearch" type="search" placeholder="タグで絞り込み（例: 夜景）" aria-label="タグ検索"/>
      </div>
      <div id="contestGallery" class="gallery"></div>
      <div class="load-more" id="loadMoreWrap" hidden>
        <button class="load-more-btn" id="loadMoreBtn" type="button">もっと見る</button>
      </div>
    </section>

    <div class="grid">
    </div>
  </div>
  <div class="fab-menu" id="fabMenu">
    <button class="fab-toggle" id="fabToggle" type="button" aria-label="作成メニューを開く" aria-expanded="false">＋</button>
    <div class="fab-actions" id="fabActions" aria-hidden="true">
      <button class="fab-action fab-action--post" id="openPostPanel" type="button" style="--fab-x:-4px; --fab-y:-84px;" aria-label="投稿する">
        <img class="fab-action__icon" src="../ougi-3.png" alt=""/>
        <span class="fab-action__text">投稿</span>
      </button>
      <a class="fab-action fab-action--draw" href="../pixiedraw/index.html" rel="noopener" target="_blank" style="--fab-x:-68px; --fab-y:-58px;" aria-label="PiXiEEDrawで描く">
        <img class="fab-action__icon" src="../ougi-2.png" alt=""/>
        <span class="fab-action__text">PiXiEEDraw</span>
      </a>
      <a class="fab-action fab-action--lite" href="../jerin-maker/index.html" rel="noopener" target="_blank" style="--fab-x:-92px; --fab-y:-6px;" aria-label="PiXiEEDraw Liteで描く">
        <img class="fab-action__icon" src="../ougi-1.png" alt=""/>
        <span class="fab-action__text">PiXiEEDraw Lite</span>
      </a>
    </div>
  </div>
  <div class="post-panel" id="postPanel" aria-hidden="true">
    <div class="post-card">
      <div class="post-header">
        <h3 class="post-title">投稿する</h3>
        <button class="close-btn" type="button" id="closePostPanel">閉じる</button>
      </div>
      <form id="contestForm">
        <div class="field">
          <label>名前</label>
          <div class="static-input" id="nameDisplay">未設定</div>
        </div>
        <div class="field">
          <label for="title">作品名</label>
          <input id="title" name="title" type="text" placeholder="無題"/>
        </div>
        <div class="field">
          <label for="tagInput">タグ</label>
          <div class="tag-input">
            <input id="tagInput" type="text" placeholder="例: 夜景, キャラ" maxlength="24"/>
            <button class="tag-add-btn" id="addTagBtn" type="button">追加</button>
          </div>
          <div class="tag-list" id="tagList" aria-live="polite"></div>
          <p class="helper">Enter / 追加でタグをセット（最大5）</p>
        </div>
        <div class="field">
          <label>ダウンロード設定</label>
          <div class="download-settings">
            <label class="toggle">
              <input id="allowDownload" type="checkbox"/>
              ダウンロードを許可
            </label>
            <div class="download-passcode" id="downloadPasscodeWrap" hidden>
              <label class="toggle">
                <input id="requirePasscode" type="checkbox"/>
                パスコードを設定
              </label>
              <input id="downloadPasscode" type="text" placeholder="パスコード（4〜12文字）" maxlength="12"/>
              <p class="helper">英数字のみ（例: 1234 / pixieed）</p>
            </div>
          </div>
        </div>
        <div class="field">
          <label>プレビュー</label>
          <div class="post-preview" id="postPreview">
            <span class="post-preview__empty" id="postPreviewEmpty">画像が選択されていません</span>
            <img id="postPreviewImage" alt="投稿プレビュー"/>
          </div>
        </div>
        <div class="field">
          <label for="contestFile">PNG / GIF</label>
          <input id="contestFile" name="contestFile" type="file" accept="image/png,image/gif"/>
          <p class="helper">PNG または GIF（サムネは1フレーム表示） / 元サイズ512x512以内 / 256色以内</p>
        </div>
        <button class="button" type="submit">投稿する</button>
        <p class="status" id="contestStatus"></p>
      </form>
    </div>
  </div>
  <nav class="bottom-nav">
    <a class="bottom-nav__item" data-tab="home" href="../index.html">
      <span class="icon"><img src="../FooterIcon1.png" alt=""/></span><span>ホーム</span>
    </a>
    <a class="bottom-nav__item is-active" data-tab="contest" href="./index.html">
      <span class="icon"><img src="../FooterIcon2.png" alt=""/></span><span>コンテスト</span>
    </a>
    <a class="bottom-nav__item" data-tab="tools" href="../tools.html">
      <span class="icon"><img src="../FooterIcon3.png" alt=""/></span><span>ツール/ゲーム</span>
    </a>
    <span class="bottom-nav__item bottom-nav__item--empty" aria-hidden="true"></span>
    <a class="bottom-nav__item" data-tab="portfolio" href="../portfolio/index.html">
      <span class="icon"><img src="../FooterIcon4.png" alt=""/></span><span>企業向け</span>
    </a>
  </nav>
  <div class="auth-panel" id="authPanel" aria-hidden="true">
    <div class="auth-card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
        <h3 style="margin:0;font-size:16px;color:#f9fafb;">プロフィール</h3>
        <button class="close-btn" type="button" id="closeAuthPanel">閉じる</button>
      </div>
      <div class="profile-block">
        <div class="profile-row">
          <button class="avatar-toggle" id="avatarToggle" type="button" aria-label="アイコンを変更" aria-expanded="false" aria-controls="avatarPanel">
            <span class="avatar-toggle__img" id="avatarPreview"></span>
          </button>
          <label class="profile-name">
            <span style="font-weight:700; color:#e5e7eb;">ニックネーム</span>
            <input class="auth-input" id="profileNickname" type="text" placeholder="なまえ" maxlength="32">
          </label>
        </div>
        <div class="avatar-panel" id="avatarPanel" hidden>
          <div class="avatar-grid" id="avatarGrid"></div>
        </div>
        <label class="profile-name">
          <span style="font-weight:700; color:#e5e7eb;">X (旧Twitter)</span>
          <input class="auth-input" id="profileX" type="url" placeholder="https://x.com/username" maxlength="200" inputmode="url">
        </label>
        <button class="auth-btn" id="saveProfile" type="button">プロフィールを保存</button>
      </div>
      <div class="profile-block">
        <details class="auth-details" id="authDetails">
          <summary>
            <span>アカウントの保存（メール）</span>
            <span class="auth-details__status" id="linkedEmail" style="display:none;"></span>
          </summary>
          <div class="auth-details__body">
            <p class="helper" style="margin:0;">長期保存 / 自動で引き継ぎ / 復旧可</p>
            <div id="authInputs" style="display:grid; gap:8px;">
              <input class="auth-input" id="authEmail" type="email" placeholder="メールアドレス" autocomplete="email">
              <input class="auth-input" id="authPasscode" type="password" placeholder="パスコード（6〜20文字）" autocomplete="current-password">
            </div>
            <button class="auth-btn" id="authBtn" type="button">メール＋パスコードでログイン</button>
            <button class="auth-btn logout" id="logoutBtn" type="button" style="display:none;">ログアウト</button>
            <p class="helper" style="margin:0;">別端末でも同じアカウントで利用できます。</p>
          </div>
        </details>
      </div>
      <p class="auth-status" id="authStatus"></p>
    </div>
  </div>
  <script type="module">
    // インライン版：file:// でも必ずダミー表示。Supabaseが使えない場合もプレース表示。
    const SUPABASE_URL = 'https://kyyiuakrqomzlikfaire.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_gnc61sD2hZvGHhEW8bQMoA_lrL07SN4';
    const FORM_ID = 'contestForm';
    const FILE_INPUT_ID = 'contestFile';
    const STATUS_ID = 'contestStatus';
    const GALLERY_ID = 'contestGallery';
    const TAG_INPUT_ID = 'tagInput';
    const TAG_LIST_ID = 'tagList';
    const TAG_SEARCH_ID = 'tagSearch';
    const LOAD_MORE_BTN_ID = 'loadMoreBtn';
    const LOAD_MORE_WRAP_ID = 'loadMoreWrap';
    const ADD_TAG_BTN_ID = 'addTagBtn';
    const ALLOW_DOWNLOAD_ID = 'allowDownload';
    const REQUIRE_PASSCODE_ID = 'requirePasscode';
    const PASSCODE_INPUT_ID = 'downloadPasscode';
    const PASSCODE_WRAP_ID = 'downloadPasscodeWrap';
    const MAX_SIZE = 512;
    const MAX_COLORS = 256;
    const NORMALIZE_COLOR_TOLERANCE = 12;
    const NORMALIZE_MATCH_RATIO = 0.985;
    const MAX_TAGS = 5;
    const PAGE_SIZE = 12;
    const PENDING_UPLOAD_KEY = 'pixieed_contest_upload_v1';
    const SUPABASE_MAINTENANCE_KEY = 'pixieed_supabase_maintenance';
    const POST_QUEUE_KEY = 'contest_post_queue';
    const POST_QUEUE_LIMIT = 20;
    const POST_QUEUE_RETRY_MS = 60000;
    const STORAGE_BUCKET = 'pixieed-contest';
    const THUMB_SIZE = 256;
    const CONTEST_SHARE_BASE_URL = 'https://pixieed.jp/contest/view.html';
    const CONTEST_SHARE_OGP_WIDTH = 1200;
    const CONTEST_SHARE_OGP_HEIGHT = 630;
    const CONTEST_SHARE_PADDING = 60;
    const CONTEST_SHARE_TITLE_SIZE = 32;
    const SHARE_HASHTAG = '#PiXiEED';
    let supportsClientId = true;
    let supportsTags = true;
    let supportsDownloadSettings = true;
    let supportsImageUrls = true;
    let supportsStorageUploads = true;
    let supportsImageHash = true;
    let supportsPhash = true;
    let supportsUserId = true;
    let supportsXUrl = true;
    let supportsProfileXUrl = true;
    let supabaseUser = null;
    let supabaseSession = null;
    let migrationDone = false;
    let clientLinkConflict = false;
    let clientLinkChecked = false;

    let clientId = null;
    let likedEntries = new Set();
    let likesCache = [];
    let likeCounts = {};
    let currentFilter = 'all';
    let currentSort = 'new';
    let currentTagQuery = '';
    let cachedEntries = [];
    let currentOffset = 0;
    let hasMoreEntries = true;
    let isLoadingEntries = false;
    let postTags = [];
    let supabase = null;
    let supabaseMaintenance = Boolean(readSupabaseMaintenance());
    let postQueueBusy = false;
    let supabaseInitPromise = null;
    const SAMPLE_COLORS = ['#7dd3fc','#f472b6','#facc15','#34d399','#c084fc','#60a5fa','#f59e0b','#a3e635','#f43f5e','#38bdf8'];
    const PLACEHOLDERS = Array.from({ length: 10 }, (_, i) => ({
      id: 100000 + i,
      title: `サンプル${i + 1}`,
      name: `サンプル${i + 1}`,
      width: 512,
      height: 512,
      colors: 256,
      image_url: '',
      thumb_url: '',
      image_base64: makePlaceholder(SAMPLE_COLORS[i % SAMPLE_COLORS.length]),
      submitted_at: new Date().toISOString(),
      likeCount: 0,
      mode: i % 2 === 0 ? 'timed10' : 'free',
      color: SAMPLE_COLORS[i % SAMPLE_COLORS.length]
    }));

    const NFAV_SRC = '../pixiedraw/assets/NFav.png';
    const FAV_SRC = '../pixiedraw/assets/Fav.png';

    function $(id){ return document.getElementById(id); }

    const AVATARS = [
      { id:'mao', type:'img', src:'../character-dots/mao1.png' },
      { id:'jerin1', type:'img', src:'../character-dots/Jerin1.png' },
      { id:'jerin2', type:'img', src:'../character-dots/Jerin2.png' },
      { id:'jerin3', type:'img', src:'../character-dots/Jerin3.png' },
      { id:'jerin4', type:'img', src:'../character-dots/Jerin4.png' },
      { id:'jerin5', type:'img', src:'../character-dots/Jerin5.png' },
      { id:'jerin6', type:'img', src:'../character-dots/Jerin6.png' },
      { id:'jerin7', type:'img', src:'../character-dots/Jerin7.png' },
      { id:'jerin8', type:'img', src:'../character-dots/Jerin8.png' },
      { id:'jellnall1', type:'img', src:'../character-dots/JELLNALL1.png' },
      { id:'jellnall2', type:'img', src:'../character-dots/JELLNALL2.png' },
      { id:'jellnall3', type:'img', src:'../character-dots/JELLNALL3.png' },
      { id:'jellnall4', type:'img', src:'../character-dots/JELLNALL4.png' },
      { id:'jellnall5', type:'img', src:'../character-dots/JELLNALL5.png' },
      { id:'jellnall6', type:'img', src:'../character-dots/JELLNALL6.png' },
      { id:'jellnall7', type:'img', src:'../character-dots/JELLNALL7.png' },
      { id:'jellnall8', type:'img', src:'../character-dots/JELLNALL8.png' },
      { id:'jellnall9', type:'img', src:'../character-dots/JELLNALL9.png' },
      { id:'jellnall10', type:'img', src:'../character-dots/JELLNALL10.png' },
      { id:'jellnall11', type:'img', src:'../character-dots/JELLNALL11.png' },
      { id:'jellnall12', type:'img', src:'../character-dots/JELLNALL12.png' },
      { id:'jellnall13', type:'img', src:'../character-dots/JELLNALL13.png' },
      { id:'jellnall14', type:'img', src:'../character-dots/JELLNALL14.png' },
      { id:'jellnall15', type:'img', src:'../character-dots/JELLNALL15.png' },
      { id:'jellnall16', type:'img', src:'../character-dots/JELLNALL16.png' },
      { id:'jellnall17', type:'img', src:'../character-dots/JELLNALL17.png' },
      { id:'jellnall18', type:'img', src:'../character-dots/JELLNALL18.png' },
      { id:'jellnall19', type:'img', src:'../character-dots/JELLNALL19.png' },
      { id:'baburin', type:'img', src:'../character-dots/baburinpng.png' }
    ];

    function loadNickname(){
      try{
        return localStorage.getItem('pixieed_nickname') || '';
      }catch(_){
        return '';
      }
    }

    function saveNickname(name){
      try{
        localStorage.setItem('pixieed_nickname', name);
      }catch(_){}
    }

    function loadXUrl(){
      try{
        return localStorage.getItem('pixieed_x_url') || '';
      }catch(_){
        return '';
      }
    }

    function normalizeXUrl(value){
      const raw = String(value || '').trim();
      if(!raw) return '';
      if(/^https?:\/\//i.test(raw)){
        try{
          const url = new URL(raw);
          const host = url.hostname.replace(/^www\./, '');
          if(host === 'x.com' || host.endsWith('.x.com') || host === 'twitter.com' || host.endsWith('.twitter.com')){
            return url.toString();
          }
        }catch(_){}
        return '';
      }
      const handle = raw.replace(/^@+/, '').trim();
      if(!handle) return '';
      const candidate = /^(x\.com|twitter\.com)\//i.test(handle)
        ? `https://${handle}`
        : `https://x.com/${handle}`;
      try{
        const url = new URL(candidate);
        const host = url.hostname.replace(/^www\./, '');
        if(host === 'x.com' || host.endsWith('.x.com') || host === 'twitter.com' || host.endsWith('.twitter.com')){
          return url.toString();
        }
      }catch(_){}
      return '';
    }

    function saveXUrl(value){
      try{
        const normalized = normalizeXUrl(value);
        if(normalized){
          localStorage.setItem('pixieed_x_url', normalized);
        }else{
          localStorage.removeItem('pixieed_x_url');
        }
      }catch(_){}
    }

    function updateNameDisplay(){
      const el = document.getElementById('nameDisplay');
      if(!el) return;
      const nick = loadNickname();
      el.textContent = nick || '未設定';
    }

    function loadAvatar(){
      try{
        return localStorage.getItem('pixieed_avatar') || 'mao';
      }catch(_){
        return 'mao';
      }
    }

    function saveAvatar(id){
      try{
        localStorage.setItem('pixieed_avatar', id);
      }catch(_){}
    }

    function ensureClientId(){
      const KEY = 'pixieed_client_id';
      try{
        const saved = localStorage.getItem(KEY) || window.PIXIEED_CLIENT_ID;
        if(saved){
          clientId = saved;
          if(!localStorage.getItem(KEY)) localStorage.setItem(KEY, saved);
          return;
        }
        const id = crypto.randomUUID ? crypto.randomUUID() : `guest-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
        localStorage.setItem(KEY, id);
        clientId = id;
      }catch(_){
        clientId = `guest-${Math.random().toString(36).slice(2,8)}`;
      }
    }

    function setStatus(msg){
      const el = $(STATUS_ID);
      if(el) el.textContent = msg || '';
    }

    function readSupabaseMaintenance(){
      try{
        const raw = localStorage.getItem(SUPABASE_MAINTENANCE_KEY);
        if(!raw) return null;
        const data = JSON.parse(raw);
        if(data && data.active) return data;
      }catch(_){
        // ignore
      }
      return null;
    }

    function isSupabaseMaintenance(){
      return supabaseMaintenance;
    }

    function setSupabaseMaintenance(active, reason = ''){
      supabaseMaintenance = active;
      try{
        if(active){
          localStorage.setItem(SUPABASE_MAINTENANCE_KEY, JSON.stringify({ active: true, reason, ts: Date.now() }));
        }else{
          localStorage.removeItem(SUPABASE_MAINTENANCE_KEY);
        }
      }catch(_){
        // ignore
      }
      if(active){
        setStatus('メンテ中のため投稿はキューに保存されます');
      }
    }

    function noteSupabaseSuccess(){
      if(supabaseMaintenance){
        setSupabaseMaintenance(false);
      }
    }

    function shouldMarkSupabaseMaintenance(error){
      const status = Number(error?.status || error?.statusCode || 0);
      if(status >= 500) return true;
      const msg = String(error?.message || '').toLowerCase();
      return msg.includes('failed to fetch') || msg.includes('network') || msg.includes('fetch failed') || msg.includes('503') || msg.includes('502') || msg.includes('504');
    }

    function isPermissionError(error){
      const status = Number(error?.status || error?.statusCode || 0);
      if(status === 401 || status === 403) return true;
      const msg = String(error?.message || '').toLowerCase();
      return msg.includes('permission') || msg.includes('not authorized') || msg.includes('row-level security');
    }

    function parseMissingColumn(error){
      const msg = String(error?.message || error || '');
      const match = msg.match(/column \"([^\"]+)\"/) || msg.match(/'([a-z0-9_]+)' column/i);
      return match ? match[1] : null;
    }

    function markSupabaseMaintenanceFromError(error){
      if(shouldMarkSupabaseMaintenance(error)){
        setSupabaseMaintenance(true, 'network');
      }
    }

    function setPostPreview(dataUrl){
      const wrap = document.getElementById('postPreview');
      const img = document.getElementById('postPreviewImage');
      if(!wrap || !img) return;
      if(dataUrl){
        img.src = dataUrl;
        wrap.classList.add('is-filled');
      }else{
        img.removeAttribute('src');
        wrap.classList.remove('is-filled');
      }
    }

    function resolveEntryThumb(entry){
      if(!entry) return '';
      return entry.thumb_url || entry.image_url || entry.image_base64 || '';
    }

    function resolveEntryImage(entry){
      if(!entry) return '';
      return entry.image_url || entry.image_base64 || entry.thumb_url || '';
    }

    function dataUrlToFile(dataUrl, filename){
      if(!dataUrl) return null;
      const parts = dataUrl.split(',');
      if(parts.length < 2) return null;
      const match = parts[0].match(/data:(.*?);base64/);
      const mime = match ? match[1] : 'image/png';
      const binary = atob(parts[1]);
      const bytes = new Uint8Array(binary.length);
      for(let i = 0; i < binary.length; i++){
        bytes[i] = binary.charCodeAt(i);
      }
      return new File([bytes], filename, { type: mime });
    }

    async function dataUrlToBlob(dataUrl){
      const response = await fetch(dataUrl);
      if(!response.ok) throw new Error('data url parse failed');
      return await response.blob();
    }

    function loadPostQueue(){
      try{
        const raw = localStorage.getItem(POST_QUEUE_KEY);
        if(!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      }catch(_){
        return [];
      }
    }

    function savePostQueue(queue){
      try{
        localStorage.setItem(POST_QUEUE_KEY, JSON.stringify(queue.slice(0, POST_QUEUE_LIMIT)));
      }catch(_){
        // ignore
      }
    }

    function normalizePostTask(task){
      if(!task) return null;
      const dataUrl = typeof task.dataUrl === 'string' ? task.dataUrl : '';
      if(!dataUrl) return null;
      const queueId = task.queueId || (crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2,8)}`);
      return {
        queueId,
        name: task.name || '名無し',
        title: task.title || '無題',
        tags: Array.isArray(task.tags) ? task.tags.slice(0, MAX_TAGS) : [],
        allowDownload: !!task.allowDownload,
        requirePasscode: !!task.requirePasscode,
        passcode: task.passcode || '',
        prompt: task.prompt || '自由投稿',
        mode: task.mode || 'free',
        submitted_at: task.submitted_at || new Date().toISOString(),
        width: Number.isFinite(task.width) ? task.width : null,
        height: Number.isFinite(task.height) ? task.height : null,
        colors: Number.isFinite(task.colors) ? task.colors : null,
        hash: task.hash || null,
        phash: task.phash || null,
        userId: task.userId || null,
        clientId: task.clientId || null,
        xUrl: normalizeXUrl(task.xUrl || ''),
        dataUrl,
      };
    }

    function queuePostTask(task){
      const normalized = normalizePostTask(task);
      if(!normalized) return false;
      const queue = loadPostQueue();
      const next = queue.filter(item => item.queueId !== normalized.queueId);
      next.unshift(normalized);
      savePostQueue(next);
      return true;
    }

    function applyInsertFallback(payload, error, imageInfo){
      const missing = parseMissingColumn(error);
      if(!missing) return false;
      if(supportsTags && missing === 'tags'){
        supportsTags = false;
        delete payload.tags;
        return true;
      }
      if(supportsDownloadSettings && (missing === 'allow_download' || missing === 'download_passcode')){
        supportsDownloadSettings = false;
        delete payload.allow_download;
        delete payload.download_passcode;
        return true;
      }
      if(supportsImageUrls && (missing === 'image_url' || missing === 'thumb_url')){
        supportsImageUrls = false;
        delete payload.image_url;
        delete payload.thumb_url;
        if(!payload.image_base64 && imageInfo?.dataUrl){
          payload.image_base64 = imageInfo.dataUrl;
        }
        return true;
      }
      if(supportsClientId && missing === 'client_id'){
        supportsClientId = false;
        delete payload.client_id;
        return true;
      }
      if(supportsUserId && missing === 'user_id'){
        supportsUserId = false;
        delete payload.user_id;
        return true;
      }
      if(supportsXUrl && missing === 'x_url'){
        supportsXUrl = false;
        delete payload.x_url;
        return true;
      }
      if(supportsImageHash && missing === 'image_hash'){
        supportsImageHash = false;
        delete payload.image_hash;
        return true;
      }
      if(supportsPhash && missing === 'phash'){
        supportsPhash = false;
        delete payload.phash;
        return true;
      }
      return false;
    }

    async function ensureSupabaseReady(){
      if(supabase){
        if(!isSupabaseMaintenance()) return true;
        try{
          const { error } = await supabase
            .from('contest_entries')
            .select('id')
            .limit(1);
          if(error){
            markSupabaseMaintenanceFromError(error);
            return false;
          }
          noteSupabaseSuccess();
          return true;
        }catch(err){
          markSupabaseMaintenanceFromError(err);
          return false;
        }
      }
      await initSupabase();
      return !!supabase;
    }

    async function buildImageInfoFromTask(task){
      const imageBlob = await dataUrlToBlob(task.dataUrl);
      const img = await createImageBitmap(imageBlob);
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      if(!ctx) throw new Error('canvas init failed');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0);
      const thumbCanvas = createThumbnailCanvas(canvas);
      const thumbBlob = await canvasToBlob(thumbCanvas, 'image/png');
      return {
        width: Number.isFinite(task.width) ? task.width : img.width,
        height: Number.isFinite(task.height) ? task.height : img.height,
        colors: Number.isFinite(task.colors) ? task.colors : null,
        dataUrl: task.dataUrl,
        hash: task.hash,
        phash: task.phash,
        imageBlob,
        thumbBlob,
      };
    }

    async function flushPostQueue(){
      if(postQueueBusy) return;
      const queue = loadPostQueue();
      if(!queue.length) return;
      const ready = await ensureSupabaseReady();
      if(!ready) return;
      postQueueBusy = true;
      const remaining = [];
      let posted = false;
      for(const task of queue){
        try{
          const normalized = normalizePostTask(task);
          if(!normalized) continue;
          const imageInfo = await buildImageInfoFromTask(normalized);
          let uploadResult = null;
          if(supabase && supportsImageUrls){
            uploadResult = await uploadContestImages(imageInfo);
          }
          const payload = {
            name: normalized.name,
            title: normalized.title,
            prompt: normalized.prompt,
            mode: normalized.mode,
            started_at: null,
            submitted_at: normalized.submitted_at,
            width: imageInfo.width,
            height: imageInfo.height,
            colors: imageInfo.colors
          };
          payload.image_base64 = imageInfo.dataUrl;
          if(supportsImageHash){
            payload.image_hash = imageInfo.hash;
          }
          if(supportsPhash){
            payload.phash = imageInfo.phash;
          }
          if(supportsImageUrls && uploadResult){
            payload.image_url = uploadResult.imageUrl;
            payload.thumb_url = uploadResult.thumbUrl;
          }
          if(supportsTags && normalized.tags.length){
            payload.tags = normalized.tags.join(',');
          }
          if(supportsDownloadSettings){
            payload.allow_download = normalized.allowDownload;
            payload.download_passcode = normalized.allowDownload && normalized.requirePasscode ? normalized.passcode : null;
          }
          if(supportsXUrl && normalized.xUrl){
            payload.x_url = normalized.xUrl;
          }
          if(normalized.userId && supportsUserId){
            payload.user_id = normalized.userId;
          }
          if(supportsClientId && normalized.clientId){
            payload.client_id = normalized.clientId;
          }
          let res = null;
          for(let attempt = 0; attempt < 3; attempt++){
            res = await supabase.from('contest_entries').insert(payload).select('id');
            if(!res.error) break;
            if(applyInsertFallback(payload, res.error, imageInfo)){
              continue;
            }
            break;
          }
          if(res?.error){
            throw res.error;
          }
          noteSupabaseSuccess();
          posted = true;
        }catch(err){
          if(isPermissionError(err)){
            setStatus('投稿権限がありません。ログインまたは権限設定をご確認ください。');
            remaining.push(task);
            break;
          }
          remaining.push(task);
          markSupabaseMaintenanceFromError(err);
          if(isSupabaseMaintenance()) break;
        }
      }
      savePostQueue(remaining);
      postQueueBusy = false;
      if(posted){
        setStatus('キューに保存した投稿を自動送信しました。');
        await fetchAndRender();
      }
    }

    function schedulePostQueueFlush(){
      window.addEventListener('online', () => {
        flushPostQueue().catch(err => console.warn('post queue flush failed', err));
      });
      window.setInterval(() => {
        if(isSupabaseMaintenance() || loadPostQueue().length){
          flushPostQueue().catch(err => console.warn('post queue flush failed', err));
        }
      }, POST_QUEUE_RETRY_MS);
    }

    function restorePendingUpload(){
      let payload;
      try{
        const raw = localStorage.getItem(PENDING_UPLOAD_KEY);
        if(!raw) return;
        localStorage.removeItem(PENDING_UPLOAD_KEY);
        payload = JSON.parse(raw);
      }catch(err){
        console.warn('pending upload parse failed', err);
        return;
      }
      const dataUrl = payload?.dataUrl;
      if(!dataUrl) return;
      const file = dataUrlToFile(dataUrl, `pixieedrawlite-${payload?.canvasSize || ''}px.png`);
      if(!file) return;
      const input = $(FILE_INPUT_ID);
      if(!input) return;
      try{
        const dt = new DataTransfer();
        dt.items.add(file);
        input.files = dt.files;
      }catch(err){
        console.warn('file inject failed', err);
        return;
      }
      const openBtn = document.getElementById('openPostPanel');
      if(openBtn){
        openBtn.click();
      }
      setPostPreview(dataUrl);
      setStatus('画像を読み込みました。内容を確認して投稿してください。');
    }

    function setAuthStatus(msg){
      const el = document.getElementById('authStatus');
      if(el) el.textContent = msg || '';
    }

    function applyAvatarToBrand(){
      const brand = document.getElementById('brandAvatar');
      const brandUser = document.getElementById('brandUser');
      const preview = document.getElementById('avatarPreview');
      const avatarId = loadAvatar();
      const found = AVATARS.find(a => a.id === avatarId);
      if(brand){
        if(found && found.type === 'img'){
          brand.style = 'border:1px solid rgba(255,255,255,0.25); background:rgba(255,255,255,0.08);';
          brand.innerHTML = `<img src="${found.src}" alt="avatar">`;
        }else if(found && found.style){
          brand.style = `${found.style} border:1px solid rgba(255,255,255,0.25);`;
          brand.innerHTML = '';
        }else{
          brand.style = 'border:1px solid rgba(255,255,255,0.25); background:rgba(255,255,255,0.08);';
          brand.innerHTML = `<img src="../character-dots/mao1.png" alt="logo">`;
        }
      }
      if(preview){
        if(found && found.type === 'img'){
          preview.innerHTML = `<img src="${found.src}" alt="avatar">`;
        }else{
          preview.innerHTML = `<img src="../character-dots/mao1.png" alt="avatar">`;
        }
      }
      if(brandUser){
        const nick = loadNickname();
        brandUser.textContent = nick || 'ユーザー';
      }
    }

    function renderAvatarChoices(){
      const grid = document.getElementById('avatarGrid');
      if(!grid) return;
      grid.innerHTML = '';
      const current = loadAvatar();
      AVATARS.forEach(a => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `avatar-option${current === a.id ? ' is-active' : ''}`;
        if(a.type === 'img' && a.src){
          btn.style = 'background:rgba(0,0,0,0.7);';
          const im = document.createElement('img');
          im.src = a.src;
          im.alt = a.id;
          im.style.width = '80%';
          im.style.height = '80%';
          im.style.objectFit = 'contain';
          im.style.pointerEvents = 'none';
          im.style.imageRendering = 'pixelated';
          im.style.imageRendering = 'crisp-edges';
          btn.appendChild(im);
        }else{
          btn.style = a.style;
          btn.textContent = '';
        }
        btn.addEventListener('click', () => {
          saveAvatar(a.id);
          renderAvatarChoices();
          applyAvatarToBrand();
          const panel = document.getElementById('avatarPanel');
          const toggle = document.getElementById('avatarToggle');
          if(panel){
            panel.hidden = true;
          }
          if(toggle){
            toggle.setAttribute('aria-expanded','false');
          }
        });
        grid.appendChild(btn);
      });
    }

    function setupAvatarToggle(){
      const toggle = document.getElementById('avatarToggle');
      const panel = document.getElementById('avatarPanel');
      if(!toggle || !panel) return;
      const setOpen = (open) => {
        panel.hidden = !open;
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      };
      setOpen(false);
      toggle.addEventListener('click', () => {
        setOpen(panel.hidden);
      });
    }

    function setupTabs(){
      const filterTabs = document.getElementById('filterTabs');
      const sortTabs = document.getElementById('sortTabs');
      if(filterTabs){
        filterTabs.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            currentFilter = btn.dataset.filter || 'all';
            filterTabs.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('is-active', b === btn));
            renderEntries(applyFilterAndSort(cachedEntries));
          });
        });
      }
      if(sortTabs){
        sortTabs.querySelectorAll('.sort-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            currentSort = btn.dataset.sort || 'new';
            sortTabs.querySelectorAll('.sort-btn').forEach(b => b.classList.toggle('is-active', b === btn));
            renderEntries(applyFilterAndSort(cachedEntries));
          });
        });
      }
    }

    function normalizeTag(value){
      return String(value || '').replace(/^[#＃]+/, '').trim();
    }

    function parseTags(value){
      if(!value) return [];
      const raw = Array.isArray(value) ? value : String(value).split(',');
      const out = [];
      raw.forEach(tag => {
        const normalized = normalizeTag(tag);
        if(!normalized) return;
        if(!out.some(t => t.toLowerCase() === normalized.toLowerCase())){
          out.push(normalized);
        }
      });
      return out;
    }

    function renderPostTags(){
      const list = $(TAG_LIST_ID);
      if(!list) return;
      list.innerHTML = '';
      if(!postTags.length) return;
      postTags.forEach(tag => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'tag-chip';
        chip.setAttribute('aria-label', `${tag} を削除`);
        const label = document.createElement('span');
        label.textContent = `#${tag}`;
        const remove = document.createElement('span');
        remove.className = 'tag-remove';
        remove.textContent = '×';
        chip.append(label, remove);
        chip.addEventListener('click', () => {
          postTags = postTags.filter(t => t.toLowerCase() !== tag.toLowerCase());
          renderPostTags();
        });
        list.appendChild(chip);
      });
    }

    function addTagsFromInput(){
      const input = $(TAG_INPUT_ID);
      if(!input) return;
      const raw = input.value;
      if(!raw) return;
      const candidates = raw.split(/[,，、。．\s]+/).map(normalizeTag).filter(Boolean);
      candidates.forEach(tag => {
        if(postTags.length >= MAX_TAGS) return;
        if(!postTags.some(t => t.toLowerCase() === tag.toLowerCase())){
          postTags.push(tag);
        }
      });
      input.value = '';
      renderPostTags();
    }

    function setupTagInput(){
      const input = $(TAG_INPUT_ID);
      const btn = $(ADD_TAG_BTN_ID);
      if(!input) return;
      if(btn) btn.addEventListener('click', addTagsFromInput);
      input.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          addTagsFromInput();
        }
      });
      renderPostTags();
    }

    function setupTagSearch(){
      const input = $(TAG_SEARCH_ID);
      if(!input) return;
      input.addEventListener('input', () => {
        const raw = normalizeTag(input.value);
        currentTagQuery = raw.toLowerCase();
        renderEntries(applyFilterAndSort(cachedEntries));
      });
    }

    function updateLoadMoreUI(){
      const wrap = $(LOAD_MORE_WRAP_ID);
      const btn = $(LOAD_MORE_BTN_ID);
      if(!wrap || !btn) return;
      wrap.hidden = !hasMoreEntries;
      btn.disabled = isLoadingEntries;
      btn.textContent = isLoadingEntries ? '読み込み中...' : 'もっと見る';
    }

    function setupLoadMore(){
      const btn = $(LOAD_MORE_BTN_ID);
      if(!btn) return;
      btn.addEventListener('click', () => {
        fetchAndRender({ append: true });
      });
    }

    function updateDownloadSettingsUI(){
      const allow = $(ALLOW_DOWNLOAD_ID);
      const requirePass = $(REQUIRE_PASSCODE_ID);
      const passInput = $(PASSCODE_INPUT_ID);
      const wrap = $(PASSCODE_WRAP_ID);
      if(!allow || !requirePass || !passInput || !wrap) return;
      if(!allow.checked){
        wrap.hidden = true;
        requirePass.checked = false;
        passInput.value = '';
        passInput.disabled = true;
        return;
      }
      wrap.hidden = false;
      passInput.disabled = !requirePass.checked;
      if(!requirePass.checked){
        passInput.value = '';
      }
    }

    function setupDownloadSettings(){
      const allow = $(ALLOW_DOWNLOAD_ID);
      const requirePass = $(REQUIRE_PASSCODE_ID);
      if(allow) allow.addEventListener('change', updateDownloadSettingsUI);
      if(requirePass) requirePass.addEventListener('change', updateDownloadSettingsUI);
      updateDownloadSettingsUI();
    }

    function createStorageKey(prefix){
      const seed = (typeof crypto !== 'undefined' && crypto.randomUUID)
        ? crypto.randomUUID()
        : `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      const date = new Date().toISOString().slice(0,10).replace(/-/g, '');
      return `${prefix}/${date}/${seed}`;
    }

    function canvasToBlob(canvas, type = 'image/png'){
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if(blob) resolve(blob);
          else reject(new Error('blob create failed'));
        }, type);
      });
    }

    function createThumbnailCanvas(source){
      const max = Math.max(source.width, source.height);
      const scale = Math.min(1, THUMB_SIZE / max);
      if(scale >= 1){
        return source;
      }
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(source.width * scale));
      canvas.height = Math.max(1, Math.round(source.height * scale));
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
      return canvas;
    }

    function normalizePixelCanvas(sourceCanvas){
      const width = sourceCanvas.width;
      const height = sourceCanvas.height;
      const sourceCtx = sourceCanvas.getContext('2d');
      if(!sourceCtx) return { canvas: sourceCanvas, ctx: sourceCtx, width, height };
      let imageData;
      try{
        imageData = sourceCtx.getImageData(0, 0, width, height);
      }catch(_){
        return { canvas: sourceCanvas, ctx: sourceCtx, width, height };
      }
      const scaleX = detectScaleFactor(imageData, width, height, 'x');
      const scaleY = detectScaleFactor(imageData, width, height, 'y');
      let scale = Math.max(1, Math.min(scaleX, scaleY));
      const blockScale = detectScaleFactorByBlocks(imageData, width, height);
      if(blockScale > scale){
        scale = blockScale;
      }
      if(scale <= 1){
        return { canvas: sourceCanvas, ctx: sourceCtx, width, height };
      }
      const targetWidth = Math.max(1, Math.round(width / scale));
      const targetHeight = Math.max(1, Math.round(height / scale));
      const targetCanvas = document.createElement('canvas');
      targetCanvas.width = targetWidth;
      targetCanvas.height = targetHeight;
      const targetCtx = targetCanvas.getContext('2d');
      if(!targetCtx) return { canvas: sourceCanvas, ctx: sourceCtx, width, height };
      const targetData = targetCtx.createImageData(targetWidth, targetHeight);
      const src = imageData.data;
      const dest = targetData.data;
      for(let y=0; y<targetHeight; y++){
        for(let x=0; x<targetWidth; x++){
          const srcIndex = ((y * scale) * width + (x * scale)) * 4;
          const destIndex = (y * targetWidth + x) * 4;
          dest[destIndex] = src[srcIndex];
          dest[destIndex + 1] = src[srcIndex + 1];
          dest[destIndex + 2] = src[srcIndex + 2];
          dest[destIndex + 3] = src[srcIndex + 3];
        }
      }
      targetCtx.putImageData(targetData, 0, 0);
      return { canvas: targetCanvas, ctx: targetCtx, width: targetWidth, height: targetHeight };
    }

    function detectScaleFactor(imageData, width, height, axis){
      const { data } = imageData;
      const length = axis === 'x' ? width : height;
      const compare = axis === 'x'
        ? (indexA, indexB) => columnsMatch(data, width, height, indexA, indexB)
        : (indexA, indexB) => rowsMatch(data, width, height, indexA, indexB);

      let run = 1;
      let best = 0;
      for(let i=1; i<length; i++){
        if(compare(i, i - 1)){
          run += 1;
        }else{
          best = best ? gcd(best, run) : run;
          run = 1;
        }
      }
      best = best ? gcd(best, run) : run;
      return Math.max(1, best);
    }

    function detectScaleFactorByBlocks(imageData, width, height){
      const common = gcd(width, height);
      if(common <= 1) return 1;
      const candidates = getDivisors(common).filter(value => value > 1).sort((a, b) => b - a);
      for(const factor of candidates){
        if(isLikelyUpscaledByFactor(imageData.data, width, height, factor)){
          return factor;
        }
      }
      return 1;
    }

    function isLikelyUpscaledByFactor(data, width, height, factor){
      const totalPixels = width * height;
      const allowedMismatch = Math.floor(totalPixels * (1 - NORMALIZE_MATCH_RATIO));
      let mismatches = 0;
      for(let blockY=0; blockY<height; blockY+=factor){
        for(let blockX=0; blockX<width; blockX+=factor){
          const baseIndex = (blockY * width + blockX) * 4;
          const baseR = data[baseIndex];
          const baseG = data[baseIndex + 1];
          const baseB = data[baseIndex + 2];
          const baseA = data[baseIndex + 3];
          for(let y=0; y<factor; y++){
            const rowStart = (blockY + y) * width;
            for(let x=0; x<factor; x++){
              const idx = (rowStart + blockX + x) * 4;
              if(!isColorNear(data, idx, baseR, baseG, baseB, baseA)){
                mismatches += 1;
                if(mismatches > allowedMismatch){
                  return false;
                }
              }
            }
          }
        }
      }
      return true;
    }

    function isColorNear(data, idx, r, g, b, a){
      return (
        Math.abs(data[idx] - r) <= NORMALIZE_COLOR_TOLERANCE &&
        Math.abs(data[idx + 1] - g) <= NORMALIZE_COLOR_TOLERANCE &&
        Math.abs(data[idx + 2] - b) <= NORMALIZE_COLOR_TOLERANCE &&
        Math.abs(data[idx + 3] - a) <= NORMALIZE_COLOR_TOLERANCE
      );
    }

    function getDivisors(value){
      const divisors = new Set();
      for(let i=2; i<=Math.sqrt(value); i+=1){
        if(value % i === 0){
          divisors.add(i);
          divisors.add(value / i);
        }
      }
      divisors.add(value);
      return Array.from(divisors);
    }

    function columnsMatch(data, width, height, a, b){
      for(let y=0; y<height; y++){
        const idxA = (y * width + a) * 4;
        const idxB = (y * width + b) * 4;
        if(
          data[idxA] !== data[idxB] ||
          data[idxA + 1] !== data[idxB + 1] ||
          data[idxA + 2] !== data[idxB + 2] ||
          data[idxA + 3] !== data[idxB + 3]
        ){
          return false;
        }
      }
      return true;
    }

    function rowsMatch(data, width, height, a, b){
      const rowLength = width * 4;
      const startA = a * rowLength;
      const startB = b * rowLength;
      for(let offset=0; offset<rowLength; offset++){
        if(data[startA + offset] !== data[startB + offset]){
          return false;
        }
      }
      return true;
    }

    function gcd(a, b){
      while(b !== 0){
        const temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    async function uploadContestImages(imageInfo){
      if(!supabase || !supportsStorageUploads || !imageInfo?.imageBlob || !imageInfo?.thumbBlob) return null;
      const baseKey = createStorageKey('entries');
      const imagePath = `${baseKey}.png`;
      const thumbPath = `${baseKey}_thumb.png`;
      try{
        const { error: imageError } = await supabase
          .storage
          .from(STORAGE_BUCKET)
          .upload(imagePath, imageInfo.imageBlob, {
            contentType: 'image/png',
            cacheControl: '31536000',
            upsert: false
          });
        if(imageError) throw imageError;
        const { error: thumbError } = await supabase
          .storage
          .from(STORAGE_BUCKET)
          .upload(thumbPath, imageInfo.thumbBlob, {
            contentType: 'image/png',
            cacheControl: '31536000',
            upsert: false
          });
        if(thumbError) throw thumbError;
        const imageUrl = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(imagePath).data.publicUrl;
        const thumbUrl = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(thumbPath).data.publicUrl;
        return { imageUrl, thumbUrl };
      }catch(err){
        console.warn('storage upload failed', err);
        markSupabaseMaintenanceFromError(err);
        const msg = String(err?.message || '').toLowerCase();
        if(msg.includes('bucket') || msg.includes('storage') || msg.includes('not found')){
          supportsStorageUploads = false;
        }
        return null;
      }
    }

    function escapeHtml(value){
      return String(value ?? '').replace(/[&<>"']/g, (ch) => (
        { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch] || ch
      ));
    }

    function isStorageExistsError(error){
      const status = Number(error?.status || error?.statusCode || 0);
      if(status === 409) return true;
      const msg = String(error?.message || '').toLowerCase();
      return msg.includes('exists');
    }

    function truncateText(ctx, text, maxWidth){
      let output = String(text ?? '');
      if(!output) return '';
      if(ctx.measureText(output).width <= maxWidth) return output;
      while(output.length > 1 && ctx.measureText(`${output}…`).width > maxWidth){
        output = output.slice(0, -1);
      }
      return output.length > 1 ? `${output}…` : output;
    }

    function encodeStoragePath(path){
      return path.split('/').map(segment => encodeURIComponent(segment)).join('/');
    }

    function getContestPublicUrl(path){
      if(supabase?.storage){
        return supabase.storage.from(STORAGE_BUCKET).getPublicUrl(path).data.publicUrl;
      }
      return `${SUPABASE_URL}/storage/v1/object/public/${STORAGE_BUCKET}/${encodeStoragePath(path)}`;
    }

    function buildShareHtml({ title, description, imageUrl, shareUrl, targetUrl }){
      const safeTitle = escapeHtml(title);
      const safeDescription = escapeHtml(description);
      const safeImage = escapeHtml(imageUrl);
      const safeShareUrl = escapeHtml(shareUrl);
      const safeTargetUrl = escapeHtml(targetUrl);
      return `<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>${safeTitle}</title>
  <meta name="description" content="${safeDescription}"/>
  <meta property="og:type" content="website"/>
  <meta property="og:title" content="${safeTitle}"/>
  <meta property="og:description" content="${safeDescription}"/>
  <meta property="og:image" content="${safeImage}"/>
  <meta property="og:image:width" content="${CONTEST_SHARE_OGP_WIDTH}"/>
  <meta property="og:image:height" content="${CONTEST_SHARE_OGP_HEIGHT}"/>
  <meta property="og:url" content="${safeShareUrl}"/>
  <meta property="og:site_name" content="PiXiEED"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:title" content="${safeTitle}"/>
  <meta name="twitter:description" content="${safeDescription}"/>
  <meta name="twitter:image" content="${safeImage}"/>
  <meta http-equiv="refresh" content="0; url=${safeTargetUrl}"/>
  <link rel="canonical" href="${safeTargetUrl}"/>
  <style>body{margin:0;font-family:sans-serif;background:#0f172a;color:#e2e8f0;display:flex;align-items:center;justify-content:center;min-height:100vh}</style>
</head>
<body>
  <p>Redirecting...</p>
  <script>window.location.replace('${safeTargetUrl}');<\/script>
</body>
</html>`;
    }

    function drawContainImage(ctx, image, x, y, width, height){
      if(!ctx || !image) return;
      const iw = image.width || 1;
      const ih = image.height || 1;
      const scale = Math.min(width / iw, height / ih);
      const dw = Math.max(1, Math.round(iw * scale));
      const dh = Math.max(1, Math.round(ih * scale));
      const dx = Math.round(x + (width - dw) / 2);
      const dy = Math.round(y + (height - dh) / 2);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(image, dx, dy, dw, dh);
    }

    async function createContestOgpBlob({ title, imageBlob }){
      if(!imageBlob) return null;
      let bitmap = null;
      try{
        bitmap = await createImageBitmap(imageBlob);
      }catch(_){
        return null;
      }
      const canvas = document.createElement('canvas');
      canvas.width = CONTEST_SHARE_OGP_WIDTH;
      canvas.height = CONTEST_SHARE_OGP_HEIGHT;
      const ctx = canvas.getContext('2d');
      if(!ctx) return null;

      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#0f172a');
      gradient.addColorStop(1, '#1e293b');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#f8fafc';
      ctx.font = `600 ${CONTEST_SHARE_TITLE_SIZE}px 'DotGothic16', sans-serif`;
      ctx.textBaseline = 'top';
      const maxTitleWidth = canvas.width - CONTEST_SHARE_PADDING * 2;
      const titleText = truncateText(ctx, title || '作品', maxTitleWidth);
      ctx.fillText(titleText, CONTEST_SHARE_PADDING, CONTEST_SHARE_PADDING);

      const top = CONTEST_SHARE_PADDING + CONTEST_SHARE_TITLE_SIZE + 20;
      const availableHeight = canvas.height - top - CONTEST_SHARE_PADDING;
      const availableWidth = canvas.width - CONTEST_SHARE_PADDING * 2;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 2;
      ctx.fillRect(CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      ctx.strokeRect(CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      drawContainImage(ctx, bitmap, CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      return await canvasToBlob(canvas, 'image/png');
    }

    async function uploadContestShareAssets({ entryId, title, imageInfo }){
      if(!supabase || !supportsStorageUploads || !entryId || !imageInfo?.imageBlob) return null;
      const ogpBlob = await createContestOgpBlob({ title, imageBlob: imageInfo.imageBlob });
      if(!ogpBlob) return null;
      const ogpPath = `share/${entryId}.png`;
      const sharePath = `share/${entryId}.html`;
      const ogpUrl = getContestPublicUrl(ogpPath);
      const shareUrl = getContestPublicUrl(sharePath);
      const targetUrl = `${CONTEST_SHARE_BASE_URL}?id=${entryId}`;
      const html = buildShareHtml({
        title: `PiXiEED | ${title || '作品'}`,
        description: 'PiXiEEDのドット作品',
        imageUrl: ogpUrl,
        shareUrl,
        targetUrl,
      });
      const htmlBlob = new Blob([html], { type: 'text/html; charset=utf-8' });
      try{
        const bucket = supabase.storage.from(STORAGE_BUCKET);
        const { error: ogpError } = await bucket.upload(ogpPath, ogpBlob, {
          contentType: 'image/png',
          cacheControl: '31536000',
          upsert: false
        });
        if(ogpError){
          if(isStorageExistsError(ogpError)){
            if(typeof bucket.update === 'function'){
              const { error: ogpUpdateError } = await bucket.update(ogpPath, ogpBlob, {
                contentType: 'image/png',
                cacheControl: '31536000'
              });
              if(ogpUpdateError){
                console.warn('share ogp overwrite failed', ogpUpdateError);
              }
            }
          }else{
            throw ogpError;
          }
        }
        const { error: htmlError } = await bucket.upload(sharePath, htmlBlob, {
          contentType: 'text/html; charset=utf-8',
          cacheControl: '3600',
          upsert: false
        });
        if(htmlError){
          if(isStorageExistsError(htmlError)){
            if(typeof bucket.update === 'function'){
              const { error: htmlUpdateError } = await bucket.update(sharePath, htmlBlob, {
                contentType: 'text/html; charset=utf-8',
                cacheControl: '3600'
              });
              if(htmlUpdateError){
                console.warn('share html overwrite failed', htmlUpdateError);
              }
            }
          }else{
            throw htmlError;
          }
        }
        return { shareUrl, ogpUrl };
      }catch(err){
        console.warn('share upload failed', err);
        markSupabaseMaintenanceFromError(err);
        const msg = String(err?.message || '').toLowerCase();
        if(msg.includes('bucket') || msg.includes('storage') || msg.includes('not found')){
          supportsStorageUploads = false;
        }
        return null;
      }
    }

    async function fileToImageInfo(file){
      const type = (file.type || '').toLowerCase();
      if(type !== 'image/png' && type !== 'image/gif'){
        throw new Error('PNGまたはGIFのみ投稿できます');
      }
      const img = await createImageBitmap(file);
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0);

      const normalized = normalizePixelCanvas(canvas);
      const nCanvas = normalized.canvas;
      const nWidth = normalized.width;
      const nHeight = normalized.height;
      if(nWidth > MAX_SIZE || nHeight > MAX_SIZE){
        throw new Error(`元サイズは${MAX_SIZE}x${MAX_SIZE}以内にしてください`);
      }

      // 余白をトリミング
      const trimmed = trimTransparent(nCanvas);
      const tCanvas = trimmed.canvas;
      const tCtx = trimmed.ctx;
      const tWidth = tCanvas.width;
      const tHeight = tCanvas.height;

      // 色数チェック（トリミング後ベース）
      const baseData = tCtx.getImageData(0,0,tWidth,tHeight).data;
      const colors = new Set();
      for(let i=0;i<baseData.length;i+=4){
        colors.add(`${baseData[i]}-${baseData[i+1]}-${baseData[i+2]}-${baseData[i+3]}`);
        if(colors.size > MAX_COLORS){
          throw new Error(`色数は${MAX_COLORS}色以内にしてください`);
        }
      }

      // 近似ハッシュ用に小さく縮小（16x16グレースケール）
      const phash = await computePHash(tCanvas);
      const hash = await hashUint8(new Uint8Array(baseData));

      // GIFもPNGサムネに変換して保存（トリミング後のキャンバスを使用）
      const dataUrl = tCanvas.toDataURL('image/png');
      const thumbCanvas = createThumbnailCanvas(tCanvas);
      const imageBlob = await canvasToBlob(tCanvas, 'image/png');
      const thumbBlob = await canvasToBlob(thumbCanvas, 'image/png');
      return { width: tWidth, height: tHeight, colors: colors.size, dataUrl, hash, phash, imageBlob, thumbBlob };
    }

    function drawWatermark(ctx, width, height){
      ctx.save();
      const size = Math.max(12, Math.round(Math.min(width, height) * 0.08));
      ctx.font = `${size}px 'DotGothic16', sans-serif`;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.textBaseline = 'bottom';
      ctx.textAlign = 'right';
      ctx.filter = 'drop-shadow(0 0 6px rgba(0,0,0,0.45))';
      ctx.fillText('PiXiEED', width - 8, height - 6);
      ctx.restore();
    }

    async function embedInvisibleHash(canvas){
      const ctx = canvas.getContext('2d');
      const { width, height } = canvas;
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      const hashBytes = await createHashBytes(`${clientId || 'guest'}-${Date.now()}-${Math.random()}`);
      const bitsNeeded = hashBytes.length * 8;
      // 透過ピクセルには書き込まない（透過面で白い点が出るのを防ぐ）
      const opaquePixels = [];
      for(let p=0; p<data.length/4; p++){
        const a = data[p*4 + 3];
        if(a >= 200) opaquePixels.push(p);
      }
      if(!opaquePixels.length) return;
      let bitIndex = 0;
      for(let i=0; i<bitsNeeded && i<opaquePixels.length; i++){
        const byte = hashBytes[Math.floor(bitIndex / 8)];
        const bit = (byte >> (bitIndex % 8)) & 1;
        const pix = opaquePixels[opaquePixels.length - 1 - i]; // 末尾側から
        const dataIndex = pix * 4 + 3; // alpha
        data[dataIndex] = (data[dataIndex] & 0xFE) | bit;
        bitIndex++;
      }
      ctx.putImageData(imageData, 0, 0);
    }

    async function createHashBytes(text){
      const enc = new TextEncoder().encode(text);
      try{
        const buf = await crypto.subtle.digest('SHA-256', enc);
        return new Uint8Array(buf).slice(0, 16); // 128bit
      }catch(_){
        // Fallback: simple hash
        let h = 0;
        for(const b of enc){ h = (h * 31 + b) >>> 0; }
        const arr = new Uint8Array(16);
        for(let i=0;i<16;i++){
          h = (h * 1664525 + 1013904223) >>> 0;
          arr[i] = h & 0xFF;
        }
        return arr;
      }
    }

    async function hashUint8(uint8){
      try{
        const buf = await crypto.subtle.digest('SHA-256', uint8);
        return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('');
      }catch(_){
        let h = 0;
        for(const b of uint8){ h = (h * 31 + b) >>> 0; }
        let out = '';
        for(let i=0;i<16;i++){
          h = (h * 1664525 + 1013904223) >>> 0;
          out += (h & 0xff).toString(16).padStart(2,'0');
        }
        return out;
      }
    }

    function trimTransparent(canvas){
      const ctx = canvas.getContext('2d');
      const { width, height } = canvas;
      const imgData = ctx.getImageData(0,0,width,height);
      const data = imgData.data;
      let minX = width, minY = height, maxX = -1, maxY = -1;
      for(let y=0; y<height; y++){
        for(let x=0; x<width; x++){
          const i = (y*width + x)*4;
          const a = data[i+3];
          if(a !== 0){
            if(x < minX) minX = x;
            if(y < minY) minY = y;
            if(x > maxX) maxX = x;
            if(y > maxY) maxY = y;
          }
        }
      }
      if(maxX === -1){ // 全部透明
        return { canvas, ctx };
      }
      const cropW = maxX - minX + 1;
      const cropH = maxY - minY + 1;
      const trimmed = document.createElement('canvas');
      trimmed.width = cropW;
      trimmed.height = cropH;
      const tCtx = trimmed.getContext('2d');
      tCtx.putImageData(ctx.getImageData(minX, minY, cropW, cropH), 0, 0);
      return { canvas: trimmed, ctx: tCtx };
    }

    async function computePHash(srcCanvas){
      // 16x16グレースケール平均ハッシュ
      const size = 16;
      const c = document.createElement('canvas');
      c.width = size;
      c.height = size;
      const ctx = c.getContext('2d');
      ctx.drawImage(srcCanvas, 0, 0, size, size);
      const img = ctx.getImageData(0,0,size,size).data;
      const gray = [];
      for(let i=0;i<img.length;i+=4){
        const g = img[i]*0.299 + img[i+1]*0.587 + img[i+2]*0.114;
        gray.push(g);
      }
      const avg = gray.reduce((a,b)=>a+b,0) / gray.length;
      let bits = '';
      gray.forEach(g => { bits += g > avg ? '1' : '0'; });
      return bits;
    }

    function hammingDistance(a, b){
      if(a.length !== b.length) return Infinity;
      let d = 0;
      for(let i=0;i<a.length;i++){
        if(a[i] !== b[i]) d++;
      }
      return d;
    }

    async function handleSubmit(e){
      e.preventDefault();
      const form = e.currentTarget;
      ensureClientId();
      const name = loadNickname() || '名無し';
      const xUrl = normalizeXUrl(loadXUrl());
      const title = form.title.value.trim() || '無題';
      const tags = postTags.slice(0, MAX_TAGS);
      const allowDownload = form[ALLOW_DOWNLOAD_ID]?.checked || false;
      const requirePasscode = form[REQUIRE_PASSCODE_ID]?.checked || false;
      const passcode = (form[PASSCODE_INPUT_ID]?.value || '').trim();
      const file = form[FILE_INPUT_ID]?.files?.[0];
      if(!file){
        setStatus('画像ファイルを選択してください');
        return;
      }
      if(allowDownload && requirePasscode){
        if(!passcode){
          setStatus('パスコードを入力してください');
          return;
        }
        if(!/^[a-zA-Z0-9]{4,12}$/.test(passcode)){
          setStatus('パスコードは英数字4〜12文字で入力してください');
          return;
        }
      }
      setStatus('画像を確認しています...');
      let imageInfo;
      try{
        imageInfo = await fileToImageInfo(file);
      }catch(err){
        setStatus(err.message || '画像の解析に失敗しました');
        return;
      }
      const submittedAt = new Date().toISOString();
      if(!supabase || isSupabaseMaintenance()){
        const ready = await ensureSupabaseReady();
        if(!ready || isSupabaseMaintenance()){
          const queued = queuePostTask({
            name,
            title,
            tags,
            allowDownload,
            requirePasscode,
            passcode,
            submitted_at: submittedAt,
            width: imageInfo.width,
            height: imageInfo.height,
            colors: imageInfo.colors,
            hash: imageInfo.hash,
            phash: imageInfo.phash,
            userId: supabaseUser?.id || null,
            clientId,
            xUrl,
            dataUrl: imageInfo.dataUrl,
          });
          if(queued){
            setStatus('メンテ中のためキューに保存しました。復旧後に自動投稿します。');
            form.reset();
            setPostPreview('');
            postTags = [];
            renderPostTags();
            updateDownloadSettingsUI();
          }else{
            setStatus('キューへの保存に失敗しました。時間を置いて再試行してください。');
          }
          return;
        }
      }
      // 重複画像チェック（完全一致 + 類似）
      try{
        if(supportsImageHash){
          const dupHash = await supabase
            .from('contest_entries')
            .select('id')
            .eq('image_hash', imageInfo.hash)
            .limit(1);
          if(!dupHash.error && dupHash.data && dupHash.data.length){
            setStatus('同じ画像が既に投稿されています');
            return;
          }
        }
        if(supportsPhash){
          const dupP = await supabase
            .from('contest_entries')
            .select('id,phash,user_id,client_id')
            .not('phash','is',null)
            .limit(200);
          if(!dupP.error && Array.isArray(dupP.data)){
            const isSimilar = dupP.data.some(row => {
              if((supabaseUser?.id && row.user_id === supabaseUser.id) || row.client_id === clientId){
                return false; // 自分の投稿は許可
              }
              if(!row.phash || row.phash.length !== imageInfo.phash.length) return false;
              const dist = hammingDistance(row.phash, imageInfo.phash);
              return dist <= 5; // 閾値
            });
            if(isSimilar){
              setStatus('類似した画像が既に投稿されています');
              return;
            }
          }
        }
      }catch(err){
        console.warn('duplicate check skipped', err);
        const missing = parseMissingColumn(err);
        if(missing === 'image_hash') supportsImageHash = false;
        if(missing === 'phash') supportsPhash = false;
      }
      let uploadResult = null;
      if(supabase && supportsImageUrls){
        setStatus('アップロード中...');
        uploadResult = await uploadContestImages(imageInfo);
      }
      setStatus('投稿しています...');
      try{
        const payload = {
          name,
          title,
          prompt: '自由投稿',
          mode: 'free',
          started_at: null,
          submitted_at: submittedAt,
          width: imageInfo.width,
          height: imageInfo.height,
          colors: imageInfo.colors
        };
        payload.image_base64 = imageInfo.dataUrl;
        if(supportsImageHash){
          payload.image_hash = imageInfo.hash;
        }
        if(supportsPhash){
          payload.phash = imageInfo.phash;
        }
        if(supportsImageUrls && uploadResult){
          payload.image_url = uploadResult.imageUrl;
          payload.thumb_url = uploadResult.thumbUrl;
        }
        if(supportsTags && tags.length){
          payload.tags = tags.join(',');
        }
        if(supportsDownloadSettings){
          payload.allow_download = allowDownload;
          payload.download_passcode = allowDownload && requirePasscode ? passcode : null;
        }
        if(supportsXUrl && xUrl){
          payload.x_url = xUrl;
        }
        if(supabaseUser?.id && supportsUserId){
          payload.user_id = supabaseUser.id;
        }
        if(supportsClientId){
          payload.client_id = clientId;
        }
        let res = null;
        for(let attempt = 0; attempt < 3; attempt++){
          res = await supabase.from('contest_entries').insert(payload).select('id');
          if(!res.error) break;
          if(applyInsertFallback(payload, res.error, imageInfo)){
            continue;
          }
          break;
        }
        if(res?.error){
          throw res.error;
        }
        const entryId = Array.isArray(res?.data) ? res.data[0]?.id : null;
        const shareUrl = entryId ? `${CONTEST_SHARE_BASE_URL}?id=${entryId}` : null;
        noteSupabaseSuccess();
        form.reset();
        setPostPreview('');
        postTags = [];
        renderPostTags();
        updateDownloadSettingsUI();
        if(shareUrl){
          const shareMessage = `${shareUrl}\n${SHARE_HASHTAG}`;
          if(navigator.clipboard?.writeText){
            await navigator.clipboard.writeText(shareMessage);
            setStatus('投稿しました！共有リンクをコピーしました。');
          }else{
            window.prompt('共有リンクをコピーしてください。', shareMessage);
            setStatus('投稿しました！');
          }
        }else{
          setStatus('投稿しました！');
        }
        closePostPanel();
      }catch(err){
        console.error(err);
        if(isPermissionError(err)){
          setStatus('投稿権限がありません。ログインまたは権限設定をご確認ください。');
          return;
        }
        markSupabaseMaintenanceFromError(err);
        if(isSupabaseMaintenance()){
          const queued = queuePostTask({
            name,
            title,
            tags,
            allowDownload,
            requirePasscode,
            passcode,
            submitted_at: submittedAt,
            width: imageInfo.width,
            height: imageInfo.height,
            colors: imageInfo.colors,
            hash: imageInfo.hash,
            phash: imageInfo.phash,
            userId: supabaseUser?.id || null,
            clientId,
            xUrl,
            dataUrl: imageInfo.dataUrl,
          });
          if(queued){
            setStatus('メンテ中のためキューに保存しました。復旧後に自動投稿します。');
            form.reset();
            setPostPreview('');
            postTags = [];
            renderPostTags();
            updateDownloadSettingsUI();
          }else{
            setStatus('投稿に失敗しました。キュー保存にも失敗しました。');
          }
        }else{
          setStatus('投稿に失敗しました');
        }
      }
      await fetchAndRender();
    }

    function createAdCard(slotId){
      const wrap = document.createElement('div');
      wrap.className = 'entry-card entry-card--ad';
      wrap.innerHTML = `
        <div class="entry-ad-slot">
          <ins class="adsbygoogle"
               style="display:block"
               data-ad-client="ca-pub-9801602250480253"
               data-ad-slot="${slotId}"
               data-ad-format="auto"></ins>
        </div>
        <p class="entry-ad-note">広告</p>
      `;
      return wrap;
    }

    function renderEntries(entries){
      const gallery = $(GALLERY_ID);
      if(!gallery) return;
      if(!entries.length){
        gallery.innerHTML = '<p class="empty">まだ投稿がありません。</p>';
        return;
      }
      gallery.innerHTML = '';
      const AD_SLOTS = ['2141591954','9073878884','2261515379'];
      entries.forEach((entry, idx) => {
        const item = document.createElement('a');
        item.className = 'entry-card';
        item.href = `view.html?id=${entry.id}`;
        item.innerHTML = `
          <div class="entry-imgwrap">
            <img src="${resolveEntryThumb(entry)}" alt="${entry.title}" draggable="false" loading="lazy" decoding="async">
            <span class="entry-watermark" style="top:6px; left:6px;">PiXiEED</span>
            <span class="entry-watermark" style="top:6px; right:6px;">PiXiEED</span>
            <span class="entry-watermark" style="right:6px; bottom:6px;">PiXiEED</span>
            <span class="entry-watermark" style="left:6px; bottom:6px;">PiXiEED</span>
            <span class="entry-watermark" style="left:50%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
            <span class="entry-watermark" style="left:50%; top:25%; transform:translate(-50%,-50%);">PiXiEED</span>
            <span class="entry-watermark" style="left:50%; top:75%; transform:translate(-50%,-50%);">PiXiEED</span>
            <span class="entry-watermark" style="left:25%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
            <span class="entry-watermark" style="left:75%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
            <button class="heart-btn" data-id="${entry.id}" aria-label="いいね">
              <img src="${likedEntries.has(entry.id) ? FAV_SRC : NFAV_SRC}" alt="like icon">
            </button>
          </div>
        `;
        gallery.appendChild(item);
        // 12件ごとに広告を挿入
        if((idx + 1) % 12 === 0){
          const slotId = AD_SLOTS[(idx / 12) % AD_SLOTS.length | 0];
          gallery.appendChild(createAdCard(slotId));
        }
      });
      gallery.querySelectorAll('.heart-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          likeEntry(Number(btn.dataset.id));
        });
      });
      // trigger AdSense render
      try{
        if(window.pixieedObserveAds){
          window.pixieedObserveAds();
        }
      }catch(e){
        console.warn('ads render skipped', e);
      }
    }

    async function hydrateLegacyImages(entries){
      if(!supportsImageUrls || !supabase) return entries;
      const missingIds = entries.filter(e => !e.thumb_url && !e.image_url).map(e => e.id);
      if(!missingIds.length) return entries;
      const { data, error } = await supabase
        .from('contest_entries')
        .select('id,image_base64')
        .in('id', missingIds);
      if(error || !Array.isArray(data)) return entries;
      const legacyMap = new Map(data.map(row => [row.id, row.image_base64]));
      return entries.map(e => (
        legacyMap.has(e.id) ? { ...e, image_base64: legacyMap.get(e.id) } : e
      ));
    }

    async function fetchAndRender({ append = false } = {}){
      if(isLoadingEntries) return;
      if(!append){
        currentOffset = 0;
        cachedEntries = [];
        hasMoreEntries = true;
      }
      if(append && !hasMoreEntries) return;
      isLoadingEntries = true;
      updateLoadMoreUI();
      ensureClientId();
      setStatus(append ? '追加読み込み中...' : '読み込み中...');
      let entries = [];
      let likes = likesCache;
      let networkError = false;
      if(supabase){
        try{
          const buildBaseSelect = () => (
            supportsImageUrls
              ? 'id,name,title,prompt,mode,submitted_at,width,height,colors,image_url,thumb_url'
              : 'id,name,title,prompt,mode,submitted_at,width,height,colors,image_base64'
          );
          const buildSelectColumns = () => {
            const baseSelect = buildBaseSelect();
            return supportsTags ? `${baseSelect},tags` : baseSelect;
          };
          let res = await supabase
            .from('contest_entries')
            .select(buildSelectColumns())
            .order('submitted_at', { ascending:false })
            .range(currentOffset, currentOffset + PAGE_SIZE - 1);
          let errorMsg = String(res.error?.message || '').toLowerCase();
          if(res.error && supportsTags && errorMsg.includes('tags')){
            supportsTags = false;
            res = await supabase
              .from('contest_entries')
              .select(buildSelectColumns())
              .order('submitted_at', { ascending:false })
              .range(currentOffset, currentOffset + PAGE_SIZE - 1);
            errorMsg = String(res.error?.message || '').toLowerCase();
          }
          if(res.error && supportsImageUrls && (errorMsg.includes('image_url') || errorMsg.includes('thumb_url'))){
            supportsImageUrls = false;
            res = await supabase
              .from('contest_entries')
              .select(buildSelectColumns())
              .order('submitted_at', { ascending:false })
              .range(currentOffset, currentOffset + PAGE_SIZE - 1);
          }
          if(!res.error && Array.isArray(res.data)){
            entries = await hydrateLegacyImages(res.data);
          }
          if(!append){
            const likeRes = await supabase
              .from('contest_likes')
              .select('entry_id, client_id, user_id')
              .limit(1000);
            if(!likeRes.error && Array.isArray(likeRes.data)){
              likes = likeRes.data;
            }
          }
        }catch(err){
          console.error(err);
          entries = [];
          likes = [];
          networkError = true;
        }
      } else {
        networkError = true;
      }

      if(networkError){
        setStatus(append ? '追加読み込みに失敗しました' : 'ネットワークエラーが発生しています');
        isLoadingEntries = false;
        if(!append){
          hasMoreEntries = false;
        }
        updateLoadMoreUI();
        return;
      }

      if(!append){
        likesCache = Array.isArray(likes) ? likes : [];
        likeCounts = {};
        likedEntries = new Set();
        likesCache.forEach(l => {
          likeCounts[l.entry_id] = (likeCounts[l.entry_id] || 0) + 1;
          if((supabaseUser?.id && l.user_id === supabaseUser.id) || l.client_id === clientId){
            likedEntries.add(l.entry_id);
          }
        });
      }

      const useEntries = Array.isArray(entries) ? entries : [];
      const enriched = useEntries.map(e => ({
        ...e,
        likeCount: likeCounts[e.id] || e.likeCount || 0
      }));
      if(append){
        cachedEntries = cachedEntries.concat(enriched);
      }else{
        cachedEntries = enriched;
      }
      currentOffset += enriched.length;
      if(enriched.length < PAGE_SIZE){
        hasMoreEntries = false;
      }
      renderEntries(applyFilterAndSort(cachedEntries));
      setStatus('');
      isLoadingEntries = false;
      updateLoadMoreUI();
    }

    function applyFilterAndSort(entries){
      let filtered = entries.slice();
      if(currentFilter === 'timed10'){
        filtered = filtered.filter(e => e.mode === 'timed10');
      }else if(currentFilter === 'px32'){
        filtered = filtered.filter(e => (e.width || 999) <= 32 && (e.height || 999) <= 32);
      }
      if(currentTagQuery){
        const query = currentTagQuery.toLowerCase();
        filtered = filtered.filter(e => {
          const tags = parseTags(e.tags);
          return tags.some(tag => tag.toLowerCase().includes(query));
        });
      }
      if(currentSort === 'popular'){
        filtered.sort((a,b) => {
          if(b.likeCount !== a.likeCount) return b.likeCount - a.likeCount;
          return new Date(b.submitted_at).getTime() - new Date(a.submitted_at).getTime();
        });
      }else{
        filtered.sort((a,b) => new Date(b.submitted_at).getTime() - new Date(a.submitted_at).getTime());
      }
      return filtered;
    }

  async function likeEntry(id){
    if(!clientId) ensureClientId();
    // オフラインでもトグル可能にする
    const already = likedEntries.has(id);
    if(already){
      likedEntries.delete(id);
    }else{
      likedEntries.add(id);
    }
    const target = cachedEntries.find(e => e.id === id);
    if(target){
      target.likeCount = Math.max(0, (target.likeCount || 0) + (already ? -1 : 1));
    }
    renderEntries(applyFilterAndSort(cachedEntries));

    if(supabase){
      try{
        if(!already){
          const payload = { entry_id:id };
          if(supabaseUser?.id){
            payload.user_id = supabaseUser.id;
          }
          if(supportsClientId){
            payload.client_id = clientId;
          }
          let res = await supabase.from('contest_likes').insert(payload);
          if(res.error && supportsClientId && String(res.error.message || '').includes('client_id')){
            supportsClientId = false;
            delete payload.client_id;
            res = await supabase.from('contest_likes').insert(payload);
          }
          if(res.error) throw res.error;
        }
      }catch(err){
        console.error(err);
      }
    }
  }

    function makePlaceholder(color){
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><rect width="200" height="200" fill="${color}"/></svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    function closePostPanel(){
      const panel = document.getElementById('postPanel');
      if(!panel) return;
      panel.classList.remove('is-open');
      panel.setAttribute('aria-hidden','true');
    }

    function setupPostPanel(){
      const openBtn = document.getElementById('openPostPanel');
      const panel = document.getElementById('postPanel');
      const closeBtn = document.getElementById('closePostPanel');
      if(!openBtn || !panel) return;
      const open = () => {
        panel.classList.add('is-open');
        panel.setAttribute('aria-hidden','false');
      };
      openBtn.addEventListener('click', open);
      if(closeBtn){
        closeBtn.addEventListener('click', closePostPanel);
      }
      panel.addEventListener('click', (e) => {
        if(e.target === panel) closePostPanel();
      });
    }

    function setupFabMenu(){
      const menu = document.getElementById('fabMenu');
      const toggle = document.getElementById('fabToggle');
      const actions = document.getElementById('fabActions');
      if(!menu || !toggle) return;
      const closeMenu = () => {
        menu.classList.remove('is-open');
        toggle.setAttribute('aria-expanded', 'false');
        if(actions) actions.setAttribute('aria-hidden', 'true');
      };
      const openMenu = () => {
        menu.classList.add('is-open');
        toggle.setAttribute('aria-expanded', 'true');
        if(actions) actions.setAttribute('aria-hidden', 'false');
      };
      toggle.addEventListener('click', () => {
        if(menu.classList.contains('is-open')){
          closeMenu();
        }else{
          openMenu();
        }
      });
      document.addEventListener('click', (event) => {
        if(!menu.contains(event.target)) closeMenu();
      });
      document.addEventListener('keydown', (event) => {
        if(event.key === 'Escape') closeMenu();
      });
      menu.querySelectorAll('.fab-action').forEach(action => {
        action.addEventListener('click', closeMenu);
      });
    }

    function isMissingColumn(error, column){
      return String(error?.message || '').includes(column);
    }

    async function getLinkedUserIdForClient(){
      if(!supabase || !clientId) return null;
      const tables = ['contest_entries','contest_likes','scores'];
      for(const table of tables){
        try{
          const { data, error } = await supabase
            .from(table)
            .select('user_id')
            .eq('client_id', clientId)
            .not('user_id','is',null)
            .limit(1);
          if(error){
            if(isMissingColumn(error, 'user_id')) continue;
            continue;
          }
          if(Array.isArray(data) && data.length && data[0].user_id){
            return data[0].user_id;
          }
        }catch(_){
          continue;
        }
      }
      return null;
    }

    async function checkClientLinkConflict(){
      if(!supabase || !supabaseUser?.id || !clientId) return false;
      if(clientLinkChecked) return clientLinkConflict;
      clientLinkChecked = true;
      const linkedUserId = await getLinkedUserIdForClient();
      clientLinkConflict = !!(linkedUserId && linkedUserId !== supabaseUser.id);
      try{
        if(clientLinkConflict){
          localStorage.setItem('pixieed_link_conflict','1');
        }else{
          localStorage.removeItem('pixieed_link_conflict');
        }
      }catch(_){}
      return clientLinkConflict;
    }

    async function migrateGuestData(){
      if(!supabase || !supabaseUser?.id || migrationDone || !clientId) return;
      const isConflict = await checkClientLinkConflict();
      if(isConflict){
        setAuthStatus('別アカウントに紐付け済みのため、ゲスト投稿の移行を停止しました');
        return;
      }
      try{
        const entryRes = await supabase.from('contest_entries')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(entryRes.error) throw entryRes.error;
        const likeRes = await supabase.from('contest_likes')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(likeRes.error) throw likeRes.error;
        const scoreRes = await supabase.from('scores')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(scoreRes.error && !isMissingColumn(scoreRes.error, 'user_id')){
          console.warn('score migrate skipped', scoreRes.error);
        }
        migrationDone = true;
      }catch(err){
        console.error('migrate error', err);
      }
    }

    async function syncProfileFromServer(){
      if(!supabase || !supabaseUser?.id) return;
      const localNick = loadNickname();
      const localAvatar = loadAvatar();
      const localXUrl = normalizeXUrl(loadXUrl());
      try{
        let selectColumns = supportsProfileXUrl ? 'nickname, avatar, x_url' : 'nickname, avatar';
        let { data, error } = await supabase
          .from('user_profiles')
          .select(selectColumns)
          .eq('id', supabaseUser.id)
          .maybeSingle();
        if(error && supportsProfileXUrl && isMissingColumn(error, 'x_url')){
          supportsProfileXUrl = false;
          selectColumns = 'nickname, avatar';
          ({ data, error } = await supabase
            .from('user_profiles')
            .select(selectColumns)
            .eq('id', supabaseUser.id)
            .maybeSingle());
        }
        if(error) throw error;
        const serverNick = (data?.nickname || '').trim();
        const serverAvatar = data?.avatar || '';
        const serverXUrl = normalizeXUrl(data?.x_url || '');
        if(serverNick) saveNickname(serverNick);
        if(serverAvatar) saveAvatar(serverAvatar);
        if(serverXUrl) saveXUrl(serverXUrl);
        const shouldUpsert = (!serverNick && localNick) || (!serverAvatar && localAvatar) || (!serverXUrl && localXUrl);
        if(shouldUpsert){
          const payload = { id: supabaseUser.id };
          if(localNick && !serverNick) payload.nickname = localNick;
          if(localAvatar && !serverAvatar) payload.avatar = localAvatar;
          if(localXUrl && !serverXUrl && supportsProfileXUrl) payload.x_url = localXUrl;
          if(Object.keys(payload).length > 1){
            let upsert = await supabase.from('user_profiles').upsert(payload);
            if(upsert.error && supportsProfileXUrl && isMissingColumn(upsert.error, 'x_url')){
              supportsProfileXUrl = false;
              delete payload.x_url;
              if(Object.keys(payload).length > 1){
                upsert = await supabase.from('user_profiles').upsert(payload);
              }else{
                upsert = null;
              }
            }
            if(upsert?.error) throw upsert.error;
          }
        }
        const nickInput = document.getElementById('profileNickname');
        if(nickInput) nickInput.value = serverNick || localNick || '';
        const xInput = document.getElementById('profileX');
        if(xInput) xInput.value = serverXUrl || localXUrl || '';
        updateNameDisplay();
        applyAvatarToBrand();
        renderAvatarChoices();
      }catch(err){
        console.warn('profile sync failed', err);
      }
    }

    function updateAuthUI(){
      const btn = document.getElementById('authBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const emailInput = document.getElementById('authEmail');
      const passInput = document.getElementById('authPasscode');
      const authInputs = document.getElementById('authInputs');
      const linkedEmail = document.getElementById('linkedEmail');
      const nick = loadNickname();
      if(!btn) return;
      if(supabaseUser){
        btn.textContent = 'ログインリンクを再送';
        if(logoutBtn) logoutBtn.style.display = 'block';
        setAuthStatus(`ログイン中${supabaseUser.email ? `: ${supabaseUser.email}` : ''}${nick ? ` / ${nick}` : ''}`);
        if(emailInput){
          emailInput.value = supabaseUser.email || emailInput.value;
          emailInput.disabled = true;
        }
        if(passInput){
          passInput.value = '';
          passInput.disabled = true;
        }
        if(authInputs) authInputs.style.display = 'none';
        if(linkedEmail){
          linkedEmail.style.display = 'inline-flex';
          linkedEmail.textContent = supabaseUser.email ? `紐付け済み: ${supabaseUser.email}` : '紐付け済み';
        }
      }else{
        btn.textContent = 'メールでログイン';
        if(logoutBtn) logoutBtn.style.display = 'none';
        setAuthStatus(nick ? `ニックネーム: ${nick}` : '');
        if(emailInput){
          emailInput.disabled = false;
        }
        if(passInput){
          passInput.disabled = false;
        }
        if(authInputs) authInputs.style.display = 'grid';
        if(linkedEmail){
          linkedEmail.style.display = 'none';
          linkedEmail.textContent = '';
        }
      }
      if(clientLinkConflict){
        setAuthStatus('別アカウントに紐付け済みのため、ゲスト投稿の移行を停止しました');
      }
      applyAvatarToBrand();
    }

    async function initSupabase(){
      if(supabaseInitPromise) return supabaseInitPromise;
      supabaseInitPromise = (async () => {
        try{
          const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2.46.1?bundle');
          supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            global:{ headers:{ 'x-client-id': clientId || '' } }
          });
          window.__pixieedSupabase = supabase;
          const { data } = await supabase.auth.getSession();
          supabaseSession = data?.session || null;
          supabaseUser = supabaseSession?.user || null;
          supabase.auth.onAuthStateChange((_event, session) => {
            supabaseSession = session || null;
            supabaseUser = session?.user || null;
            clientLinkChecked = false;
            clientLinkConflict = false;
            migrateGuestData();
            syncProfileFromServer();
            updateAuthUI();
            fetchAndRender();
          });
          clientLinkChecked = false;
          clientLinkConflict = false;
          await checkClientLinkConflict();
          await migrateGuestData();
          await syncProfileFromServer();
          updateAuthUI();
          noteSupabaseSuccess();
        }catch(err){
          console.warn('Supabase初期化に失敗: オフラインプレース表示のみ', err);
          supabase = null;
          setSupabaseMaintenance(true, 'init');
        }
      })();
      try{
        await supabaseInitPromise;
      }finally{
        supabaseInitPromise = null;
      }
      return supabase;
    }

    function setupAuthButton(){
      const btn = document.getElementById('authBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const openBtn = document.getElementById('openProfilePanel');
      const closeBtn = document.getElementById('closeAuthPanel');
      const panel = document.getElementById('authPanel');
      const saveBtn = document.getElementById('saveProfile');
      const nicknameInput = document.getElementById('profileNickname');
      const xInput = document.getElementById('profileX');
      const togglePanel = (open) => {
        if(!panel) return;
        if(open){
          panel.classList.add('is-open');
          panel.setAttribute('aria-hidden','false');
        }else{
          panel.classList.remove('is-open');
          panel.setAttribute('aria-hidden','true');
        }
      };
      const sendLoginLink = async (email) => {
        if(!supabase){
          setAuthStatus('オンラインでログインしてください');
          return false;
        }
        setAuthStatus('ログインリンクを送信しています...');
        try{
          const { error } = await supabase.auth.signInWithOtp({
            email,
            options:{ emailRedirectTo: window.location.href }
          });
          if(error) throw error;
          setAuthStatus('ログインリンクを送信しました。メールを確認してください');
          return true;
        }catch(err){
          console.error(err);
          setAuthStatus('ログインリンクの送信に失敗しました');
          return false;
        }
      };
      if(openBtn) openBtn.addEventListener('click', () => {
        if(nicknameInput){
          nicknameInput.value = loadNickname();
        }
        if(xInput){
          xInput.value = loadXUrl();
        }
        togglePanel(true);
      });
      if(closeBtn) closeBtn.addEventListener('click', () => togglePanel(false));
      if(panel){
        panel.addEventListener('click', (e) => { if(e.target === panel) togglePanel(false); });
      }
      if(saveBtn){
        saveBtn.addEventListener('click', async () => {
          const nick = (nicknameInput?.value || '').trim();
          const xUrl = normalizeXUrl(xInput?.value || '');
          if(nick){
            saveNickname(nick);
          }
          saveXUrl(xUrl);
          updateNameDisplay();
          applyAvatarToBrand();
          renderAvatarChoices();
          if(supabase && supabaseUser?.id){
            try{
              const payload = { id: supabaseUser.id, nickname: nick || null, avatar: loadAvatar() };
              if(supportsProfileXUrl) payload.x_url = xUrl || null;
              let res = await supabase.from('user_profiles').upsert(payload);
              if(res.error && supportsProfileXUrl && isMissingColumn(res.error, 'x_url')){
                supportsProfileXUrl = false;
                delete payload.x_url;
                res = await supabase.from('user_profiles').upsert(payload);
              }
              if(res.error) throw res.error;
              setAuthStatus('プロフィールを保存しました');
            }catch(err){
              console.warn('profile save fallback', err);
              setAuthStatus('ローカルに保存しました');
            }
          }else{
            setAuthStatus('ローカルに保存しました');
          }
        });
      }
      if(!btn) return;
      btn.addEventListener('click', async () => {
        if(!supabase){
          setAuthStatus('オンラインでログインしてください');
          return;
        }
        const emailInput = document.getElementById('authEmail');
        const passInput = document.getElementById('authPasscode');
        const email = (emailInput?.value || '').trim();
        const passcode = (passInput?.value || '').trim();
        if(!email){
          setAuthStatus('メールアドレスを入力してください');
          return;
        }
        if(!passcode){
          await sendLoginLink(email);
          return;
        }
        if(passcode.length < 6 || passcode.length > 20){
          setAuthStatus('パスコードは6〜20文字で入力してください');
          return;
        }
        setAuthStatus('サインインしています...');
        try{
          const { error } = await supabase.auth.signInWithPassword({ email, password: passcode });
          if(error){
            // 既に登録済みで未確認なら再送
            if(String(error.message || '').toLowerCase().includes('confirm')){
              await supabase.auth.resend({ type:'signup', email, options:{ emailRedirectTo: window.location.href } });
              setAuthStatus('確認メールを再送しました。メールを確認してください');
              return;
            }
            const { error: signUpError } = await supabase.auth.signUp({ email, password: passcode, options:{ emailRedirectTo: window.location.href } });
            if(signUpError){
              const msg = String(signUpError.message || '').toLowerCase();
              if(msg.includes('already') || msg.includes('registered') || msg.includes('exists')){
                setAuthStatus('このメールは登録済みです。パスコードを確認してください');
                return;
              }
              setAuthStatus('ログイン／登録に失敗しました');
              console.error(signUpError);
              return;
            }
            setAuthStatus('確認メールを送信しました。メールを確認してください');
          }else{
            setAuthStatus('サインインしました');
          }
        }catch(err){
          console.error(err);
          setAuthStatus('ログインに失敗しました');
        }
      });
      if(logoutBtn){
        logoutBtn.addEventListener('click', async () => {
          if(!supabase) return;
          await supabase.auth.signOut();
          supabaseUser = null;
          supabaseSession = null;
          migrationDone = false;
          clientLinkChecked = false;
          clientLinkConflict = false;
          try{ localStorage.removeItem('pixieed_link_conflict'); }catch(_){}
          updateAuthUI();
          fetchAndRender();
          togglePanel(false);
        });
      }
    }

    function setActiveNav(){
      const tab = 'contest';
      document.querySelectorAll('.bottom-nav__item').forEach(item => {
        const isMatch = item.dataset.tab === tab;
        item.classList.toggle('is-active', isMatch);
      });
    }

    async function init(){
      ensureClientId();
      if(location.hash === '#auth'){
        const openBtn = document.getElementById('openProfilePanel');
        if(openBtn){
          setTimeout(() => openBtn.click(), 0);
        }
      }
      setupTabs();
      setupTagSearch();
      setupLoadMore();
      setupPostPanel();
      setupFabMenu();
      setupTagInput();
      setupDownloadSettings();
      setupAuthButton();
      setupAvatarToggle();
      // ギャラリー内は右クリック・長押し・ドラッグを抑止
      const blockGalleryAction = (e) => {
        if(!(e.target instanceof Element)) return;
        if(e.target.closest('.entry-card')){
          e.preventDefault();
        }
      };
      document.addEventListener('contextmenu', blockGalleryAction);
      document.addEventListener('dragstart', blockGalleryAction);
      const form = $(FORM_ID);
      if(form){
        updateNameDisplay();
        form.addEventListener('submit', handleSubmit);
      }
      const fileInput = $(FILE_INPUT_ID);
      if(fileInput){
        fileInput.addEventListener('change', async () => {
          const file = fileInput.files?.[0];
          if(!file){
            setPostPreview('');
            return;
          }
          setStatus('画像を読み込み中...');
          try{
            const info = await fileToImageInfo(file);
            setPostPreview(info.dataUrl);
            setStatus('');
          }catch(err){
            setPostPreview('');
            setStatus(err?.message || '画像の読み込みに失敗しました');
          }
        });
      }
      restorePendingUpload();
      const profileNick = document.getElementById('profileNickname');
      if(profileNick){
        profileNick.value = loadNickname();
      }
      const profileX = document.getElementById('profileX');
      if(profileX){
        profileX.value = loadXUrl();
      }
      await initSupabase();
      if(supabaseMaintenance){
        setSupabaseMaintenance(true, 'cached');
      }
      flushPostQueue().catch(err => console.warn('post queue flush failed', err));
      schedulePostQueueFlush();
      updateAuthUI();
      renderAvatarChoices();
      applyAvatarToBrand();
      setActiveNav();
      try{
        if(window.pixieedObserveAds){
          window.pixieedObserveAds();
        }
      }catch(e){
        console.warn('ads render skipped', e);
      }
      await fetchAndRender();
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
