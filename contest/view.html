<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no, viewport-fit=cover"/>
  <meta name="robots" content="noai,noimageai,nosnippet,noarchive"/>
  <title>ドット作品</title>
  <meta name="description" content="ドット絵制作・pixel art commission、ブラウザゲーム用アセット、ツールとゲームをまとめたPiXiEED公式サイト。"/>
  <meta property="og:type" content="website"/>
  <meta property="og:site_name" content="PiXiEED"/>
  <meta property="og:title" content="PiXiEED | ドット絵専用総合サイト"/>
  <meta property="og:description" content="ドット絵制作の外注・pixel art commission、ブラウザゲーム用アセット制作、ツールとゲームを紹介するPiXiEED公式サイト。"/>
  <meta property="og:url" content="https://pixieed.jp/contest/view.html"/>
  <meta property="og:image" content="https://pixieed.jp/PiXiEEDogp.png"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <link rel="icon" type="image/png" href="../character-dots/mao1.png"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Fredoka:wght@600&display=swap" rel="stylesheet">
  <style>
    :root{ color-scheme: dark; }
    *{
      box-sizing:border-box;
      user-select:none;
      -webkit-user-select:none;
      -ms-user-select:none;
    }
    html,
    body{
      max-width:100vw;
      overflow-x:hidden;
    }
    body{
      margin:0;
      font-family:'Fredoka','DotGothic16',system-ui,sans-serif;
      background:radial-gradient(circle at 20% 20%, rgba(59,130,246,0.22), rgba(15,23,42,1)),
                 radial-gradient(circle at 80% 0%, rgba(236,72,153,0.18), rgba(15,23,42,1)),
                 #0b1224;
      color:#e5e7eb;
      min-height:100vh;
      padding:20px 14px 120px;
      width:100%;
      max-width:100vw;
      display:flex;
      justify-content:center;
    }
    .page{
      width:100%;
      max-width:min(1200px, 100vw);
      min-width:0;
      display:grid;
      gap:16px;
    }
    header{
      position:sticky;
      top:0;
      z-index:70;
      background:rgba(11,18,36,0.94);
      backdrop-filter:blur(8px);
      border-bottom:1px solid rgba(255,255,255,0.08);
      margin:-20px -14px 8px;
      padding:10px 14px;
    }
    .header-inner{
      width:100%;
      max-width:none;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:800;
      letter-spacing:0.01em;
      background:none;
      border:0;
      padding:0;
      cursor:pointer;
    }
    .brand-icon{
      width:34px;
      height:34px;
      border-radius:10px;
      background:rgba(255,255,255,0.12);
      padding:4px;
      border:1px solid rgba(255,255,255,0.2);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .brand-icon img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    .brand-text{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand-title{ margin:0; font-size:16px; color:#f9fafb; }
    .brand-sub{ margin:0; font-size:12px; color:#9ca3af; }
    h1{ margin:0; font-size:22px; }
    .auth-panel{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.65);
      backdrop-filter:blur(4px);
      padding:calc(12px + env(safe-area-inset-top)) calc(12px + env(safe-area-inset-right)) calc(12px + env(safe-area-inset-bottom) + 76px) calc(12px + env(safe-area-inset-left));
      z-index:70;
    }
    .auth-panel.is-open{ display:flex; }
    .auth-card{
      width:100%;
      max-width:420px;
      max-height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 84px);
      background:rgba(15,23,42,0.95);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:16px;
      padding:clamp(12px, 2vh, 16px);
      box-shadow:0 18px 40px rgba(0,0,0,0.45);
      display:grid;
      gap:clamp(8px, 1.6vh, 12px);
      box-sizing:border-box;
      overflow:hidden;
    }
    @supports (height: 100dvh){
      .auth-card{
        max-height:calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 84px);
      }
    }
    .auth-input{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#fff;
      padding:clamp(8px, 1.4vh, 10px) clamp(10px, 1.6vh, 12px);
      font-size:clamp(12px, 1.6vh, 14px);
    }
    .tag-input input{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#fff;
      padding:10px 12px;
      font-size:14px;
    }
    .auth-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:linear-gradient(135deg,#4f46e5,#7c3aed);
      color:#fff;
      border-radius:12px;
      padding:clamp(8px, 1.4vh, 10px) clamp(12px, 1.6vh, 14px);
      font-weight:800;
      cursor:pointer;
      text-align:center;
      font-size:clamp(12px, 1.6vh, 14px);
    }
    .auth-btn.logout{
      background:rgba(255,255,255,0.08);
      border-color:rgba(255,255,255,0.2);
    }
    .auth-status{ font-size:12px; color:#cbd5e1; min-height:16px; }
    .auth-details{
      border:1px solid rgba(255,255,255,0.16);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(255,255,255,0.04);
    }
    .auth-details summary{
      list-style:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:800;
      color:#e5e7eb;
    }
    .auth-details summary::-webkit-details-marker{ display:none; }
    .auth-details__status{
      margin-left:auto;
      font-size:12px;
      color:#93c5fd;
      font-weight:700;
    }
    .auth-details summary::after{
      content:'+';
      color:#94a3b8;
      font-weight:800;
    }
    .auth-details[open] summary::after{ content:'-'; }
    .auth-details__body{
      display:grid;
      gap:8px;
      margin-top:10px;
    }
    .close-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#fff;
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
    }
    .profile-block{
      display:grid;
      gap:clamp(8px, 1.4vh, 10px);
      padding:clamp(8px, 1.4vh, 12px);
      border-radius:12px;
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.08);
    }
    .profile-row{
      display:flex;
      align-items:flex-end;
      gap:10px;
    }
    .profile-name{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .avatar-toggle{
      width:48px;
      height:48px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(0,0,0,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .avatar-toggle__img{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .avatar-toggle__img img{
      width:80%;
      height:80%;
      object-fit:contain;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
    }
    .avatar-panel{
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:6px;
      background:rgba(0,0,0,0.2);
    }
    .avatar-grid{
      display:grid;
      grid-template-columns:repeat(5, minmax(0, 1fr));
      gap:clamp(4px, 1vh, 6px);
      max-height:clamp(120px, 20vh, 160px);
      overflow-y:auto;
      padding-right:4px;
      -webkit-overflow-scrolling:touch;
    }
    .avatar-option{
      width:100%;
      aspect-ratio:1;
      border-radius:12px;
      border:2px solid transparent;
      background:rgba(255,255,255,0.08);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:800;
      transition:border-color 0.15s ease, transform 0.1s ease;
    }
    .avatar-option.is-active{
      border-color:#7c3aed;
      transform:translateY(-1px);
    }
    .card{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      padding:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.3);
    }
    .entry-hero{
      position:relative;
      width:100%;
      height:min(80vh, 100vw);
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.12);
      overflow:hidden;
      border-radius:12px;
    }
    .entry-hero img{
      width:100%;
      height:100%;
      object-fit:contain;
      image-rendering:pixelated;
      background:transparent;
    }
    .entry-hero video{
      width:100%;
      height:100%;
      object-fit:contain;
      background:transparent;
      display:block;
    }
    .entry-hero video[hidden]{
      display:none;
    }
    .heart-btn{
      position:absolute;
      right:8px;
      bottom:8px;
      border:none;
      background:transparent;
      padding:0;
      width:36px;
      height:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:2;
    }
    .heart-btn img{ width:100%; height:100%; object-fit:contain; display:block; }
    .meta{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top:10px;
    }
    .meta-main{
      min-width:0;
      display:grid;
      gap:2px;
    }
    .title{ font-size:18px; font-weight:800; margin:0; }
    .author-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      min-height:18px;
    }
    .author{ margin:0; color:#cbd5e1; font-size:13px; }
    .author a{
      color:inherit;
      text-decoration:underline;
      text-underline-offset:2px;
    }
    .likes{ color:#fbbf24; font-weight:800; }
    .tag-block{
      display:grid;
      gap:8px;
      margin-top:10px;
    }
    .tag-label{
      margin:0;
      font-size:12px;
      color:#cbd5e1;
    }
    .tag-view{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      min-height:24px;
    }
    .tag-view--inline{
      min-height:0;
      gap:4px;
    }
    .tag-view--inline:empty{
      display:none;
    }
    .tag-view--inline .tag-chip{
      padding:2px 7px;
      font-size:10px;
    }
    .tag-chip{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.05);
      color:#e5e7eb;
    }
    .tag-chip .tag-remove{
      font-weight:800;
      opacity:0.7;
    }
    .tag-editor{
      display:grid;
      gap:8px;
    }
    .tag-input{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .tag-input input{
      flex:1;
      min-width:0;
    }
    .tag-save{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#e5e7eb;
      border-radius:10px;
      padding:8px 12px;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    .download-editor{
      display:grid;
      gap:8px;
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,0.08);
    }
    .download-row{
      width:100%;
      display:grid;
      grid-template-columns:minmax(0,1.4fr) minmax(0,1fr) auto;
      gap:8px;
      align-items:center;
    }
    .download-options{
      display:grid;
      gap:6px;
      min-width:0;
    }
    .download-editor .toggle{
      display:grid;
      grid-template-columns: 20px minmax(0, 1fr);
      align-items:center;
      column-gap:8px;
      font-size:13px;
      color:#cbd5e1;
      font-weight:700;
      width:100%;
    }
    .download-editor .toggle input{
      margin:0;
    }
    .download-editor .toggle span{
      line-height:1.4;
    }
    .download-pass-input{
      width:100%;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.25);
      color:#f9fafb;
      padding:8px 10px;
      font-size:13px;
      font-family:inherit;
    }
    .download-pass-input:disabled{
      opacity:0.6;
      cursor:not-allowed;
    }
    .download-editor .toggle input:disabled + span{
      opacity:0.6;
    }
    .download-row .tag-save{
      align-self:center;
    }
    .download-helper{
      margin:0;
      font-size:11px;
      color:#94a3b8;
    }
    .gallery{
      display:grid;
      gap:12px;
    }
    .user-gallery{
      grid-template-columns:repeat(3, minmax(0, 1fr));
    }
    .user-gallery .entry-card{
      background:transparent;
      border:none;
      padding:0;
    }
    .user-gallery .entry-card.entry-card--ad{
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.12);
      padding:12px;
    }
    .entry-card{
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      position:relative;
      text-decoration:none;
      color:inherit;
    }
    .entry-imgwrap{
      padding:0;
      background:transparent;
      display:block;
      position:relative;
      aspect-ratio:1/1;
      border-radius:12px;
      overflow:hidden;
    }
    .entry-imgwrap img{
      width:100%;
      height:100%;
      object-fit:cover;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      -ms-interpolation-mode:nearest-neighbor;
      border:0;
      background:transparent;
      position:relative;
      z-index:1;
      pointer-events:none;
      -webkit-user-drag:none;
      user-select:none;
    }
    .entry-watermark{
      position:absolute;
      color:rgba(255,255,255,0.04);
      font-weight:800;
      font-size:14px;
      letter-spacing:0.08em;
      text-shadow:0 0 12px rgba(0,0,0,0.18);
      z-index:2;
      pointer-events:none;
    }
    .entry-card .heart-btn{
      right:4px;
      bottom:4px;
      width:32px;
      height:32px;
    }
    .entry-meta{ padding:10px; display:flex; flex-direction:column; gap:6px; }
    .entry-meta__top{ display:flex; align-items:center; justify-content:space-between; gap:6px; }
    .entry-title{ font-weight:800; color:#f9fafb; }
    .entry-like{ color:#fbbf24; font-weight:800; }
    .entry-author{ margin:0; color:#cbd5e1; font-size:12px; }
    .empty{ color:#cbd5e1; text-align:center; margin:8px 0 0; }
    .status{
      margin:0;
      color:#fef3c7;
      font-size:12px;
      min-height:18px;
    }
    .status:empty{
      display:none;
    }
    .entry-card.entry-card--ad{
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      flex-direction:column;
      aspect-ratio:auto;
      min-height:clamp(48px, 9vw, 60px);
      gap:10px;
      width:100%;
      max-width:100%;
      padding:12px;
      background:rgba(255,255,255,0.05);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow:0 10px 30px rgba(0,0,0,0.28);
      position:relative;
    }
    .entry-ad-slot{
      width:min(100%, 720px);
      max-width:100%;
      min-width:0;
      margin:0 auto;
    }
    .entry-ad-slot ins{
      display:block;
      width:100%;
      max-width:100%;
      min-width:0;
      min-height:clamp(48px, 9vw, 60px);
      height:clamp(48px, 9vw, 60px);
      margin:0 auto;
      overflow:hidden;
    }
    .entry-ad-note{
      margin:0;
      color:#cbd5e1;
      font-size:11px;
    }
    @media(max-width:640px){
      .entry-ad-slot ins{
        min-height:clamp(48px, 9vw, 60px);
        height:clamp(48px, 9vw, 60px);
      }
    }
    .load-more{
      display:flex;
      justify-content:center;
      margin-top:12px;
    }
    .load-more-btn{
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#e5e7eb;
      border-radius:10px;
      padding:10px 16px;
      font-weight:800;
      cursor:pointer;
    }
    .load-more-btn:disabled{
      opacity:0.6;
      cursor:not-allowed;
    }
    .action-links{
      display:flex;
      gap:8px;
      margin-top:6px;
      flex-wrap:nowrap;
    }
    .action-btn{
      flex:1 1 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding:10px 14px;
      border-radius:12px;
      font-weight:800;
      text-decoration:none;
      white-space:nowrap;
      min-width:0;
      transition:transform 0.1s ease, filter 0.1s ease;
    }
    .action-btn--play{
      border:1px solid rgba(255,111,141,0.6);
      background:linear-gradient(135deg, rgba(255,111,141,0.25), rgba(255,159,67,0.25));
      color:#ffe4ec;
      box-shadow:0 6px 16px rgba(255,111,141,0.25);
    }
    .action-btn--download{
      border:1px solid rgba(96,165,250,0.55);
      background:linear-gradient(135deg, rgba(96,165,250,0.2), rgba(52,211,153,0.18));
      color:#e0f2fe;
      box-shadow:0 6px 16px rgba(96,165,250,0.2);
      cursor:pointer;
    }
    .action-btn--share{
      border:1px solid rgba(56,189,248,0.55);
      background:linear-gradient(135deg, rgba(56,189,248,0.2), rgba(59,130,246,0.18));
      color:#e0f2fe;
      box-shadow:0 6px 16px rgba(56,189,248,0.2);
      cursor:pointer;
    }
    .action-btn:hover,
    .action-btn:focus-visible{
      transform:translateY(-1px);
      filter:brightness(1.05);
    }
    .action-btn.is-disabled,
    .action-btn:disabled,
    .action-btn[aria-disabled="true"]{
      border:1px solid rgba(148,163,184,0.5);
      background:rgba(148,163,184,0.18);
      color:#cbd5e1;
      box-shadow:none;
      pointer-events:none;
      cursor:not-allowed;
      filter:none;
      transform:none;
    }
    .danger-btn{
      border:1px solid rgba(248,113,113,0.5);
      background:rgba(248,113,113,0.12);
      color:#fecaca;
      border-radius:10px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
    }
    .danger-btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    .bottom-nav{
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      height:68px;
      background:rgba(11,18,36,0.96);
      border-top:1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:space-around;
      align-items:center;
      z-index:80;
      backdrop-filter:blur(8px);
    }
    .bottom-nav__item{
      flex:1;
      text-align:center;
      color:#cbd5e1;
      text-decoration:none;
      font-weight:700;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      font-size:12px;
      padding:8px 0;
    }
    .bottom-nav__item .icon{
      width:22px;
      height:22px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .bottom-nav__item .icon img{
      width:100%;
      height:100%;
      object-fit:contain;
      image-rendering:pixelated;
    }
    .bottom-nav__item.is-active{
      color:#f9fafb;
    }
  </style>
  <style id="interaction-guard">
    * {
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    input,
    textarea,
    [contenteditable] {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  <script id="interaction-guard-js">
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    document.addEventListener('dragstart', (event) => {
      event.preventDefault();
    });
  </script>
<link rel="manifest" href="/manifest.webmanifest"/>
<link rel="apple-touch-icon" href="/icon/PiXiEED.icon512.png"/>
</head>
<body>
  <div class="page">
    <header aria-label="top-nav">
      <div class="header-inner">
        <button class="brand" id="openProfilePanel" type="button">
          <span class="brand-icon" id="brandAvatar"><img src="../character-dots/mao1.png" alt="logo"></span>
          <div class="brand-text">
            <p class="brand-title">PiXiEED</p>
            <p class="brand-sub" id="brandUser">ユーザー</p>
          </div>
        </button>
        <div></div>
      </div>
    </header>
    <section class="card">
      <div class="entry-hero" id="hero">
        <img id="heroImg" alt="dot work" draggable="false" decoding="async"/>
        <video id="heroVideo" autoplay loop muted playsinline controls preload="metadata" hidden></video>
        <span class="entry-watermark" style="top:6px; left:6px;">PiXiEED</span>
        <span class="entry-watermark" style="top:6px; right:6px;">PiXiEED</span>
        <span class="entry-watermark" style="right:6px; bottom:6px;">PiXiEED</span>
        <span class="entry-watermark" style="left:6px; bottom:6px;">PiXiEED</span>
        <span class="entry-watermark" style="left:50%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
        <span class="entry-watermark" style="left:50%; top:25%; transform:translate(-50%,-50%);">PiXiEED</span>
        <span class="entry-watermark" style="left:50%; top:75%; transform:translate(-50%,-50%);">PiXiEED</span>
        <span class="entry-watermark" style="left:25%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
        <span class="entry-watermark" style="left:75%; top:50%; transform:translate(-50%,-50%);">PiXiEED</span>
        <button class="heart-btn" id="heroLike" aria-label="いいね"><img id="heroLikeIcon" alt="like icon"/></button>
      </div>
      <div class="meta">
        <div class="meta-main">
          <p class="title" id="heroTitle">タイトル</p>
          <div class="author-row">
            <p class="author" id="heroAuthor">by ???</p>
            <div class="tag-view tag-view--inline" id="tagView"></div>
          </div>
        </div>
        <span class="likes" id="heroLikes">0</span>
      </div>
      <div class="tag-block">
        <div class="tag-editor" id="tagEditor" style="display:none;">
          <div class="tag-input">
            <input id="tagEditInput" type="text" placeholder="タグを追加（Enterで追加）" maxlength="24"/>
            <button class="tag-save" id="tagSaveBtn" type="button">保存</button>
          </div>
          <div class="tag-view" id="tagEditList"></div>
          <p class="status" id="tagStatus"></p>
        </div>
        <div class="download-editor" id="downloadEditor" style="display:none;">
          <p class="tag-label">ダウンロード設定</p>
          <div class="download-row">
            <div class="download-options">
              <label class="toggle">
                <input id="downloadAllowToggle" type="checkbox"/>
                <span>ダウンロードを許可</span>
              </label>
              <label class="toggle">
                <input id="downloadPassToggle" type="checkbox"/>
                <span>パスコードを設定</span>
              </label>
            </div>
            <input class="download-pass-input" id="downloadPassInput" type="text" placeholder="パスコード（4〜12文字）" maxlength="12"/>
            <button class="tag-save" id="downloadSaveBtn" type="button">保存</button>
          </div>
          <p class="download-helper">英数字のみ</p>
          <p class="status" id="downloadStatus"></p>
        </div>
      </div>
      <div class="action-links" id="actionLinks">
        <a class="action-btn action-btn--play is-disabled" id="pixfindPlay" aria-disabled="true" role="button">PiXFiNDで遊ぶ</a>
        <button class="action-btn action-btn--download is-disabled" id="downloadButton" type="button" disabled>ダウンロード</button>
        <button class="action-btn action-btn--share" id="shareButton" type="button">共有</button>
      </div>
      <p class="status" id="viewStatus"></p>
      <button class="danger-btn" id="deleteEntry" style="display:none;">この作品を削除する</button>
      <p class="status" id="deleteNotice"></p>
    </section>
    <section class="card">
      <h2 style="margin:0 0 8px;font-size:16px;">このユーザーの作品</h2>
      <div id="relatedGallery" class="gallery user-gallery"></div>
      <div class="load-more" id="relatedLoadMoreWrap" hidden>
        <button class="load-more-btn" id="relatedLoadMoreBtn" type="button">続きを見る</button>
      </div>
    </section>
  </div>
  <nav class="bottom-nav">
    <a class="bottom-nav__item" data-tab="home" href="../index.html">
      <span class="icon"><img src="../FooterIcon1.png" alt=""/></span><span>ホーム</span>
    </a>
    <a class="bottom-nav__item is-active" data-tab="contest" href="./index.html">
      <span class="icon"><img src="../FooterIcon2.png" alt=""/></span><span>コンテスト</span>
    </a>
    <a class="bottom-nav__item" data-tab="tools" href="../tools.html">
      <span class="icon"><img src="../FooterIcon3.png" alt=""/></span><span>ツール/ゲーム</span>
    </a>
    <a class="bottom-nav__item" data-tab="lens" href="../pixiee-lens/index.html">
      <span class="icon"><img src="../FooterIcon5.png" alt=""/></span><span>PiXiEELENS</span>
    </a>
    <a class="bottom-nav__item" data-tab="portfolio" href="../portfolio/index.html">
      <span class="icon"><img src="../FooterIcon4.png" alt=""/></span><span>企業向け</span>
    </a>
  </nav>
  <div class="auth-panel" id="authPanel" aria-hidden="true">
    <div class="auth-card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
        <h3 style="margin:0;font-size:16px;color:#f9fafb;">プロフィール</h3>
        <button class="close-btn" type="button" id="closeAuthPanel">閉じる</button>
      </div>
      <div class="profile-block">
        <div class="profile-row">
          <button class="avatar-toggle" id="avatarToggle" type="button" aria-label="アイコンを変更" aria-expanded="false" aria-controls="avatarPanel">
            <span class="avatar-toggle__img" id="avatarPreview"></span>
          </button>
          <label class="profile-name">
            <span style="font-weight:700; color:#e5e7eb;">ニックネーム</span>
            <input class="auth-input" id="profileNickname" type="text" placeholder="なまえ" maxlength="32">
          </label>
        </div>
        <div class="avatar-panel" id="avatarPanel" hidden>
          <div class="avatar-grid" id="avatarGrid"></div>
        </div>
        <label class="profile-name">
          <span style="font-weight:700; color:#e5e7eb;">X (旧Twitter)</span>
          <input class="auth-input" id="profileX" type="url" placeholder="https://x.com/username" maxlength="200" inputmode="url">
        </label>
        <button class="auth-btn" id="saveProfile" type="button">プロフィールを保存</button>
      </div>
      <div class="profile-block">
        <details class="auth-details" id="authDetails">
          <summary>
            <span>アカウントの保存（メール）</span>
            <span class="auth-details__status" id="linkedEmail" style="display:none;"></span>
          </summary>
          <div class="auth-details__body">
            <p class="author" style="margin:0;">長期保存 / 自動で引き継ぎ / 復旧可</p>
            <div id="authInputs" style="display:grid; gap:8px;">
              <input class="auth-input" id="authEmail" type="email" placeholder="メールアドレス" autocomplete="email">
              <input class="auth-input" id="authPasscode" type="password" placeholder="パスコード（6〜20文字）" autocomplete="current-password">
            </div>
            <button class="auth-btn" id="authBtn" type="button">メール＋パスコードでログイン</button>
            <button class="auth-btn logout" id="logoutBtn" type="button" style="display:none;">ログアウト</button>
            <p class="author" style="margin:0;">別端末でも同じアカウントで利用できます。</p>
          </div>
        </details>
      </div>
      <p class="auth-status" id="authStatus"></p>
    </div>
  </div>
  <script type="module">
    const NFAV_SRC = '../pixiedraw/assets/NFav.png';
    const FAV_SRC = '../pixiedraw/assets/Fav.png';
    const SUPABASE_URL = 'https://kyyiuakrqomzlikfaire.supabase.co';
    const SUPABASE_REST = `${SUPABASE_URL}/rest/v1`;
    const SUPABASE_ANON_KEY = 'sb_publishable_gnc61sD2hZvGHhEW8bQMoA_lrL07SN4';
    const STORAGE_BUCKET = 'pixieed-contest';
    const CONTEST_SHARE_BASE_URL = 'https://pixieed.jp/contest/view.html';
    const CONTEST_SHARE_OGP_WIDTH = 1200;
    const CONTEST_SHARE_OGP_HEIGHT = 630;
    const CONTEST_SHARE_PADDING = 60;
    const CONTEST_SHARE_TITLE_SIZE = 32;
    const SHARE_HASHTAG = '#PiXiEED';
    const SUPABASE_MAINTENANCE_KEY = 'pixieed_supabase_maintenance';
    const CONTEST_SHARE_QUEUE_KEY = 'contest_share_queue';
    const CONTEST_SHARE_QUEUE_LIMIT = 20;
    const PIXFIND_PROMPT_PREFIX = 'pixfind:';
    const PIXFIND_PATH = '../pixfind/index.html';
    const MAX_TAGS = 5;
    const TAG_INPUT_ID = 'tagEditInput';
    const TAG_LIST_ID = 'tagEditList';
    const TAG_VIEW_ID = 'tagView';
    const TAG_SAVE_BTN_ID = 'tagSaveBtn';
    const TAG_STATUS_ID = 'tagStatus';
    const DOWNLOAD_ALLOW_ID = 'downloadAllowToggle';
    const DOWNLOAD_PASS_TOGGLE_ID = 'downloadPassToggle';
    const DOWNLOAD_PASS_INPUT_ID = 'downloadPassInput';
    const DOWNLOAD_SAVE_BTN_ID = 'downloadSaveBtn';
    const DOWNLOAD_STATUS_ID = 'downloadStatus';
    const SAMPLE_COLORS = ['#7dd3fc','#f472b6','#facc15','#34d399','#c084fc','#60a5fa','#f59e0b','#a3e635','#f43f5e','#38bdf8'];
    let clientLinkConflict = false;
    let clientLinkChecked = false;
    const AVATARS = [
      { id:'mao', type:'img', src:'../character-dots/mao1.png' },
      { id:'jerin1', type:'img', src:'../character-dots/Jerin1.png' },
      { id:'jerin2', type:'img', src:'../character-dots/Jerin2.png' },
      { id:'jerin3', type:'img', src:'../character-dots/Jerin3.png' },
      { id:'jerin4', type:'img', src:'../character-dots/Jerin4.png' },
      { id:'jerin5', type:'img', src:'../character-dots/Jerin5.png' },
      { id:'jerin6', type:'img', src:'../character-dots/Jerin6.png' },
      { id:'jerin7', type:'img', src:'../character-dots/Jerin7.png' },
      { id:'jerin8', type:'img', src:'../character-dots/Jerin8.png' },
      { id:'jellnall1', type:'img', src:'../character-dots/JELLNALL1.png' },
      { id:'jellnall2', type:'img', src:'../character-dots/JELLNALL2.png' },
      { id:'jellnall3', type:'img', src:'../character-dots/JELLNALL3.png' },
      { id:'jellnall4', type:'img', src:'../character-dots/JELLNALL4.png' },
      { id:'jellnall5', type:'img', src:'../character-dots/JELLNALL5.png' },
      { id:'jellnall6', type:'img', src:'../character-dots/JELLNALL6.png' },
      { id:'jellnall7', type:'img', src:'../character-dots/JELLNALL7.png' },
      { id:'jellnall8', type:'img', src:'../character-dots/JELLNALL8.png' },
      { id:'jellnall9', type:'img', src:'../character-dots/JELLNALL9.png' },
      { id:'jellnall10', type:'img', src:'../character-dots/JELLNALL10.png' },
      { id:'jellnall11', type:'img', src:'../character-dots/JELLNALL11.png' },
      { id:'jellnall12', type:'img', src:'../character-dots/JELLNALL12.png' },
      { id:'jellnall13', type:'img', src:'../character-dots/JELLNALL13.png' },
      { id:'jellnall14', type:'img', src:'../character-dots/JELLNALL14.png' },
      { id:'jellnall15', type:'img', src:'../character-dots/JELLNALL15.png' },
      { id:'jellnall16', type:'img', src:'../character-dots/JELLNALL16.png' },
      { id:'jellnall17', type:'img', src:'../character-dots/JELLNALL17.png' },
      { id:'jellnall18', type:'img', src:'../character-dots/JELLNALL18.png' },
      { id:'jellnall19', type:'img', src:'../character-dots/JELLNALL19.png' },
      { id:'baburin', type:'img', src:'../character-dots/baburinpng.png' }
    ];
    let clientId = null;
    let supabaseMaintenance = Boolean(readSupabaseMaintenance());
    let supabaseAuth = null;
    let supabaseSession = null;
    let supabaseUser = null;
    let profileSyncChannel = null;
    let migrationDone = false;
    let likedEntries = new Set();
    let entry = null;
    let cachedEntries = [];
    let currentEntryId = 0;
    let editTags = [];
    let supportsDownloadSettings = true;
    let supportsImageUrls = true;
    let supportsVideoColumns = true;
    let supportsStorageUploads = true;
    let supportsXUrl = true;
    let supportsProfileXUrl = true;
    let relatedOffset = 0;
    let relatedHasMore = false;
    let relatedLoading = false;
    let entryLoaded = false;
    const ENTRY_SELECT_WITH_URL = 'id,client_id,user_id,name,title,width,height,colors,image_url,thumb_url,image_base64,submitted_at,mode,tags,prompt,allow_download,download_passcode';
    const ENTRY_SELECT_BASE = 'id,client_id,user_id,name,title,width,height,colors,image_base64,submitted_at,mode,tags,prompt,allow_download,download_passcode';
    const RELATED_SELECT_WITH_URL = 'id,name,title,submitted_at,mode,image_url,thumb_url';
    const RELATED_SELECT_BASE = 'id,name,title,submitted_at,mode,image_base64';
    const VIDEO_SELECT_COLUMNS = 'video_url,video_mime';
    const LIKE_SELECT = 'entry_id,user_id,client_id';
    const RELATED_FETCH_LIMIT = 12;

    function $(id){ return document.getElementById(id); }

    function setStatus(msg){
      const el = $('viewStatus');
      if(el) el.textContent = msg || '';
    }

    function readSupabaseMaintenance(){
      try{
        const raw = localStorage.getItem(SUPABASE_MAINTENANCE_KEY);
        if(!raw) return null;
        const data = JSON.parse(raw);
        if(data && data.active) return data;
      }catch(_){
        // ignore
      }
      return null;
    }

    function isSupabaseMaintenance(){
      return supabaseMaintenance;
    }

    function setSupabaseMaintenance(active, reason = ''){
      supabaseMaintenance = active;
      try{
        if(active){
          localStorage.setItem(SUPABASE_MAINTENANCE_KEY, JSON.stringify({ active: true, reason, ts: Date.now() }));
        }else{
          localStorage.removeItem(SUPABASE_MAINTENANCE_KEY);
        }
      }catch(_){
        // ignore
      }
      if(active){
        setStatus('メンテナンス中のため投稿・共有は一時停止しています');
      }
    }

    function noteSupabaseSuccess(){
      if(supabaseMaintenance){
        setSupabaseMaintenance(false);
      }
    }

    function shouldMarkSupabaseMaintenance(error, status){
      if(status && status >= 500) return true;
      const msg = String(error?.message || '').toLowerCase();
      return msg.includes('failed to fetch') || msg.includes('network') || msg.includes('fetch failed') || msg.includes('503') || msg.includes('502') || msg.includes('504');
    }

    function markSupabaseMaintenanceFromError(error, status){
      if(shouldMarkSupabaseMaintenance(error, status)){
        setSupabaseMaintenance(true, 'network');
      }
    }

    function loadShareQueue(){
      try{
        const raw = localStorage.getItem(CONTEST_SHARE_QUEUE_KEY);
        if(!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      }catch(_){
        return [];
      }
    }

    function saveShareQueue(queue){
      try{
        localStorage.setItem(CONTEST_SHARE_QUEUE_KEY, JSON.stringify(queue.slice(0, CONTEST_SHARE_QUEUE_LIMIT)));
      }catch(_){
        // ignore
      }
    }

    function queueShareTask(task){
      if(!task?.entryId) return;
      const queue = loadShareQueue();
      const next = queue.filter(item => item.entryId !== task.entryId);
      next.unshift(task);
      saveShareQueue(next);
    }

    function setAuthStatus(msg){
      const el = $('authStatus');
      if(el) el.textContent = msg || '';
    }

    function setTagStatus(msg){
      const el = $(TAG_STATUS_ID);
      if(el) el.textContent = msg || '';
    }

    function setDownloadStatus(msg){
      const el = $(DOWNLOAD_STATUS_ID);
      if(el) el.textContent = msg || '';
    }

    function normalizeTag(value){
      return String(value || '').replace(/^[#＃]+/, '').trim();
    }

    function parseTags(value){
      if(!value) return [];
      const raw = Array.isArray(value) ? value : String(value).split(',');
      const out = [];
      raw.forEach(tag => {
        const normalized = normalizeTag(tag);
        if(!normalized) return;
        if(!out.some(t => t.toLowerCase() === normalized.toLowerCase())){
          out.push(normalized);
        }
      });
      return out;
    }

    function canEditEntry(){
      if(!entry) return false;
      if(entry.user_id && supabaseUser?.id && entry.user_id === supabaseUser.id){
        return true;
      }
      if(!entry.user_id && entry.client_id && entry.client_id === clientId){
        return true;
      }
      return false;
    }

    function renderTagView(tags){
      const view = $(TAG_VIEW_ID);
      if(!view) return;
      view.innerHTML = '';
      if(!tags.length) return;
      tags.forEach(tag => {
        const chip = document.createElement('span');
        chip.className = 'tag-chip';
        chip.textContent = `#${tag}`;
        view.appendChild(chip);
      });
    }

    function renderTagEditor(){
      const editor = document.getElementById('tagEditor');
      const list = $(TAG_LIST_ID);
      if(!editor || !list) return;
      const editable = canEditEntry();
      editor.style.display = editable ? 'grid' : 'none';
      list.innerHTML = '';
      editTags.forEach(tag => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'tag-chip';
        chip.setAttribute('aria-label', `${tag} を削除`);
        const label = document.createElement('span');
        label.textContent = `#${tag}`;
        const remove = document.createElement('span');
        remove.className = 'tag-remove';
        remove.textContent = '×';
        chip.append(label, remove);
        chip.addEventListener('click', () => {
          editTags = editTags.filter(t => t.toLowerCase() !== tag.toLowerCase());
          renderTagEditor();
        });
        list.appendChild(chip);
      });
    }

    function updateDownloadEditorUI(){
      const allowToggle = $(DOWNLOAD_ALLOW_ID);
      const passToggle = $(DOWNLOAD_PASS_TOGGLE_ID);
      const passInput = $(DOWNLOAD_PASS_INPUT_ID);
      if(!allowToggle || !passToggle || !passInput) return;
      const allow = allowToggle.checked;
      if(!allow){
        passToggle.checked = false;
      }
      passToggle.disabled = !allow;
      passInput.disabled = !(allow && passToggle.checked);
    }

    function renderDownloadEditor(){
      const editor = $('downloadEditor');
      if(!editor) return;
      const editable = canEditEntry() && supportsDownloadSettings;
      editor.style.display = editable ? 'grid' : 'none';
      if(!editable || !entry) return;
      const allowToggle = $(DOWNLOAD_ALLOW_ID);
      const passToggle = $(DOWNLOAD_PASS_TOGGLE_ID);
      const passInput = $(DOWNLOAD_PASS_INPUT_ID);
      const allow = isDownloadAllowed(entry.allow_download);
      const passcode = String(entry.download_passcode || '');
      if(allowToggle) allowToggle.checked = allow;
      if(passToggle) passToggle.checked = allow && Boolean(passcode);
      if(passInput) passInput.value = passcode;
      updateDownloadEditorUI();
    }

    function normalizeDownloadPasscode(value){
      return String(value || '').trim();
    }

    async function saveDownloadSettings(){
      if(!entry){
        setDownloadStatus('作品が読み込まれていません');
        return;
      }
      if(!canEditEntry()){
        setDownloadStatus('この作品は編集できません');
        return;
      }
      const allowToggle = $(DOWNLOAD_ALLOW_ID);
      const passToggle = $(DOWNLOAD_PASS_TOGGLE_ID);
      const passInput = $(DOWNLOAD_PASS_INPUT_ID);
      if(!allowToggle || !passToggle || !passInput){
        setDownloadStatus('設定項目が見つかりません');
        return;
      }
      const allow = allowToggle.checked;
      const requirePass = passToggle.checked;
      let passcode = null;
      if(allow && requirePass){
        const raw = normalizeDownloadPasscode(passInput.value);
        if(raw.length < 4 || raw.length > 12){
          setDownloadStatus('パスコードは4〜12文字で入力してください');
          return;
        }
        if(!/^[a-zA-Z0-9]+$/.test(raw)){
          setDownloadStatus('パスコードは英数字のみです');
          return;
        }
        passcode = raw;
      }
      const payload = { allow_download: allow, download_passcode: passcode };
      const eq = { id: entry.id };
      if(entry.user_id && supabaseUser?.id){
        eq.user_id = supabaseUser.id;
      }else if(entry.client_id){
        eq.client_id = entry.client_id;
      }
      if(!eq.user_id && !eq.client_id){
        setDownloadStatus('編集権限が確認できません');
        return;
      }
      setDownloadStatus('保存中...');
      try{
        await supabaseUpdate('contest_entries', payload, { eq });
        entry.allow_download = allow;
        entry.download_passcode = passcode;
        setDownloadStatus('保存しました');
        render();
      }catch(err){
        console.error(err);
        if(isMissingColumn(err, 'allow_download') || isMissingColumn(err, 'download_passcode')){
          supportsDownloadSettings = false;
          renderDownloadEditor();
          setDownloadStatus('ダウンロード設定は未対応です');
          return;
        }
        setDownloadStatus('保存に失敗しました');
      }
    }

    function addTag(tag){
      const normalized = normalizeTag(tag);
      if(!normalized) return;
      if(editTags.length >= MAX_TAGS) return;
      if(!editTags.some(t => t.toLowerCase() === normalized.toLowerCase())){
        editTags.push(normalized);
      }
      renderTagEditor();
    }

    function addTagsFromInput(){
      const input = $(TAG_INPUT_ID);
      if(!input) return;
      const raw = input.value;
      if(!raw) return;
      const candidates = raw.split(/[,，、。．\s]+/).map(normalizeTag).filter(Boolean);
      candidates.forEach(addTag);
      input.value = '';
    }

    async function saveTags(){
      if(!entry){
        setTagStatus('作品が読み込まれていません');
        return;
      }
      if(!canEditEntry()){
        setTagStatus('この作品は編集できません');
        return;
      }
      addTagsFromInput();
      const tags = editTags.slice(0, MAX_TAGS);
      const payload = { tags: tags.length ? tags.join(',') : null };
      const eq = { id: entry.id };
      if(entry.user_id && supabaseUser?.id){
        eq.user_id = supabaseUser.id;
      }else if(entry.client_id){
        eq.client_id = entry.client_id;
      }
      if(!eq.user_id && !eq.client_id){
        setTagStatus('編集権限が確認できません');
        return;
      }
      setTagStatus('保存中...');
      try{
        await supabaseUpdate('contest_entries', payload, { eq });
        entry.tags = payload.tags || '';
        renderTagView(parseTags(entry.tags));
        setTagStatus('保存しました');
      }catch(err){
        console.error(err);
        setTagStatus('タグの保存に失敗しました');
      }
    }

    function setupTagEditor(){
      const input = $(TAG_INPUT_ID);
      const saveBtn = $(TAG_SAVE_BTN_ID);
      if(input){
        input.addEventListener('keydown', (e) => {
          if(e.key === 'Enter'){
            e.preventDefault();
            addTagsFromInput();
          }
        });
      }
      if(saveBtn) saveBtn.addEventListener('click', saveTags);
    }

    function setupDownloadEditor(){
      const allowToggle = $(DOWNLOAD_ALLOW_ID);
      const passToggle = $(DOWNLOAD_PASS_TOGGLE_ID);
      const saveBtn = $(DOWNLOAD_SAVE_BTN_ID);
      if(allowToggle){
        allowToggle.addEventListener('change', updateDownloadEditorUI);
      }
      if(passToggle){
        passToggle.addEventListener('change', updateDownloadEditorUI);
      }
      if(saveBtn) saveBtn.addEventListener('click', saveDownloadSettings);
    }

    function loadNickname(){
      try{
        return localStorage.getItem('pixieed_nickname') || '';
      }catch(_){
        return '';
      }
    }
    function saveNickname(name){
      try{
        localStorage.setItem('pixieed_nickname', name);
      }catch(_){}
    }

    function loadXUrl(){
      try{
        return localStorage.getItem('pixieed_x_url') || '';
      }catch(_){
        return '';
      }
    }

    function normalizeXUrl(value){
      const raw = String(value || '').trim();
      if(!raw) return '';
      if(/^https?:\/\//i.test(raw)){
        try{
          const url = new URL(raw);
          const host = url.hostname.replace(/^www\./, '');
          if(host === 'x.com' || host.endsWith('.x.com') || host === 'twitter.com' || host.endsWith('.twitter.com')){
            return url.toString();
          }
        }catch(_){}
        return '';
      }
      const handle = raw.replace(/^@+/, '').trim();
      if(!handle) return '';
      const candidate = /^(x\.com|twitter\.com)\//i.test(handle)
        ? `https://${handle}`
        : `https://x.com/${handle}`;
      try{
        const url = new URL(candidate);
        const host = url.hostname.replace(/^www\./, '');
        if(host === 'x.com' || host.endsWith('.x.com') || host === 'twitter.com' || host.endsWith('.twitter.com')){
          return url.toString();
        }
      }catch(_){}
      return '';
    }

    function saveXUrl(value){
      try{
        const normalized = normalizeXUrl(value);
        if(normalized){
          localStorage.setItem('pixieed_x_url', normalized);
        }else{
          localStorage.removeItem('pixieed_x_url');
        }
      }catch(_){}
    }

    const PROFILE_DIRTY_FIELDS_KEY = 'pixieed_profile_dirty_fields';

    function loadProfileDirtyFields(){
      try{
        const raw = localStorage.getItem(PROFILE_DIRTY_FIELDS_KEY);
        if(!raw) return new Set();
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)){
          return new Set(parsed.filter(Boolean));
        }
      }catch(_){}
      return new Set();
    }

    function saveProfileDirtyFields(fields){
      try{
        if(!fields || fields.size === 0){
          localStorage.removeItem(PROFILE_DIRTY_FIELDS_KEY);
          return;
        }
        localStorage.setItem(PROFILE_DIRTY_FIELDS_KEY, JSON.stringify(Array.from(fields)));
      }catch(_){}
    }

    function markProfileDirty(...fields){
      const set = loadProfileDirtyFields();
      fields.filter(Boolean).forEach(field => set.add(field));
      saveProfileDirtyFields(set);
    }

    function clearProfileDirty(...fields){
      if(!fields.length){
        try{ localStorage.removeItem(PROFILE_DIRTY_FIELDS_KEY); }catch(_){}
        return;
      }
      const set = loadProfileDirtyFields();
      fields.forEach(field => set.delete(field));
      saveProfileDirtyFields(set);
    }

    function applyProfileFromServer(data, { force = false } = {}){
      if(!data) return;
      const serverNick = (data.nickname || '').trim();
      const serverAvatar = data.avatar || '';
      const hasXUrl = supportsProfileXUrl && Object.prototype.hasOwnProperty.call(data, 'x_url');
      const serverXUrl = hasXUrl ? normalizeXUrl(data.x_url || '') : '';
      if(force){
        saveNickname(serverNick);
        saveAvatar(serverAvatar);
        if(hasXUrl) saveXUrl(serverXUrl);
        clearProfileDirty('nickname', 'avatar', 'x_url');
      }
      const nickInput = document.getElementById('profileNickname');
      if(nickInput){
        nickInput.value = force ? serverNick : (nickInput.value || serverNick || '');
      }
      const xInput = document.getElementById('profileX');
      if(xInput && hasXUrl){
        xInput.value = force ? serverXUrl : (xInput.value || serverXUrl || '');
      }
      applyAvatarToBrand();
      renderAvatarChoices();
    }

    function loadAvatar(){
      try{
        return localStorage.getItem('pixieed_avatar') || 'mao';
      }catch(_){
        return 'mao';
      }
    }
    function saveAvatar(id){
      try{
        localStorage.setItem('pixieed_avatar', id);
      }catch(_){}
    }

    function applyAvatarToBrand(){
      const brand = document.getElementById('brandAvatar');
      const brandUser = document.getElementById('brandUser');
      const preview = document.getElementById('avatarPreview');
      const avatarId = loadAvatar();
      const found = AVATARS.find(a => a.id === avatarId);
      if(brand){
        if(found && found.type === 'img'){
          brand.style = 'border:1px solid rgba(255,255,255,0.25); background:rgba(255,255,255,0.08);';
          brand.innerHTML = `<img src="${found.src}" alt="avatar">`;
        }else if(found && found.style){
          brand.style = `${found.style} border:1px solid rgba(255,255,255,0.25);`;
          brand.innerHTML = '';
        }else{
          brand.style = 'border:1px solid rgba(255,255,255,0.25); background:rgba(255,255,255,0.08);';
          brand.innerHTML = `<img src="../character-dots/mao1.png" alt="logo">`;
        }
      }
      if(preview){
        if(found && found.type === 'img'){
          preview.innerHTML = `<img src="${found.src}" alt="avatar">`;
        }else{
          preview.innerHTML = `<img src="../character-dots/mao1.png" alt="avatar">`;
        }
      }
      if(brandUser){
        const nick = loadNickname();
        brandUser.textContent = nick || 'ユーザー';
      }
    }

    function renderAvatarChoices(){
      const grid = document.getElementById('avatarGrid');
      if(!grid) return;
      grid.innerHTML = '';
      const current = loadAvatar();
      AVATARS.forEach(a => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `avatar-option${current === a.id ? ' is-active' : ''}`;
        if(a.type === 'img' && a.src){
          btn.style = 'background:rgba(0,0,0,0.7);';
          const im = document.createElement('img');
          im.src = a.src;
          im.alt = a.id;
          im.style.width = '80%';
          im.style.height = '80%';
          im.style.objectFit = 'contain';
          im.style.pointerEvents = 'none';
          im.style.imageRendering = 'pixelated';
          im.style.imageRendering = 'crisp-edges';
          btn.appendChild(im);
        }else{
          btn.style = a.style;
          btn.textContent = '';
        }
        btn.addEventListener('click', () => {
          saveAvatar(a.id);
          markProfileDirty('avatar');
          renderAvatarChoices();
          applyAvatarToBrand();
          const panel = document.getElementById('avatarPanel');
          const toggle = document.getElementById('avatarToggle');
          if(panel){
            panel.hidden = true;
          }
          if(toggle){
            toggle.setAttribute('aria-expanded','false');
          }
        });
        grid.appendChild(btn);
      });
    }

    function setupAvatarToggle(){
      const toggle = document.getElementById('avatarToggle');
      const panel = document.getElementById('avatarPanel');
      if(!toggle || !panel) return;
      const setOpen = (open) => {
        panel.hidden = !open;
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      };
      setOpen(false);
      toggle.addEventListener('click', () => {
        setOpen(panel.hidden);
      });
    }

    function setDeleteNotice(msg){
      const el = $('deleteNotice');
      if(el) el.textContent = msg || '';
    }

    function resolvePixfindPuzzleId(value){
      if(!value) return null;
      const raw = String(value).trim();
      if(!raw) return null;
      if(raw.startsWith(PIXFIND_PROMPT_PREFIX)){
        return raw.slice(PIXFIND_PROMPT_PREFIX.length).trim();
      }
      if(raw.startsWith('pixfind://')){
        return raw.slice('pixfind://'.length).trim();
      }
      return null;
    }

    function buildPixfindUrl(target){
      if(!target) return null;
      return `${PIXFIND_PATH}?puzzle=${encodeURIComponent(target)}`;
    }

    function resolveEntryImage(entry, { preferThumb = false } = {}){
      if(!entry) return '';
      const thumb = entry.thumb_url || '';
      const full = entry.image_url || '';
      const base = entry.image_base64 || '';
      return preferThumb ? (thumb || full || base || '') : (full || base || thumb || '');
    }

    function resolveEntryVideo(entry){
      if(!entry) return '';
      const value = String(entry.video_url || '').trim();
      return value || '';
    }

    function resolveAuthorUrl(entry){
      const fromEntry = normalizeXUrl(entry?.x_url || '');
      if(fromEntry) return fromEntry;
      const local = normalizeXUrl(loadXUrl());
      const isOwner = entry && ((entry.user_id && supabaseUser?.id === entry.user_id) || (!entry.user_id && entry.client_id === clientId));
      return isOwner ? local : '';
    }

    function renderAuthor(authorEl, entryData){
      if(!authorEl) return;
      authorEl.textContent = '';
      const name = entryData?.name || '名無し';
      const prefix = document.createElement('span');
      prefix.textContent = 'by ';
      authorEl.appendChild(prefix);
      const url = resolveAuthorUrl(entryData);
      if(url){
        const link = document.createElement('a');
        link.href = url;
        link.textContent = name;
        link.target = '_blank';
        link.rel = 'noopener';
        authorEl.appendChild(link);
      }else{
        const label = document.createElement('span');
        label.textContent = name;
        authorEl.appendChild(label);
      }
    }

    function getRelatedFilter(){
      if(!entry) return null;
      if(entry.user_id) return { key: 'user_id', value: entry.user_id };
      if(entry.client_id) return { key: 'client_id', value: entry.client_id };
      if(entry.name) return { key: 'name', value: entry.name };
      return null;
    }

    function updateRelatedLoadMore(){
      const wrap = $('relatedLoadMoreWrap');
      const btn = $('relatedLoadMoreBtn');
      if(!wrap || !btn) return;
      wrap.hidden = !relatedHasMore;
      btn.disabled = relatedLoading;
    }

    function createRelatedAdCard(){
      const card = document.createElement('div');
      card.className = 'entry-card entry-card--ad';
      card.innerHTML = `
        <div class="entry-ad-slot">
          <ins class="adsbygoogle"
               style="display:block"
               data-ad-client="ca-pub-9801602250480253"
               data-ad-slot="rotate"
               data-ad-format="auto"></ins>
        </div>
        <p class="entry-ad-note">広告</p>
      `;
      return card;
    }

    function getEntrySelect(){
      let base = supportsImageUrls ? ENTRY_SELECT_WITH_URL : ENTRY_SELECT_BASE;
      if(supportsVideoColumns){
        base = `${base},${VIDEO_SELECT_COLUMNS}`;
      }
      return supportsXUrl ? `${base},x_url` : base;
    }

    function getRelatedSelect(){
      let base = supportsImageUrls ? RELATED_SELECT_WITH_URL : RELATED_SELECT_BASE;
      if(supportsVideoColumns){
        base = `${base},video_url`;
      }
      return base;
    }

    function isDownloadAllowed(value){
      return value === true || value === 'true' || value === 1 || value === '1';
    }

    function getDownloadExtension(dataUrl){
      if(typeof dataUrl !== 'string') return 'png';
      if(dataUrl.startsWith('data:image/gif')) return 'gif';
      if(dataUrl.startsWith('data:image/jpeg')) return 'jpg';
      if(dataUrl.startsWith('data:image/webp')) return 'webp';
      if(dataUrl.startsWith('data:video/mp4')) return 'mp4';
      if(dataUrl.startsWith('data:video/webm')) return 'webm';
      const clean = dataUrl.split('?')[0];
      const match = clean.match(/\.([a-z0-9]+)$/i);
      if(match && match[1]){
        return match[1].toLowerCase();
      }
      return 'png';
    }

    async function handleDownload(){
      if(!entry) return;
      if(!isDownloadAllowed(entry.allow_download)){
        setStatus('この作品はダウンロード不可です');
        return;
      }
      const passcode = String(entry.download_passcode || '').trim();
      if(passcode){
        const input = window.prompt('ダウンロードパスコードを入力してください') || '';
        if(!input){
          setStatus('パスコードを入力してください');
          return;
        }
        if(input !== passcode){
          setStatus('パスコードが違います');
          return;
        }
      }
      const source = resolveEntryVideo(entry) || resolveEntryImage(entry);
      if(!source){
        setStatus('画像が見つかりません');
        return;
      }
      const ext = getDownloadExtension(source);
      const safeTitle = (entry.title || 'pixieed').replace(/[^\w\-]+/g, '-');
      const filename = `${safeTitle || 'pixieed'}-${entry.id}.${ext}`;
      const link = document.createElement('a');
      if(source.startsWith('data:')){
        link.href = source;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setStatus('ダウンロードしました');
        return;
      }
      setStatus('ダウンロード中...');
      try{
        const res = await fetch(source);
        if(!res.ok){
          throw new Error(`download failed: ${res.status}`);
        }
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setStatus('ダウンロードしました');
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }catch(err){
        console.error(err);
        setStatus('ダウンロードに失敗しました');
      }
    }

    function ensureClientId(){
      const KEY = 'pixieed_client_id';
      try{
        const saved = localStorage.getItem(KEY) || window.PIXIEED_CLIENT_ID;
        if(saved){
          clientId = saved;
          if(!localStorage.getItem(KEY)) localStorage.setItem(KEY, saved);
          return;
        }
        const id = crypto.randomUUID ? crypto.randomUUID() : `guest-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
        localStorage.setItem(KEY, id);
        clientId = id;
      }catch(_){
        clientId = `guest-${Math.random().toString(36).slice(2,8)}`;
      }
    }

    function isMissingColumn(error, column){
      return String(error?.message || '').includes(column);
    }

    async function getLinkedUserIdForClient(){
      if(!supabaseAuth || !clientId) return null;
      const tables = ['contest_entries','contest_likes','scores'];
      for(const table of tables){
        try{
          const { data, error } = await supabaseAuth
            .from(table)
            .select('user_id')
            .eq('client_id', clientId)
            .not('user_id','is',null)
            .limit(1);
          if(error){
            if(isMissingColumn(error, 'user_id')) continue;
            continue;
          }
          if(Array.isArray(data) && data.length && data[0].user_id){
            return data[0].user_id;
          }
        }catch(_){
          continue;
        }
      }
      return null;
    }

    async function checkClientLinkConflict(){
      if(!supabaseAuth || !supabaseUser?.id || !clientId) return false;
      if(clientLinkChecked) return clientLinkConflict;
      clientLinkChecked = true;
      const linkedUserId = await getLinkedUserIdForClient();
      clientLinkConflict = !!(linkedUserId && linkedUserId !== supabaseUser.id);
      try{
        if(clientLinkConflict){
          localStorage.setItem('pixieed_link_conflict','1');
        }else{
          localStorage.removeItem('pixieed_link_conflict');
        }
      }catch(_){}
      return clientLinkConflict;
    }

    async function migrateGuestData(){
      if(!supabaseAuth || !supabaseUser?.id || migrationDone || !clientId) return;
      const isConflict = await checkClientLinkConflict();
      if(isConflict){
        setAuthStatus('別アカウントに紐付け済みのため、ゲスト投稿の移行を停止しました');
        return;
      }
      try{
        const entryRes = await supabaseAuth.from('contest_entries')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(entryRes.error) throw entryRes.error;
        const likeRes = await supabaseAuth.from('contest_likes')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(likeRes.error) throw likeRes.error;
        const scoreRes = await supabaseAuth.from('scores')
          .update({ user_id: supabaseUser.id })
          .eq('client_id', clientId)
          .is('user_id', null);
        if(scoreRes.error && !isMissingColumn(scoreRes.error, 'user_id')){
          console.warn('score migrate skipped', scoreRes.error);
        }
        migrationDone = true;
      }catch(err){
        console.error('migrate error', err);
      }
    }

    async function syncProfileFromServer(){
      if(!supabaseAuth || !supabaseUser?.id) return;
      const localNick = loadNickname();
      const localAvatar = loadAvatar();
      const localXUrl = normalizeXUrl(loadXUrl());
      const dirtyFields = loadProfileDirtyFields();
      try{
        let selectColumns = supportsProfileXUrl ? 'nickname, avatar, x_url' : 'nickname, avatar';
        let { data, error } = await supabaseAuth
          .from('user_profiles')
          .select(selectColumns)
          .eq('id', supabaseUser.id)
          .maybeSingle();
        if(error && supportsProfileXUrl && isMissingColumn(error, 'x_url')){
          supportsProfileXUrl = false;
          selectColumns = 'nickname, avatar';
          ({ data, error } = await supabaseAuth
            .from('user_profiles')
            .select(selectColumns)
            .eq('id', supabaseUser.id)
            .maybeSingle());
        }
        if(error) throw error;
        const serverNick = (data?.nickname || '').trim();
        const serverAvatar = data?.avatar || '';
        const serverXUrl = normalizeXUrl(data?.x_url || '');
        if(!dirtyFields.has('nickname') && serverNick) saveNickname(serverNick);
        if(!dirtyFields.has('avatar') && serverAvatar) saveAvatar(serverAvatar);
        if(!dirtyFields.has('x_url') && serverXUrl) saveXUrl(serverXUrl);
        const payload = { id: supabaseUser.id };
        const dirtyToClear = [];
        if(dirtyFields.has('nickname')){
          payload.nickname = localNick || null;
          dirtyToClear.push('nickname');
        }else if(localNick && !serverNick){
          payload.nickname = localNick;
        }
        if(dirtyFields.has('avatar')){
          payload.avatar = localAvatar || null;
          dirtyToClear.push('avatar');
        }else if(localAvatar && !serverAvatar){
          payload.avatar = localAvatar;
        }
        if(supportsProfileXUrl){
          if(dirtyFields.has('x_url')){
            payload.x_url = localXUrl || null;
            dirtyToClear.push('x_url');
          }else if(localXUrl && !serverXUrl){
            payload.x_url = localXUrl;
          }
        }
        if(Object.keys(payload).length > 1){
          let upsert = await supabaseAuth.from('user_profiles').upsert(payload);
          if(upsert.error && supportsProfileXUrl && isMissingColumn(upsert.error, 'x_url')){
            supportsProfileXUrl = false;
            delete payload.x_url;
            const idx = dirtyToClear.indexOf('x_url');
            if(idx >= 0) dirtyToClear.splice(idx, 1);
            if(Object.keys(payload).length > 1){
              upsert = await supabaseAuth.from('user_profiles').upsert(payload);
            }else{
              upsert = null;
            }
          }
          if(upsert?.error) throw upsert.error;
          if(dirtyToClear.length){
            clearProfileDirty(...dirtyToClear);
          }
        }
        const nickInput = document.getElementById('profileNickname');
        if(nickInput){
          const effectiveNick = dirtyFields.has('nickname') ? localNick : (serverNick || localNick);
          nickInput.value = effectiveNick || '';
        }
        const xInput = document.getElementById('profileX');
        if(xInput){
          const effectiveXUrl = dirtyFields.has('x_url') ? localXUrl : (serverXUrl || localXUrl);
          xInput.value = effectiveXUrl || '';
        }
        applyAvatarToBrand();
        renderAvatarChoices();
      }catch(err){
        console.warn('profile sync failed', err);
      }
    }

    function clearProfileSyncChannel(){
      if(!profileSyncChannel) return;
      try{
        if(supabaseAuth && typeof supabaseAuth.removeChannel === 'function'){
          supabaseAuth.removeChannel(profileSyncChannel);
        }
      }catch(err){
        console.warn('profile sync cleanup failed', err);
      }
      profileSyncChannel = null;
    }

    function setupProfileSyncChannel(){
      if(!supabaseAuth || !supabaseUser?.id || typeof supabaseAuth.channel !== 'function'){
        clearProfileSyncChannel();
        return;
      }
      clearProfileSyncChannel();
      try{
        profileSyncChannel = supabaseAuth.channel(`profile-sync-${supabaseUser.id}`);
        profileSyncChannel.on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'user_profiles',
          filter: `id=eq.${supabaseUser.id}`
        }, (payload) => {
          const data = payload?.new || payload?.record;
          if(!data) return;
          applyProfileFromServer(data, { force: true });
        });
        profileSyncChannel.subscribe();
      }catch(err){
        console.warn('profile sync init failed', err);
      }
    }

    function updateAuthUI(){
      const btn = document.getElementById('authBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const nick = loadNickname();
      const emailInput = document.getElementById('authEmail');
      const passInput = document.getElementById('authPasscode');
      const authInputs = document.getElementById('authInputs');
      const linkedEmail = document.getElementById('linkedEmail');
      if(!btn) return;
      if(supabaseUser){
        if(logoutBtn) logoutBtn.style.display = 'block';
        btn.style.display = 'none';
        setAuthStatus(`ログイン中${supabaseUser.email ? `: ${supabaseUser.email}` : ''}${nick ? ` / ${nick}` : ''}`);
        if(emailInput){
          emailInput.value = supabaseUser.email || emailInput.value;
          emailInput.disabled = true;
        }
        if(passInput){
          passInput.value = '';
          passInput.disabled = true;
        }
        if(authInputs) authInputs.style.display = 'none';
        if(linkedEmail){
          linkedEmail.style.display = 'inline-flex';
          linkedEmail.textContent = supabaseUser.email ? `紐付け済み: ${supabaseUser.email}` : '紐付け済み';
        }
      }else{
        btn.textContent = 'メール＋パスコードでログイン';
        btn.style.display = '';
        if(logoutBtn) logoutBtn.style.display = 'none';
        setAuthStatus(nick ? `ニックネーム: ${nick}` : '');
        if(emailInput){
          emailInput.disabled = false;
        }
        if(passInput){
          passInput.disabled = false;
        }
        if(authInputs) authInputs.style.display = 'grid';
        if(linkedEmail){
          linkedEmail.style.display = 'none';
          linkedEmail.textContent = '';
        }
      }
      if(clientLinkConflict){
        setAuthStatus('別アカウントに紐付け済みのため、ゲスト投稿の移行を停止しました');
      }
    }

    async function initSupabaseAuth(){
      try{
        const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2.46.1?bundle');
        supabaseAuth = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          global:{ headers:{ 'x-client-id': clientId || '' } }
        });
        window.__pixieedSupabase = supabaseAuth;
        const { data } = await supabaseAuth.auth.getSession();
        supabaseSession = data?.session || null;
        supabaseUser = supabaseSession?.user || null;
        supabaseAuth.auth.onAuthStateChange(async (_event, session) => {
          supabaseSession = session || null;
          supabaseUser = session?.user || null;
          clientLinkChecked = false;
          clientLinkConflict = false;
          migrationDone = false;
          await migrateGuestData();
          await syncProfileFromServer();
          updateAuthUI();
          setupProfileSyncChannel();
          if(currentEntryId){
            await fetchEntry(currentEntryId);
            scheduleRelatedFetch(currentEntryId);
          }
        });
        clientLinkChecked = false;
        clientLinkConflict = false;
        await checkClientLinkConflict();
        await migrateGuestData();
        await syncProfileFromServer();
        updateAuthUI();
        setupProfileSyncChannel();
        applyAvatarToBrand();
      }catch(err){
        console.warn('Supabase auth init failed', err);
        supabaseAuth = null;
      }
    }

    function setupAuthButton(){
      const btn = document.getElementById('authBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const openBtn = document.getElementById('openProfilePanel');
      const closeBtn = document.getElementById('closeAuthPanel');
      const panel = document.getElementById('authPanel');
      const saveBtn = document.getElementById('saveProfile');
      const nicknameInput = document.getElementById('profileNickname');
      const xInput = document.getElementById('profileX');
      const togglePanel = (open) => {
        if(!panel) return;
        if(open){
          if(nicknameInput) nicknameInput.value = loadNickname();
          panel.classList.add('is-open');
          panel.setAttribute('aria-hidden','false');
        }else{
          panel.classList.remove('is-open');
          panel.setAttribute('aria-hidden','true');
        }
      };
      const sendLoginLink = async (email) => {
        if(!supabaseAuth){
          setAuthStatus('オンラインでログインしてください');
          return false;
        }
        setAuthStatus('ログインリンクを送信しています...');
        try{
          const { error } = await supabaseAuth.auth.signInWithOtp({
            email,
            options:{ emailRedirectTo: window.location.href }
          });
          if(error) throw error;
          setAuthStatus('ログインリンクを送信しました。メールを確認してください');
          return true;
        }catch(err){
          console.error(err);
          setAuthStatus('ログインリンクの送信に失敗しました');
          return false;
        }
      };
      if(openBtn) openBtn.addEventListener('click', () => {
        if(nicknameInput) nicknameInput.value = loadNickname();
        if(xInput) xInput.value = loadXUrl();
        renderAvatarChoices();
        togglePanel(true);
      });
      if(closeBtn) closeBtn.addEventListener('click', () => togglePanel(false));
      if(panel){
        panel.addEventListener('click', (e) => { if(e.target === panel) togglePanel(false); });
      }
      if(saveBtn){
        saveBtn.addEventListener('click', async () => {
          const nick = (nicknameInput?.value || '').trim();
          const xUrl = normalizeXUrl(xInput?.value || '');
          markProfileDirty('nickname', 'avatar', 'x_url');
          if(nick) saveNickname(nick);
          saveXUrl(xUrl);
          applyAvatarToBrand();
          if(supabaseAuth && supabaseUser?.id){
            try{
              const payload = { id: supabaseUser.id, nickname: nick || null, avatar: loadAvatar() };
              if(supportsProfileXUrl) payload.x_url = xUrl || null;
              let res = await supabaseAuth.from('user_profiles').upsert(payload);
              if(res.error && supportsProfileXUrl && isMissingColumn(res.error, 'x_url')){
                supportsProfileXUrl = false;
                delete payload.x_url;
                res = await supabaseAuth.from('user_profiles').upsert(payload);
              }
              if(res.error) throw res.error;
              setAuthStatus('プロフィールを保存しました');
              clearProfileDirty('nickname', 'avatar', 'x_url');
            }catch(err){
              console.warn('profile save fallback', err);
              setAuthStatus('ローカルに保存しました');
            }
          }else{
            setAuthStatus('ローカルに保存しました');
          }
        });
      }
      if(!btn) return;
      btn.addEventListener('click', async () => {
        if(!supabaseAuth){
          setAuthStatus('オンラインでログインしてください');
          return;
        }
        let email = window.prompt('メールアドレスを入力してください') || '';
        if(!email){
          setAuthStatus('メールアドレスを入力してください');
          return;
        }
        let passcode = window.prompt('パスコード（6〜20文字）を入力してください') || '';
        if(!passcode){
          const confirmSend = window.confirm('パスコード未入力のため、ログインリンクを送信しますか？');
          if(!confirmSend){
            setAuthStatus('ログインをキャンセルしました');
            return;
          }
          await sendLoginLink(email);
          return;
        }
        if(passcode.length < 6 || passcode.length > 20){
          setAuthStatus('パスコードは6〜20文字で入力してください');
          return;
        }
        setAuthStatus('サインインしています...');
        try{
          const { error } = await supabaseAuth.auth.signInWithPassword({ email, password: passcode });
          if(error){
            if(String(error.message || '').toLowerCase().includes('confirm')){
              await supabaseAuth.auth.resend({ type:'signup', email, options:{ emailRedirectTo: window.location.href } });
              setAuthStatus('確認メールを再送しました。メールを確認してください');
              return;
            }
            const { error: signUpError } = await supabaseAuth.auth.signUp({ email, password: passcode, options:{ emailRedirectTo: window.location.href } });
            if(signUpError){
              const msg = String(signUpError.message || '').toLowerCase();
              if(msg.includes('already') || msg.includes('registered') || msg.includes('exists')){
                setAuthStatus('このメールは登録済みです。パスコードを確認してください');
                return;
              }
              setAuthStatus('ログイン／登録に失敗しました');
              console.error(signUpError);
              return;
            }
            setAuthStatus('確認メールを送信しました。メールを確認してください');
          }else{
            setAuthStatus('サインインしました');
          }
        }catch(err){
          console.error(err);
          setAuthStatus('ログインに失敗しました');
        }
      });
      if(logoutBtn){
        logoutBtn.addEventListener('click', async () => {
          if(!supabaseAuth) return;
          try{
            await supabaseAuth.auth.signOut();
          }catch(err){
            console.warn('logout failed', err);
          }
          supabaseSession = null;
          supabaseUser = null;
          migrationDone = false;
          clientLinkChecked = false;
          clientLinkConflict = false;
          try{ localStorage.removeItem('pixieed_link_conflict'); }catch(_){}
          updateAuthUI();
          clearProfileSyncChannel();
          await fetchEntry(currentEntryId);
          scheduleRelatedFetch(currentEntryId);
          togglePanel(false);
        });
      }
    }

    function render(){
      const img = $('heroImg');
      const video = $('heroVideo');
      const titleEl = $('heroTitle');
      const authorEl = $('heroAuthor');
      const likesEl = $('heroLikes');
      const likeIcon = $('heroLikeIcon');
      const delBtn = $('deleteEntry');
      const playBtn = $('pixfindPlay');
      const downloadBtn = $('downloadButton');
      const shareBtn = $('shareButton');
      if(!entry){
        img.src = '';
        if(video){
          video.pause();
          video.removeAttribute('src');
          video.removeAttribute('poster');
          delete video.dataset.src;
          video.hidden = true;
          video.load();
        }
        img.hidden = false;
        titleEl.textContent = '読み込めませんでした';
        if(authorEl) authorEl.textContent = '';
        likesEl.textContent = '';
        if(delBtn) delBtn.style.display = 'none';
        if(playBtn){
          playBtn.classList.add('is-disabled');
          playBtn.setAttribute('aria-disabled','true');
          playBtn.removeAttribute('href');
        }
        if(downloadBtn){
          downloadBtn.disabled = true;
          downloadBtn.classList.add('is-disabled');
        }
        if(shareBtn){
          shareBtn.disabled = true;
          shareBtn.classList.add('is-disabled');
        }
        return;
      }
      const fallbackImgSrc = resolveEntryImage(entry) || makePlaceholder('#334155');
      const videoSrc = resolveEntryVideo(entry);
      const posterSrc = resolveEntryImage(entry, { preferThumb: true }) || fallbackImgSrc;
      const showVideo = Boolean(videoSrc && video);
      if(showVideo){
        img.hidden = true;
        img.removeAttribute('src');
        if(video){
          video.hidden = false;
          if(video.poster !== posterSrc){
            video.poster = posterSrc;
          }
          if(video.dataset.src !== videoSrc){
            video.src = videoSrc;
            video.dataset.src = videoSrc;
          }
          video.onerror = () => {
            video.pause();
            video.hidden = true;
            img.hidden = false;
            img.src = fallbackImgSrc;
          };
          const playPromise = video.play();
          if(playPromise && typeof playPromise.catch === 'function'){
            playPromise.catch(() => {});
          }
        }
      }else{
        if(video){
          video.pause();
          video.hidden = true;
          video.removeAttribute('src');
          video.removeAttribute('poster');
          delete video.dataset.src;
          video.load();
        }
        img.hidden = false;
        img.src = fallbackImgSrc;
      }
      img.onerror = () => {
        img.src = makePlaceholder('#334155');
      };
      img.alt = entry.title || 'dot work';
      titleEl.textContent = entry.title || '無題';
      renderAuthor(authorEl, entry);
      likesEl.textContent = `${entry.likeCount || 0}`;
      const isLiked = likedEntries.has(entry.id);
      likeIcon.src = isLiked ? FAV_SRC : NFAV_SRC;
      const canDelete = (entry.user_id && supabaseUser?.id === entry.user_id) || (!entry.user_id && entry.client_id === clientId);
      if(delBtn){
        delBtn.style.display = canDelete ? 'inline-block' : 'none';
        delBtn.disabled = !canDelete;
      }
      if(playBtn){
        const puzzleRef = resolvePixfindPuzzleId(entry.prompt || '');
        const isPixfindEntry = entry.mode === 'pixfind' && Boolean(puzzleRef);
        const playUrl = isPixfindEntry ? buildPixfindUrl(puzzleRef) : null;
        if(playUrl){
          playBtn.classList.remove('is-disabled');
          playBtn.setAttribute('aria-disabled','false');
          playBtn.href = playUrl;
        }else{
          playBtn.classList.add('is-disabled');
          playBtn.setAttribute('aria-disabled','true');
          playBtn.removeAttribute('href');
        }
      }
      if(downloadBtn){
        const allowDownload = isDownloadAllowed(entry.allow_download);
        downloadBtn.disabled = !allowDownload;
        downloadBtn.classList.toggle('is-disabled', !allowDownload);
      }
      if(shareBtn){
        const canShare = entryLoaded;
        shareBtn.disabled = !canShare;
        shareBtn.classList.toggle('is-disabled', !canShare);
      }
      editTags = parseTags(entry.tags);
      renderTagView(editTags);
      renderTagEditor();
      renderDownloadEditor();
      setTagStatus('');
      setDownloadStatus('');
      setDeleteNotice(canDelete ? '' : '※この端末から投稿した作品のみ削除できます');
    }

    async function likeEntry(){
      if(!entry) return;
      if(isSupabaseMaintenance()){
        setStatus('メンテナンス中のためいいねできません');
        return;
      }
      ensureClientId();
      const already = likedEntries.has(entry.id);
      if(already){
        likedEntries.delete(entry.id);
        entry.likeCount = Math.max(0, (entry.likeCount || 0) - 1);
      }else{
        likedEntries.add(entry.id);
        entry.likeCount = (entry.likeCount || 0) + 1;
      }
      render();
      try{
        if(!already){
          const payload = { entry_id: entry.id };
          if(supabaseUser?.id){
            payload.user_id = supabaseUser.id;
          }
          payload.client_id = clientId;
          await supabaseInsert('contest_likes', payload);
        }
      }catch(err){
        console.error(err);
        markSupabaseMaintenanceFromError(err);
      }
    }

    async function deleteEntry(){
      if(!entry){
        setDeleteNotice('作品が読み込まれていません');
        return;
      }
      const canDelete = (entry.user_id && supabaseUser?.id === entry.user_id) || (!entry.user_id && entry.client_id === clientId);
      if(!canDelete){
        setDeleteNotice('この作品はこの端末から削除できません');
        return;
      }
      if(!confirm('この作品を削除しますか？')){
        return;
      }
      setStatus('削除しています...');
      try{
        const eq = { id: entry.id };
        if(entry.user_id && supabaseUser?.id === entry.user_id){
          eq.user_id = supabaseUser.id;
        }else if(entry.client_id){
          eq.client_id = entry.client_id;
        }
        await supabaseDelete('contest_entries', { eq });
        setStatus('削除しました');
        setDeleteNotice('');
        location.replace('./index.html');
      }catch(err){
        console.error(err);
        setStatus('削除に失敗しました');
      }
    }

    async function fetchEntry(id){
      setStatus('読み込み中...');
      entryLoaded = false;
      entry = {
        id,
        name: 'サンプル',
        title: 'サンプル作品',
        width: 512,
        height: 512,
        colors: 256,
        image_base64: makePlaceholder(SAMPLE_COLORS[id % SAMPLE_COLORS.length]),
        submitted_at: new Date().toISOString(),
        likeCount: 0,
        mode: 'free',
        client_id: null,
        user_id: null,
        tags: ''
      };
      render();
      let loaded = false;
      try{
        const res = await supabaseSelect('contest_entries', { eq: { id }, limit: 1, select: getEntrySelect() });
        if(res.length){
          entry = { ...res[0], likeCount: entry.likeCount || 0 };
          loaded = true;
          setStatus('');
        }else{
          setStatus('ネットワークエラーまたは作品が見つかりません');
        }
      }catch(err){
        console.error(err);
        if(supportsXUrl && isMissingColumn(err, 'x_url')){
          supportsXUrl = false;
          await fetchEntry(id);
          return;
        }
        if(supportsImageUrls && (isMissingColumn(err, 'image_url') || isMissingColumn(err, 'thumb_url'))){
          supportsImageUrls = false;
          await fetchEntry(id);
          return;
        }
        if(supportsVideoColumns && (isMissingColumn(err, 'video_url') || isMissingColumn(err, 'video_mime'))){
          supportsVideoColumns = false;
          await fetchEntry(id);
          return;
        }
        if(isSupabaseMaintenance()){
          setStatus('メンテナンス中のため作品を読み込めません');
        }else{
          setStatus('ネットワークエラーが発生しています');
        }
      }
      render();
      entryLoaded = loaded;
      if(loaded){
        fetchEntryLikes(id);
      }
    }

    async function fetchEntryLikes(id){
      try{
        const likeRes = await supabaseSelect('contest_likes', { eq: { entry_id: id }, select: LIKE_SELECT });
        if(!entry || entry.id !== id) return;
        entry.likeCount = likeRes.length;
        likeRes.forEach(l => {
          if((supabaseUser?.id && l.user_id === supabaseUser.id) || l.client_id === clientId) likedEntries.add(id);
        });
        render();
      }catch(err){
        console.error(err);
      }
    }

    function scheduleRelatedFetch(id){
      if(!id) return;
      if(typeof requestIdleCallback === 'function'){
        requestIdleCallback(() => fetchRelated(id), { timeout: 1200 });
      }else{
        setTimeout(() => fetchRelated(id), 200);
      }
    }

    function renderRelated(entries){
      const wrap = document.getElementById('relatedGallery');
      if(!wrap) return;
      if(!entries.length){
        wrap.innerHTML = '<p class="empty">このユーザーの作品はまだありません。</p>';
        return;
      }
      wrap.innerHTML = '';
      const placeholderSrc = makePlaceholder('#334155');
      entries.forEach((e, idx) => {
        const item = document.createElement('a');
        item.className = 'entry-card';
        item.href = `view.html?id=${e.id}`;
        item.innerHTML = `
          <div class="entry-imgwrap">
            <img src="${resolveEntryImage(e, { preferThumb: true })}" alt="${e.title}" draggable="false" loading="lazy" decoding="async">
          </div>
        `;
        wrap.appendChild(item);
        if((idx + 1) % 9 === 0){
          wrap.appendChild(createRelatedAdCard());
        }
      });
      wrap.querySelectorAll('.entry-imgwrap img').forEach(img => {
        img.addEventListener('error', () => {
          img.src = placeholderSrc;
        });
      });
      try{
        if(window.pixieedObserveAds){
          window.pixieedObserveAds();
        }
      }catch(e){
        console.warn('ads render skipped', e);
      }
    }

    async function fetchRelated(currentId, { append = false } = {}){
      if(relatedLoading) return;
      relatedLoading = true;
      updateRelatedLoadMore();
      if(!append){
        cachedEntries = [];
        relatedOffset = 0;
      }
      try{
        const filter = getRelatedFilter();
        if(!filter || !filter.value){
          cachedEntries = [];
          relatedHasMore = false;
          renderRelated([]);
          relatedLoading = false;
          updateRelatedLoadMore();
          return;
        }
        const requestSize = RELATED_FETCH_LIMIT + 1;
        const batch = await supabaseSelect('contest_entries', {
          order: 'submitted_at.desc',
          limit: requestSize,
          select: getRelatedSelect(),
          offset: relatedOffset,
          eq: { [filter.key]: filter.value }
        });
        relatedOffset += batch.length;
        let filtered = batch.filter(e => e.id !== currentId);
        relatedHasMore = batch.length > RELATED_FETCH_LIMIT;
        if(filtered.length > RELATED_FETCH_LIMIT){
          filtered = filtered.slice(0, RELATED_FETCH_LIMIT);
          relatedHasMore = true;
        }
        const missingIds = supportsImageUrls
          ? filtered.filter(e => !e.thumb_url && !e.image_url).map(e => e.id)
          : [];
        if(missingIds.length){
          const legacy = await supabaseSelect('contest_entries', { select: 'id,image_base64', in: { id: missingIds } });
          const legacyMap = new Map(legacy.map(row => [row.id, row.image_base64]));
          filtered = filtered.map(e => (
            legacyMap.has(e.id) ? { ...e, image_base64: legacyMap.get(e.id) } : e
          ));
        }
        cachedEntries = append ? cachedEntries.concat(filtered) : filtered;
      }catch(err){
        console.error(err);
        if(supportsImageUrls && (isMissingColumn(err, 'image_url') || isMissingColumn(err, 'thumb_url'))){
          supportsImageUrls = false;
          relatedLoading = false;
          updateRelatedLoadMore();
          await fetchRelated(currentId, { append });
          return;
        }
        if(supportsVideoColumns && (isMissingColumn(err, 'video_url') || isMissingColumn(err, 'video_mime'))){
          supportsVideoColumns = false;
          relatedLoading = false;
          updateRelatedLoadMore();
          await fetchRelated(currentId, { append });
          return;
        }
      }
      renderRelated(cachedEntries);
      relatedLoading = false;
      updateRelatedLoadMore();
    }

    function escapeHtml(str){
      return str.replace(/[&<>"']/g, s => (
        { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s] || s
      ));
    }

    function isStorageExistsError(error){
      const status = Number(error?.status || error?.statusCode || 0);
      if(status === 409) return true;
      const msg = String(error?.message || '').toLowerCase();
      return msg.includes('exists');
    }

    function truncateText(ctx, text, maxWidth){
      let output = String(text ?? '');
      if(!output) return '';
      if(ctx.measureText(output).width <= maxWidth) return output;
      while(output.length > 1 && ctx.measureText(`${output}…`).width > maxWidth){
        output = output.slice(0, -1);
      }
      return output.length > 1 ? `${output}…` : output;
    }

    function loadImageFromSource(src){
      return new Promise((resolve, reject) => {
        if(!src){
          reject(new Error('source missing'));
          return;
        }
        const img = new Image();
        try{
          const resolved = new URL(src, window.location.href);
          const isSameOrigin = resolved.origin === window.location.origin;
          const isHttp = resolved.protocol === 'http:' || resolved.protocol === 'https:';
          if(!isSameOrigin && isHttp){
            img.crossOrigin = 'anonymous';
          }
          img.src = resolved.toString();
        }catch(_){
          img.src = src;
        }
        img.onload = () => resolve(img);
        img.onerror = error => reject(error);
      });
    }

    function canvasToBlob(canvas, type = 'image/png'){
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if(blob) resolve(blob);
          else reject(new Error('blob create failed'));
        }, type);
      });
    }

    function getContestPublicUrl(path){
      if(!supabaseAuth?.storage) return '';
      return supabaseAuth.storage.from(STORAGE_BUCKET).getPublicUrl(path).data.publicUrl;
    }

    function buildShareHtml({ title, description, imageUrl, shareUrl, targetUrl }){
      const safeTitle = escapeHtml(title);
      const safeDescription = escapeHtml(description);
      const safeImage = escapeHtml(imageUrl);
      const safeShareUrl = escapeHtml(shareUrl);
      const safeTargetUrl = escapeHtml(targetUrl);
      return `<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>${safeTitle}</title>
  <meta name="description" content="${safeDescription}"/>
  <meta property="og:type" content="website"/>
  <meta property="og:title" content="${safeTitle}"/>
  <meta property="og:description" content="${safeDescription}"/>
  <meta property="og:image" content="${safeImage}"/>
  <meta property="og:image:width" content="${CONTEST_SHARE_OGP_WIDTH}"/>
  <meta property="og:image:height" content="${CONTEST_SHARE_OGP_HEIGHT}"/>
  <meta property="og:url" content="${safeShareUrl}"/>
  <meta property="og:site_name" content="PiXiEED"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:title" content="${safeTitle}"/>
  <meta name="twitter:description" content="${safeDescription}"/>
  <meta name="twitter:image" content="${safeImage}"/>
  <meta http-equiv="refresh" content="0; url=${safeTargetUrl}"/>
  <link rel="canonical" href="${safeTargetUrl}"/>
  <style>body{margin:0;font-family:sans-serif;background:#0f172a;color:#e2e8f0;display:flex;align-items:center;justify-content:center;min-height:100vh}</style>
</head>
<body>
  <p>Redirecting...</p>
  <script>window.location.replace('${safeTargetUrl}');<\/script>
<script defer src="/scripts/pwa-install.js"></script>
</body>
</html>`;
    }

    function drawContainImage(ctx, image, x, y, width, height){
      if(!ctx || !image) return;
      const iw = image.naturalWidth || image.width || 1;
      const ih = image.naturalHeight || image.height || 1;
      const scale = Math.min(width / iw, height / ih);
      const dw = Math.max(1, Math.round(iw * scale));
      const dh = Math.max(1, Math.round(ih * scale));
      const dx = Math.round(x + (width - dw) / 2);
      const dy = Math.round(y + (height - dh) / 2);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(image, dx, dy, dw, dh);
    }

    async function createContestOgpBlob({ title, image }){
      if(!image) return null;
      const canvas = document.createElement('canvas');
      canvas.width = CONTEST_SHARE_OGP_WIDTH;
      canvas.height = CONTEST_SHARE_OGP_HEIGHT;
      const ctx = canvas.getContext('2d');
      if(!ctx) return null;

      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#0f172a');
      gradient.addColorStop(1, '#1e293b');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#f8fafc';
      ctx.font = `600 ${CONTEST_SHARE_TITLE_SIZE}px 'DotGothic16', sans-serif`;
      ctx.textBaseline = 'top';
      const maxTitleWidth = canvas.width - CONTEST_SHARE_PADDING * 2;
      const titleText = truncateText(ctx, title || '作品', maxTitleWidth);
      ctx.fillText(titleText, CONTEST_SHARE_PADDING, CONTEST_SHARE_PADDING);

      const top = CONTEST_SHARE_PADDING + CONTEST_SHARE_TITLE_SIZE + 20;
      const availableHeight = canvas.height - top - CONTEST_SHARE_PADDING;
      const availableWidth = canvas.width - CONTEST_SHARE_PADDING * 2;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 2;
      ctx.fillRect(CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      ctx.strokeRect(CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      drawContainImage(ctx, image, CONTEST_SHARE_PADDING, top, availableWidth, availableHeight);
      return await canvasToBlob(canvas, 'image/png');
    }

    async function uploadContestShareAssets({ entryId, title, image }){
      if(!supabaseAuth?.storage || !supportsStorageUploads || !entryId || !image) return null;
      const ogpBlob = await createContestOgpBlob({ title, image });
      if(!ogpBlob) return null;
      const ogpPath = `share/${entryId}.png`;
      const sharePath = `share/${entryId}.html`;
      const ogpUrl = getContestPublicUrl(ogpPath);
      const shareUrl = getContestPublicUrl(sharePath);
      const targetUrl = `${CONTEST_SHARE_BASE_URL}?id=${entryId}`;
      const html = buildShareHtml({
        title: `PiXiEED | ${title || '作品'}`,
        description: 'PiXiEEDのドット作品',
        imageUrl: ogpUrl,
        shareUrl,
        targetUrl,
      });
      const htmlBlob = new Blob([html], { type: 'text/html; charset=utf-8' });
      try{
        const bucket = supabaseAuth.storage.from(STORAGE_BUCKET);
        const { error: ogpError } = await bucket.upload(ogpPath, ogpBlob, {
          contentType: 'image/png',
          cacheControl: '31536000',
          upsert: false
        });
        if(ogpError){
          if(isStorageExistsError(ogpError)){
            if(typeof bucket.update === 'function'){
              const { error: ogpUpdateError } = await bucket.update(ogpPath, ogpBlob, {
                contentType: 'image/png',
                cacheControl: '31536000'
              });
              if(ogpUpdateError){
                console.warn('share ogp overwrite failed', ogpUpdateError);
              }
            }
          }else{
            throw ogpError;
          }
        }
        const { error: htmlError } = await bucket.upload(sharePath, htmlBlob, {
          contentType: 'text/html; charset=utf-8',
          cacheControl: '3600',
          upsert: false
        });
        if(htmlError){
          if(isStorageExistsError(htmlError)){
            if(typeof bucket.update === 'function'){
              const { error: htmlUpdateError } = await bucket.update(sharePath, htmlBlob, {
                contentType: 'text/html; charset=utf-8',
                cacheControl: '3600'
              });
              if(htmlUpdateError){
                console.warn('share html overwrite failed', htmlUpdateError);
              }
            }
          }else{
            throw htmlError;
          }
        }
        return { shareUrl, ogpUrl };
      }catch(err){
        console.warn('share upload failed', err);
        markSupabaseMaintenanceFromError(err);
        const msg = String(err?.message || '').toLowerCase();
        if(msg.includes('bucket') || msg.includes('storage') || msg.includes('not found')){
          supportsStorageUploads = false;
        }
        return null;
      }
    }

    async function handleShare(){
      if(!entry || !entryLoaded){
        setStatus('作品が読み込まれていません');
        return;
      }
      const shareBtn = $('shareButton');
      if(shareBtn){
        shareBtn.disabled = true;
        shareBtn.classList.add('is-disabled');
      }
      const shareUrl = `${CONTEST_SHARE_BASE_URL}?id=${entry.id}`;
      const shareMessage = `${shareUrl}\n${SHARE_HASHTAG}`;
      try{
        if(navigator.clipboard?.writeText){
          await navigator.clipboard.writeText(shareMessage);
          setStatus('共有リンクをコピーしました');
        }else{
          window.prompt('共有リンクをコピーしてください。', shareMessage);
          setStatus('共有リンクをコピーしてください');
        }
      }catch(err){
        console.error(err);
        setStatus('共有リンクの作成に失敗しました');
      }finally{
        if(shareBtn){
          const canShare = entryLoaded;
          shareBtn.disabled = !canShare;
          shareBtn.classList.toggle('is-disabled', !canShare);
        }
      }
    }

    function makePlaceholder(color){
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512"><rect width="512" height="512" fill="${color}"/></svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    function supabaseHeaders(){
      const token = supabaseSession?.access_token || SUPABASE_ANON_KEY;
      return {
        'Content-Type':'application/json',
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${token}`,
        'x-client-id': clientId || ''
      };
    }

    async function supabaseSelect(table, { eq = {}, order, limit, offset, select = '*', in: inFilter = {} } = {}){
      const params = new URLSearchParams();
      params.set('select', select);
      Object.entries(eq).forEach(([k,v]) => params.set(k, `eq.${v}`));
      Object.entries(inFilter).forEach(([k,v]) => {
        if(!Array.isArray(v) || v.length === 0) return;
        const values = v.map((item) => {
          if(typeof item === 'number') return String(item);
          const raw = String(item).replace(/"/g, '\\"');
          return `"${raw}"`;
        });
        params.set(k, `in.(${values.join(',')})`);
      });
      if(order){
        const [col, dir] = order.split('.');
        params.set('order', col);
        if(dir === 'desc'){
          params.set('order', `${col}.desc`);
        }
      }
      if(limit){
        params.set('limit', String(limit));
      }
      if(offset){
        params.set('offset', String(offset));
      }
      let res;
      try{
        res = await fetch(`${SUPABASE_REST}/${table}?${params.toString()}`, {
          headers: supabaseHeaders()
        });
      }catch(err){
        markSupabaseMaintenanceFromError(err);
        throw err;
      }
      if(!res.ok){
        const detail = await res.text();
        markSupabaseMaintenanceFromError(null, res.status);
        throw new Error(`supabase select failed: ${res.status} ${detail}`);
      }
      noteSupabaseSuccess();
      return res.json();
    }

    async function supabaseInsert(table, payload){
      let res;
      try{
        res = await fetch(`${SUPABASE_REST}/${table}`, {
          method:'POST',
          headers: supabaseHeaders(),
          body: JSON.stringify(payload)
        });
      }catch(err){
        markSupabaseMaintenanceFromError(err);
        throw err;
      }
      if(!res.ok){
        markSupabaseMaintenanceFromError(null, res.status);
        throw new Error(`supabase insert failed: ${res.status}`);
      }
      noteSupabaseSuccess();
      return res.json();
    }

    async function supabaseDelete(table, { eq = {} } = {}){
      const params = new URLSearchParams();
      Object.entries(eq).forEach(([k,v]) => params.set(k, `eq.${v}`));
      let res;
      try{
        res = await fetch(`${SUPABASE_REST}/${table}?${params.toString()}`, {
          method:'DELETE',
          headers: supabaseHeaders()
        });
      }catch(err){
        markSupabaseMaintenanceFromError(err);
        throw err;
      }
      if(!res.ok){
        markSupabaseMaintenanceFromError(null, res.status);
        throw new Error(`supabase delete failed: ${res.status}`);
      }
      noteSupabaseSuccess();
      return res.json();
    }

    async function supabaseUpdate(table, payload, { eq = {} } = {}){
      const params = new URLSearchParams();
      Object.entries(eq).forEach(([k,v]) => params.set(k, `eq.${v}`));
      let res;
      try{
        res = await fetch(`${SUPABASE_REST}/${table}?${params.toString()}`, {
          method:'PATCH',
          headers: { ...supabaseHeaders(), Prefer: 'return=representation' },
          body: JSON.stringify(payload)
        });
      }catch(err){
        markSupabaseMaintenanceFromError(err);
        throw err;
      }
      if(!res.ok){
        markSupabaseMaintenanceFromError(null, res.status);
        throw new Error(`supabase update failed: ${res.status}`);
      }
      noteSupabaseSuccess();
      return res.json();
    }

    function setActiveNav(){
      const tab = 'contest';
      document.querySelectorAll('.bottom-nav__item').forEach(item => {
        const isMatch = item.dataset.tab === tab;
        item.classList.toggle('is-active', isMatch);
      });
    }

    async function init(){
      ensureClientId();
      if(supabaseMaintenance){
        setSupabaseMaintenance(true, 'cached');
      }
      setupAuthButton();
      setupAvatarToggle();
      setupTagEditor();
      setupDownloadEditor();
      await initSupabaseAuth();
      document.addEventListener('contextmenu', (e) => {
        if(e.target && e.target.tagName === 'IMG'){
          e.preventDefault();
        }
      });
      document.addEventListener('dragstart', (e) => {
        if(e.target && e.target.tagName === 'IMG'){
          e.preventDefault();
        }
      });
      const params = new URLSearchParams(location.search);
      currentEntryId = Number(params.get('id')) || 0;
      await fetchEntry(currentEntryId);
      scheduleRelatedFetch(currentEntryId);
      render();
      applyAvatarToBrand();
      renderAvatarChoices();
      setActiveNav();
      const likeBtn = $('heroLike');
      if(likeBtn){
        likeBtn.addEventListener('click', likeEntry);
      }
      const delBtn = $('deleteEntry');
      if(delBtn){
        delBtn.addEventListener('click', deleteEntry);
      }
      const downloadBtn = $('downloadButton');
      if(downloadBtn){
        downloadBtn.addEventListener('click', handleDownload);
      }
      const shareBtn = $('shareButton');
      if(shareBtn){
        shareBtn.addEventListener('click', handleShare);
      }
      const relatedLoadMoreBtn = $('relatedLoadMoreBtn');
      if(relatedLoadMoreBtn){
        relatedLoadMoreBtn.addEventListener('click', () => {
          fetchRelated(currentEntryId, { append: true });
        });
      }
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
