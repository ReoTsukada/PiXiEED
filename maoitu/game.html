<!DOCTYPE html>

<html lang="ja">
<head>
<meta content="https://pixieed.jp/maoitu/ogp.png" property="og:image"/>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<meta content="まおいつ" name="apple-mobile-web-app-title"/>
<title>魔王様！！いつまでよければいいですか！？</title>
<meta content="#000000" name="theme-color"/>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet"/>

<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-SZPVXMX85G"></script>
<script>
const GA_MEASUREMENT_ID = 'G-SZPVXMX85G';
const GA_ADDITIONAL_IDS = ['G-LLSD5KLJVN'];
const GA_PAGE_PATH = '/maoitu/game';
const PROJECT_SLUG = 'maoitu';
const PROJECT_NAME = '魔王様!!いつまでよければいいですか!?';
const PROJECT_TYPE = 'game';
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', GA_MEASUREMENT_ID, {
  page_path: GA_PAGE_PATH,
  page_title: document.title
});
GA_ADDITIONAL_IDS.forEach(id => {
  gtag('config', id, {
    page_path: GA_PAGE_PATH,
    page_title: document.title
  });
});
gtag('event', 'project_open', {
  project_slug: PROJECT_SLUG,
  project_type: PROJECT_TYPE,
  project_name: PROJECT_NAME
});
gtag('event', 'project_open_maoitu');
</script>
<!-- Google AdSense -->
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9801602250480253"></script>
<style>
  :root{
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  html,body{
    margin:0;
    background:#000;
    height:100%;
    overflow:hidden;
    min-height:100svh;
    touch-action:none;
    overscroll-behavior:none;
  }
  *{
    -webkit-user-select:none;
    user-select:none;
  }
  body{
    position:relative;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    min-height:var(--vvh, 100svh);
    font-family:'Press Start 2P','Noto Sans JP',system-ui,sans-serif;
    /* 上部の重なりを最小限にしてキャンバスをさらに上寄せ */
    padding-top:clamp(0px, 1vh, 12px);
    padding-bottom:calc(90px + var(--safe-bottom)); /* 固定広告ぶんの余白を下に確保しつつ余裕を持たせる */
  }
  .ad-header{
    width:100%;
    max-width:640px;
    padding:calc(8px + var(--safe-top)) 0 8px;
    box-sizing:border-box;
    display:flex;
    justify-content:center;
    background:#fff;
    border-bottom:1px solid rgba(0,0,0,0.08);
  }
  .ad-header ins{
    display:block;
    width:320px;
    max-width:320px;
    height:50px;
    overflow:hidden;
  }
  .game-area{
    position:relative;
    flex:1 1 auto;
    width:100%;
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:0;
    box-sizing:border-box;
    /* さらに余白を絞ってキャンバスを上へ */
    padding:clamp(0px, 3vh, 24px) 0;
  }
  #c{display:block;touch-action:none;image-rendering:pixelated}
  .back-link{
    position:absolute;
    top:calc(var(--safe-top) + 10px);
    left:18px;
    padding:8px 14px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.35);
    background:rgba(0,0,0,0.65);
    color:#fff;
    font:600 13px/1.2 system-ui;
    text-decoration:none;
    display:none;
    z-index:40;
    transition:background 0.2s ease,color 0.2s ease,transform 0.2s ease;
  }
  .back-link:hover,
  .back-link:focus-visible{
    background:#fff;
    color:#000;
    transform:translateY(-1px);
    outline:none;
  }
  #gameOverUi{
    position:fixed;
    inset:0;
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    padding:calc(var(--safe-top) + 20px) 16px calc(var(--safe-bottom) + 20px);
    gap:18px;
    z-index:20;
    box-sizing:border-box;
    max-height:100%;
    overflow:hidden;
  }
  #gameOverPanel{
    width:min(90vw, 336px);
    padding:14px 16px;
    background:rgba(0,0,0,0.85);
    border:1px solid rgba(255,255,255,0.25);
    border-radius:12px;
    color:#fff;
    text-align:center;
    font-family:sans-serif;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:8px;
    transition:box-shadow 0.2s ease,border-color 0.2s ease,background 0.2s ease;
  }
  #gameOverPanel.is-clear{
    background:linear-gradient(160deg, rgba(22,163,74,0.25), rgba(0,0,0,0.8));
    border-color:rgba(74,222,128,0.7);
    box-shadow:0 0 18px rgba(74,222,128,0.45);
  }
  .gameover-title{
    font-size:16px;
    font-weight:700;
    letter-spacing:0.06em;
  }
  .gameover-title.is-clear{ color:#4ade80; text-shadow:0 0 6px rgba(74,222,128,0.5); }
  .clear-badge{
    display:none;
    font:800 14px/1.2 system-ui;
    color:#bbf7d0;
    background:rgba(34,197,94,0.18);
    border:1px solid rgba(34,197,94,0.55);
    border-radius:999px;
    padding:6px 10px;
    margin:0 auto;
    text-transform:uppercase;
    letter-spacing:0.08em;
    box-shadow:0 0 10px rgba(34,197,94,0.35);
  }
  .rank-percent-label{
    font:600 13px/1.5 system-ui;
    color:#e5e7eb;
    margin-top:4px;
  }
  #sharePanel{
    display:none;
    flex-direction:column;
    gap:10px;
    padding:12px 16px;
    text-align:center;
    background:rgba(0,0,0,0.8);
    border:1px solid rgba(255,255,255,0.25);
    border-radius:12px;
    color:#fff;
    font-family:sans-serif;
    font-size:12px;
    align-items:stretch;
    width:min(90vw, 336px);
    box-sizing:border-box;
  }
  #sharePanel button,
  #sharePanel .share-link{
    font:700 12px system-ui;
    padding:10px 16px;
    border:0;
    border-radius:10px;
    cursor:pointer;
    width:100%;
    box-sizing:border-box;
    display:flex;
    align-items:center;
    justify-content:center;
    line-height:1;
  }
  #sharePanel .share-link{
    text-decoration:none;
    background:rgba(255,255,255,0.2);
    color:#fff;
  }
  #shareScoreLabel{font-size:16px;font-weight:700;text-align:center;}
  #footer{
    position:absolute;
    bottom:calc(var(--safe-bottom) + 12px);
    right:14px;
    color:rgba(255,255,255,0.6);
    font:10px/1.2 monospace;
    user-select:none;
    pointer-events:none;
  }
  .ad-footer{
    position:fixed;
    left:0;
    right:0;
    bottom:0;
    width:100%;
    max-width:640px;
    margin:0 auto;
    padding:6px 0 calc(10px + var(--safe-bottom, 0px));
    box-sizing:border-box;
    display:flex;
    justify-content:center;
    background:#000;
    border-top:1px solid rgba(255,255,255,0.08);
    z-index:30;
  }
  .ad-footer ins{
    display:block;
    width:320px;
    max-width:320px;
    height:40px;
    overflow:hidden;
  }
</style>
<link rel="icon" type="image/png" sizes="192x192" href="../icon/icon-192-3.png"/>
<link rel="icon" type="image/png" sizes="512x512" href="../icon/icon-512-3.png"/>
<style id="ads-safe">
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .adsbygoogle,
    ins.adsbygoogle {
      display: block !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box;
      overflow: hidden;
    }
    .adsbygoogle iframe,
    ins.adsbygoogle iframe {
      display: block;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
  </style>
  <style id="interaction-guard">
    * {
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    input,
    textarea,
    [contenteditable] {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  <script id="interaction-guard-js">
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    document.addEventListener('dragstart', (event) => {
      event.preventDefault();
    });
  </script>
  <script id="ads-lazy">
    (function() {
      if (window.pixieedObserveAds) return;
      const pending = [];
      const hasObserverSupport = 'IntersectionObserver' in window;
      let observer = null;
      const isLoaded = (ins) => (
        ins.dataset.adsLazyLoaded === '1' ||
        ins.getAttribute('data-adsbygoogle-status') === 'done' ||
        ins.getAttribute('data-ad-status') === 'filled'
      );
      const loadAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyLoaded = '1';
        try {
          (window.adsbygoogle = window.adsbygoogle || []).push({});
        } catch (err) {
          ins.dataset.adsLazyLoaded = '';
        }
      };
      const observeAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (ins.dataset.adsLazyObserved === '1') return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyObserved = '1';
        if (!observer) {
          if (!hasObserverSupport) {
            loadAd(ins);
          } else {
            pending.push(ins);
          }
          return;
        }
        observer.observe(ins);
      };
      const observeAds = (root) => {
        const scope = root && root.querySelectorAll ? root : document;
        scope.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
      };
      window.pixieedObserveAds = observeAds;
      const setupObserver = () => {
        if (hasObserverSupport) {
          observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting || entry.intersectionRatio > 0) {
                const target = entry.target;
                if (observer) observer.unobserve(target);
                loadAd(target);
              }
            });
          }, { rootMargin: '200px 0px', threshold: 0.01 });
        }
        const queued = pending.splice(0);
        queued.forEach((ins) => {
          if (observer) {
            observer.observe(ins);
          } else {
            loadAd(ins);
          }
        });
        observeAds(document);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
      const mo = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (!(node instanceof HTMLElement)) return;
            if (node.matches && node.matches('ins.adsbygoogle')) {
              observeAd(node);
              return;
            }
            if (node.querySelectorAll) {
              node.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
            }
          });
        });
      });
      const startObserver = () => {
        if (!document.body) return;
        mo.observe(document.body, { childList: true, subtree: true });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startObserver);
      } else {
        startObserver();
      }
    })();
  </script>
</head>
<body>
<div class="game-area">
  <audio autoplay="" hidden="" id="bgm" loop="" src="bgm.mp3" volume="0.5"></audio>
  <canvas id="c"></canvas>
  <div id="gameOverUi">
  <div id="gameOverPanel">
  <div class="gameover-title" id="gameoverTitle">GAME OVER</div>
  <div class="clear-badge" id="clearBadge">GAME CLEAR!</div>
  <div id="shareScoreLabel">SCORE: 0</div>
  <div class="rank-percent-label" id="rankPercentLabel"></div>
  </div>
<div id="sharePanel">
  <button id="shareActionBtn" style="background:#22c55e;color:#000;">シェアする</button>
  <button id="restartActionBtn" style="background:#3b82f6;color:#fff;">もう一度遊ぶ</button>
  <a class="share-link" href="../tools.html">他のゲームで遊ぶ</a>
  <button id="backToStartBtn" style="background:rgba(255,255,255,0.2);color:#fff;">スタート画面に戻る</button>
  <button id="nextDifficultyBtn" style="background:#f97316;color:#fff;display:none;">次の難易度へ</button>
</div>
</div>
</div>
<div class="ad-footer">
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9801602250480253"
     data-ad-slot="2141591954"></ins>
</div>
<div id="footer">© 2025 アルタ</div>
<script>
// 広告レンダリング
if (window.pixieedObserveAds) {
  window.pixieedObserveAds();
}
// Prevent pinch-zoom on iOS to keep the layout stable.
['gesturestart', 'gesturechange', 'gestureend'].forEach((eventName) => {
  document.addEventListener(eventName, (event) => {
    event.preventDefault();
  }, { passive: false });
});

document.addEventListener('touchmove', (event) => {
  if(event.touches.length > 1){
    event.preventDefault();
  }
}, { passive: false });

const bgm = document.getElementById('bgm');
bgm.volume = 0.5;
const AUDIO_KEY = 'maoitu_audio';
const GAME_CANONICAL_URL = `${window.location.origin}/maoitu/`;
let submitScoreAuto = null;
let fetchRankInfo = null;
let scoreSubmitted = false;
let currentRankRequestId = 0;
import('./assets/js/ranking-submit.js').then(mod => {
  submitScoreAuto = mod.submitScoreAuto;
  fetchRankInfo = mod.fetchRankInfo;
}).catch(() => {
  // ignore
});
function lsGet(key){
  try{
    return localStorage.getItem(key);
  }catch(_){
    return null;
  }
}
function lsSet(key, value){
  try{
    localStorage.setItem(key, value);
  }catch(_){
    // 無視（プライベートモードなどで弾かれるケース）
  }
}
function setViewportHeight(){
  if(window.visualViewport){
    document.documentElement.style.setProperty('--vvh', `${window.visualViewport.height}px`);
  }else{
    document.documentElement.style.setProperty('--vvh', `${window.innerHeight}px`);
  }
}
setViewportHeight();
window.addEventListener('resize', setViewportHeight);
window.addEventListener('orientationchange', setViewportHeight);
function syncAudioSetting(){
  const enabled = lsGet(AUDIO_KEY) !== 'off';
  bgm.muted = !enabled;
  if(!enabled && !bgm.paused) bgm.pause();
  return enabled;
}
let audioEnabled = syncAudioSetting();
const gameOverUi = document.getElementById('gameOverUi');
const sharePanel = document.getElementById('sharePanel');
const gameOverTitle = document.getElementById('gameoverTitle');
const shareScoreLabel = document.getElementById('shareScoreLabel');
const rankPercentLabel = document.getElementById('rankPercentLabel');
const shareActionBtn = document.getElementById('shareActionBtn');
const restartActionBtn = document.getElementById('restartActionBtn');
const backToStartBtn = document.getElementById('backToStartBtn');
const nextDifficultyBtn = document.getElementById('nextDifficultyBtn');
const backLink = document.getElementById('backLink');
const gameOverPanel = document.getElementById('gameOverPanel');
const clearBadge = document.getElementById('clearBadge');
let shareScore = 0;
let runCleared = false;

window.addEventListener('pixieed:score-queued', () => {
  if(rankPercentLabel){
    rankPercentLabel.textContent = 'メンテ中のためキューに保存しました';
  }
});

const HUD_FONT = '12px "Press Start 2P", monospace';
const HUD_FONT_SMALL = '9px "Press Start 2P", monospace';

function logPlayEvent(eventName, params={}){
  if(typeof window.gtag === 'function' && GA_MEASUREMENT_ID){
    window.gtag('event', eventName, params);
  }
}

function logPlayStart(){
  logPlayEvent('play_started');
}

function shareText(score){
  return `開発者:@PiXiEED_arta\n『魔王様！！いつまでよければいいですか！？』\nスコア: ${score}\n皆もやってみてね！！！\n\nリンクから遊べるよ！！#PiXiEED\n\n${GAME_CANONICAL_URL}`;
}

async function copyShareText(text){
  try{
    await navigator.clipboard.writeText(text);
    alert('シェア用テキストをコピーしました！');
  }catch(err){
    alert('シェア機能が利用できません。手動でスコアを共有してください。');
  }
}

shareActionBtn.addEventListener('click', async () => {
  const text = shareText(shareScore);
  copyShareText(text);
});

restartActionBtn.addEventListener('click', () => {
  hideSharePanel();
  reset();
});

if(backToStartBtn){
  backToStartBtn.addEventListener('click', () => {
    window.location.href = './index.html';
  });
}

if(nextDifficultyBtn){
  nextDifficultyBtn.addEventListener('click', () => {
    const params = new URLSearchParams(location.search);
    const current = params.get('mode') || readDifficulty();
    const next = nextDifficultyKey(current);
    params.set('mode', next);
    window.location.search = params.toString();
  });
}

function showBackLink(){
  if(!backLink) return;
  backLink.style.display = 'inline-flex';
}

function hideBackLink(){
  if(!backLink) return;
  backLink.style.display = 'none';
}

function showSharePanel(score){
  shareScore = score;
  shareScoreLabel.textContent = `SCORE: ${score}`;
  if(rankPercentLabel){
    rankPercentLabel.textContent = '';
  }
  if(gameOverTitle){
    gameOverTitle.textContent = runCleared ? 'GAME CLEAR!' : 'GAME OVER';
    gameOverTitle.classList.toggle('is-clear', runCleared);
  }
  if(gameOverPanel){
    gameOverPanel.classList.toggle('is-clear', runCleared);
  }
  if(clearBadge){
    clearBadge.style.display = runCleared ? 'inline-flex' : 'none';
  }
  if(nextDifficultyBtn){
    nextDifficultyBtn.style.display = runCleared ? 'block' : 'none';
  }
  gameOverUi.style.display = 'flex';
  sharePanel.style.display = 'flex';
  refreshRankLabel(score);
  if(typeof restartActionBtn.focus === 'function'){
    try{
      restartActionBtn.focus({ preventScroll: true });
    }catch(_){
      restartActionBtn.focus();
    }
  }
}

function hideSharePanel(){
  currentRankRequestId++;
  if(rankPercentLabel){
    rankPercentLabel.textContent = '';
  }
  sharePanel.style.display = 'none';
  gameOverUi.style.display = 'none';
}
hideSharePanel();
function isOnSharePanel(target){
  return gameOverUi.style.display !== 'none' && gameOverUi.contains(target);
}
function isOnInstructionUi(){
  return false;
}
// モバイル環境での自動再生対策
document.addEventListener('click', () => {
  audioEnabled = syncAudioSetting();
  if (audioEnabled && bgm.paused) {
    bgm.play().catch(()=>{});
  }
}, { once: true });
// ====== 画像（Base64） ======
// ====== 敵キャラ（解禁スケジュール付き） ======
const ENEMY_TYPES_DATA=[
  {name:"ジェリン",src:"./assets/sprites/jerin.png",speed:1.8,unlockSec:0},
  {name:"ポワリン",src:"./assets/sprites/powarin.png",speed:1.3,unlockSec:5},
  {name:"ブリン",src:"./assets/sprites/burin.png",speed:2.3,unlockSec:15},
  {name:"シャボリン",src:"./assets/sprites/shaborin.png",speed:0.5,unlockSec:25},
  {name:"プリズリン",src:"./assets/sprites/prizurin.png",speed:2.8,unlockSec:35},
  {name:"ヘドリン",src:"./assets/sprites/hedorin.png",speed:1.2,unlockSec:45,sticky:true},
  {name:"バブリン",src:"./assets/sprites/baburin.png",speed:1.0,unlockSec:65},
  {name:"ボムリン",src:"./assets/sprites/bomurin.png",speed:1.2,unlockSec:75,ignoreShield:true},
  {name:"デモリン",src:"./assets/sprites/demorin.png",speed:2.0,unlockSec:85,followPlayer:true,followStrength:0.2},
  {name:"ガオリン",src:"./assets/sprites/gaorin.png",speed:1.6,unlockSec:95,zigzag:true,hSpeed:1.3},
  {name:"グラビリン",src:"./assets/sprites/gurabirin.png",speed:2.0,unlockSec:105,sizeMult:1.5,gravity:true}
];
const PLAYER_SRC="./assets/sprites/player.png";
const ANGEL_SRC="./assets/sprites/jerin-angel.png";

// ====== 画像読み込み & アルファマップ ======
function withAlpha(src){
  const img=new Image(); img.src=src;
  const out={img,ready:false,alpha:null};
  img.onload=()=>{
    const oc=document.createElement('canvas'); oc.width=16; oc.height=16;
    const ctx=oc.getContext('2d'); ctx.drawImage(img,0,0,16,16);
    out.alpha=ctx.getImageData(0,0,16,16).data; out.ready=true;
  };
  return out;
}
const ENEMY_TYPES=ENEMY_TYPES_DATA.map(t=>({...t,skin:withAlpha(t.src)}));
const PLAYER=withAlpha(PLAYER_SRC);
const ANGEL=withAlpha(ANGEL_SRC);
const PLAYER_START_X = 86;
const PLAYER_START_Y = 232;
const PLAYER_START_TX = 96;

// ====== 基本設定 ======
let c=document.getElementById('c'),x=c.getContext('2d',{alpha:false}),W=192,H=288;
function createBackground(){
  const oc=document.createElement('canvas');
  oc.width=W; oc.height=H;
  const ctx=oc.getContext('2d');
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#0a0f2a');
  g.addColorStop(1,'#060912');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);
  return oc;
}
function createStarLayer(count=36,minR=0.2,maxR=1.6,alphaMin=0.05,alphaMax=0.4,heightRatio=0.8){
  const oc=document.createElement('canvas');
  oc.width=W; oc.height=H;
  const ctx=oc.getContext('2d');
  for(let i=0;i<count;i++){
    const r=Math.random()*(maxR-minR)+minR;
    const alpha=Math.random()*(alphaMax-alphaMin)+alphaMin;
    ctx.fillStyle=`rgba(255,255,255,${alpha})`;
    ctx.beginPath();
    ctx.arc(Math.random()*W,Math.random()*H*heightRatio,r,0,Math.PI*2);
    ctx.fill();
  }
  return oc;
}
const BG_LAYER=createBackground();
const STAR_LAYER=createStarLayer(); // 遠景
const STAR_LAYER_NEAR=createStarLayer(48,0.15,0.9,0.2,0.6,1); // 手前の細かい星
let starOffset=0;
let starOffsetNear=0;
const STAR_SCROLL_SPEED=0.25;
const STAR_SCROLL_SPEED_NEAR=0.55;
const HITSTOP_ON_SHIELD_FRAMES = 3;  // 短めにしてカクつきを抑制
const HITSTOP_ON_FATAL_FRAMES = 6;
const SHAKE_INTENSITY_SHIELD = 1.0;
const SHAKE_INTENSITY_FATAL = 1.4;
const SHIELD_FLASH_FRAMES = 14;
const FEVER_THRESHOLD_FRAMES = 900; // 約15秒
const FEVER_DURATION_FRAMES = 300; // 5秒
const FEVER_SPEED_SCALE = 2; // フィーバー中の敵スピード倍率
const FEVER_PLAYER_SPEED_MULT = 1.2;
const FEVER_SCORE_MULT = 2;
const FEVER_HIT_BONUS_FRAMES = 10; // フィーバー中に敵に触れたときの延命量（短め）
const FEVER_GAUGE_BOOST_ON_PICKUP = 120;
let P={x:PLAYER_START_X,y:PLAYER_START_Y,w:16,h:16,v:4,skin:PLAYER};
let E=[], angels=[], o=0, tx=PLAYER_START_TX, S=0, alive=true, shieldCharges=0;
let scoreCarry = 0;
let hitstopFrames=0;
let shieldFlashFrames=0;
let shakeFrames=0;
let shakeIntensity=0;
let feverGauge=0;
let feverFrames=0;

// ====== 表示フィット ======
const DPR_CAP = 1.25; // 高DPI端末での描画負荷を抑える上限（下げて負荷軽減）
function fit(){
  const d=Math.min(devicePixelRatio||1, DPR_CAP);
  const ar=H/W;
  const safeBottom = (() => {
    const v = getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom');
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : 0;
  })();
  const footerReserved = 80 + safeBottom; // 広告+余白ぶん確保
  const availableHeight = Math.max(120, innerHeight - footerReserved);
  const maxHeight = availableHeight * 0.98;
  const maxWidthFromHeight = maxHeight / ar;
  const maxWidth = innerWidth * 0.98;
  const w=Math.min(maxWidth, maxWidthFromHeight)|0;
  const h=(w*ar)|0;
  c.style.width=w+'px'; c.style.height=h+'px';
  c.width=(w*d)|0; c.height=(h*d)|0;
  x.setTransform((w*d)/W,0,0,(h*d)/H,0,0);
  x.imageSmoothingEnabled=false;
}
addEventListener('resize', fit); fit();

// ====== 生成 ======
function rnd(a,b){return Math.random()*(b-a)+a}
function createEnemyFromType(type, spawnX){
  const sizeMult = type.sizeMult || 1;
  const w = 16 * sizeMult;
  const h = 16 * sizeMult;
  const clampedX = Math.max(0, Math.min(W - w, spawnX));
  return {
    x: clampedX,
    y: -18,
    w,
    h,
    v: type.speed,
    vx: type.zigzag ? ((Math.random() < 0.5 ? -1 : 1) * (type.hSpeed || 0)) : 0,
    baseSpeed: type.speed,
    name: type.name || '',
    sticky: Boolean(type.sticky),
    clearOnShieldHit: Boolean(type.clearOnShieldHit),
    ignoreShield: Boolean(type.ignoreShield),
    followPlayer: Boolean(type.followPlayer),
    followStrength: type.followStrength || 0,
    zigzag: Boolean(type.zigzag),
    gravity: Boolean(type.gravity),
    absorbed: 0,
    skin: type.skin
  };
}
function spawnEnemy(){
  const elapsedSec = elapsedFrames / 60;
  const candidates = ENEMY_TYPES.filter(t=>elapsedSec >= t.unlockSec);
  const type = candidates[(Math.random()*candidates.length)|0];
  const sizeMult = type.sizeMult || 1;
  const w = 16 * sizeMult;
  E.push(createEnemyFromType(type, rnd(0, W - w)));
}
function spawnAngel(){
  angels.push({x:rnd(0,W-16),y:-18,w:16,h:16,v:1.4,skin:ANGEL});
}

// ====== Angelin 出現頻度（10秒ごと判定 + 30秒保証） ======
const ANGEL_BASE_INTERVAL = 600; // 約10秒ごと
const ANGEL_SPAWN_PROB    = 0.10;
const ANGEL_GUARANTEE_INTERVAL_SEC = 30;
let lastAngelGuaranteeSec = 0;

// ====== グラビリン重力設定 ======
const GRAVITY_RADIUS = 64;
const GRAVITY_PULL_PLAYER = 0.03;
const GRAVITY_PULL_ENEMY = 0.02;
let gravityTestSpawned = false;

// ====== 難易度プリセット ======
const DIFFICULTY_PRESETS = {
  easy:   { key:'easy',   label:'簡単',     initialSpawnIntervalFrames:36, minSpawnIntervalFrames:20, maxEnemiesPerSpawn:3, startShieldCharges:1, maxDifficultyLevel:10 },
  normal: { key:'normal', label:'普通',     initialSpawnIntervalFrames:26, minSpawnIntervalFrames:14, maxEnemiesPerSpawn:4, startShieldCharges:0, maxDifficultyLevel:10 },
  endless:{ key:'endless',label:'エンドレス', initialSpawnIntervalFrames:20, minSpawnIntervalFrames:8,  maxEnemiesPerSpawn:6, startShieldCharges:0, maxDifficultyLevel:Infinity }
};
const DIFFICULTY_STORAGE_KEY = 'maoitu_difficulty';

// ====== 難易度スケーリング（時間ベース） ======
const SPAWN_INTERVAL_DECREASE = 1;
const SLOW_DECREASE_THRESHOLD_FRAMES = 15;

let initialSpawnIntervalFrames = DIFFICULTY_PRESETS.endless.initialSpawnIntervalFrames;
let minSpawnIntervalFrames = DIFFICULTY_PRESETS.endless.minSpawnIntervalFrames;
let maxEnemiesPerSpawn = DIFFICULTY_PRESETS.endless.maxEnemiesPerSpawn;
let startShieldCharges = DIFFICULTY_PRESETS.endless.startShieldCharges;
let maxDifficultyLevel = DIFFICULTY_PRESETS.endless.maxDifficultyLevel;
let enemySpawnIntervalFrames = initialSpawnIntervalFrames;
let enemiesPerSpawn = 1;
let difficultyLevel = 1;
const DIFFICULTY_STEP_SEC = 10;
let lastDifficultyUpdateSec = 0;
let elapsedFrames = 0;
const ENEMY_GRACE_FRAMES = 60;
let slowDecreaseToggle = false;
let difficultyLabel = DIFFICULTY_PRESETS.endless.label;

const heroShieldIcon = new Image();
heroShieldIcon.src = './assets/kago.png';

function readDifficulty(){
  const params = new URLSearchParams(location.search);
  const q = params.get('mode');
  const stored = lsGet(DIFFICULTY_STORAGE_KEY);
  if(q && DIFFICULTY_PRESETS[q]) return q;
  if(stored && DIFFICULTY_PRESETS[stored]) return stored;
  return 'endless';
}

function applyDifficultyPreset(key){
  const preset = DIFFICULTY_PRESETS[key] || DIFFICULTY_PRESETS.endless;
  initialSpawnIntervalFrames = preset.initialSpawnIntervalFrames;
  minSpawnIntervalFrames = preset.minSpawnIntervalFrames;
  maxEnemiesPerSpawn = preset.maxEnemiesPerSpawn;
  startShieldCharges = preset.startShieldCharges || 0;
  maxDifficultyLevel = preset.maxDifficultyLevel || Infinity;
  difficultyLabel = preset.label;
  lsSet(DIFFICULTY_STORAGE_KEY, preset.key);
}

function nextDifficultyKey(current){
  if(current === 'easy') return 'normal';
  if(current === 'normal') return 'endless';
  return 'endless';
}

const difficultyKey = readDifficulty();
applyDifficultyPreset(difficultyKey);

function triggerHitstop(frames=8, intensity=2){
  hitstopFrames = Math.max(hitstopFrames, frames);
  shakeFrames = Math.max(shakeFrames, frames + 4);
  shakeIntensity = Math.max(shakeIntensity, intensity);
}

function startFever(){
  feverFrames = FEVER_DURATION_FRAMES;
  feverGauge = 0;
  triggerHitstop(4, 1.2);
}

// ====== 楕円ベースのゆるい当たり判定 ======
function hitBox(a, b){
  function ellipse(o, fx=0.8, fy=0.6){
    const rx = o.w * fx / 2;
    const ry = o.h * fy / 2;
    return {
      cx: o.x + o.w / 2,
      cy: o.y + o.h / 2,
      rx,
      ry
    };
  }
  const ea = ellipse(a, 0.8, 0.6);
  const eb = ellipse(b, 0.8, 0.6);
  const dx = ea.cx - eb.cx;
  const dy = ea.cy - eb.cy;
  const rx = ea.rx + eb.rx;
  const ry = ea.ry + eb.ry;
  if(rx === 0 || ry === 0) return false;
  return (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1;
}

function rectsOverlap(a, b){
  return !(
    a.x + a.w < b.x ||
    b.x + b.w < a.x ||
    a.y + a.h < b.y ||
    b.y + b.h < a.y
  );
}

// ====== 入力 ======
function pos(e){const r=c.getBoundingClientRect();return (e.clientX-r.left)/r.width*W}
document.onpointerdown = e => {
  if(isOnSharePanel(e.target)) return;
  if(isOnInstructionUi(e.target)) return;
  if(e.cancelable) e.preventDefault();
  if(!alive) return;
  tx = pos(e) - P.w/2;
};
document.onpointermove = e => {
  if(isOnSharePanel(e.target)) return;
  if(isOnInstructionUi(e.target)) return;
  if(e.cancelable) e.preventDefault();
  if(!alive) return;
  tx = pos(e) - P.w/2;
};
addEventListener('keydown',e=>{ if(!alive) return; if(e.key==='ArrowLeft')tx-=20; else if(e.key==='ArrowRight')tx+=20; });

function reset(countPlay = true){ alive=true; E.length=0; angels.length=0; o=0; S=0; scoreCarry=0; shieldCharges=startShieldCharges||0; P.x=PLAYER_START_X; P.y=PLAYER_START_Y; tx=PLAYER_START_TX; P.skin=PLAYER;
  hitstopFrames = 0;
  shieldFlashFrames = 0;
  shakeFrames = 0;
  shakeIntensity = 0;
  feverGauge = 0;
  feverFrames = 0;
  gravityTestSpawned = false;
  enemySpawnIntervalFrames = initialSpawnIntervalFrames;
  enemiesPerSpawn = 1;
  lastDifficultyUpdateSec = 0;
  elapsedFrames = 0;
  difficultyLevel = 1;
  slowDecreaseToggle = false;
  starOffset = 0;
  starOffsetNear = 0;
  lastAngelGuaranteeSec = 0;
  runCleared = false;
  scoreSubmitted = false;
  hideSharePanel();
  hideBackLink();
  if(countPlay) logPlayStart();
}

async function refreshRankLabel(score){
  if(!rankPercentLabel) return;
  if(!fetchRankInfo){
    rankPercentLabel.textContent = '';
    return;
  }
  const requestId = ++currentRankRequestId;
  rankPercentLabel.textContent = '順位計算中...';
  try{
    const { total, rank, percentile } = await fetchRankInfo(score);
    if(requestId !== currentRankRequestId) return;
    if(!total){
      rankPercentLabel.textContent = 'まだスコアがありません';
      return;
    }
    if(rank <= 100){
      rankPercentLabel.textContent = `現在の順位: ${rank}位`;
    }else{
      const rounded = Math.max(1, Math.round(percentile * 10) / 10);
      rankPercentLabel.textContent = `上位 ${rounded}%`;
    }
  }catch(_){
    if(requestId === currentRankRequestId){
      rankPercentLabel.textContent = '';
    }
  }
}

function finalizeScore(score){
  if (submitScoreAuto && !scoreSubmitted) {
    scoreSubmitted = true;
    submitScoreAuto(score);
  }
}

function endRun(){
  if(!alive) return;
  alive = false;
  showBackLink();
  logPlayEvent('game_over', { score: S });
  finalizeScore(S);
}

function clearRun(){
  if(!alive) return;
  alive = false;
  runCleared = true;
  showBackLink();
  logPlayEvent('game_clear', { score: S, difficulty: difficultyLabel });
   // クリア時もパネルを即表示
  showSharePanel(S);
  finalizeScore(S);
}

// ====== 1フレーム ======
function step(){
  if(hitstopFrames > 0){
    hitstopFrames--;
    return;
  }
  const enemySpawnEnabled = elapsedFrames >= ENEMY_GRACE_FRAMES;
  if(enemySpawnEnabled && o % enemySpawnIntervalFrames === 0){
    for(let i=0;i<enemiesPerSpawn;i++) spawnEnemy();
  }
  if(o % ANGEL_BASE_INTERVAL === 0 && Math.random() < ANGEL_SPAWN_PROB) spawnAngel();
  o++;
  elapsedFrames++;
  const currentSec = elapsedFrames / 60;
  if(currentSec - lastAngelGuaranteeSec >= ANGEL_GUARANTEE_INTERVAL_SEC){
    spawnAngel();
    lastAngelGuaranteeSec = currentSec;
  }

  const speedScale = feverFrames > 0 ? FEVER_SPEED_SCALE : 1;
  const playerSpeed = feverFrames > 0 ? P.v * FEVER_PLAYER_SPEED_MULT : P.v;

  E.forEach(e=>{
    if (e.gravity) {
      const radius = GRAVITY_RADIUS;
      const gx = e.x + e.w * 0.5;
      const gy = e.y + e.h * 0.5;
      // 重力オーラ描画
      const auraPulse = 0.45 + 0.25 * Math.sin(elapsedFrames * 0.3);
      const grad = x.createRadialGradient(gx, gy, radius * 0.25, gx, gy, radius);
      grad.addColorStop(0, `rgba(255, 102, 102, ${auraPulse})`);
      grad.addColorStop(0.55, `rgba(210, 50, 50, ${auraPulse * 0.55})`);
      grad.addColorStop(1, 'rgba(120, 20, 20, 0)');
      x.save();
      x.fillStyle = grad;
      x.beginPath();
      x.arc(gx, gy, radius, 0, Math.PI * 2);
      x.fill();
      x.restore();
      // プレイヤーを吸引
      const pdx = P.x + P.w * 0.5 - gx;
      const pdy = P.y + P.h * 0.5 - gy;
      const pd2 = pdx * pdx + pdy * pdy;
      if (pd2 > 0 && pd2 < radius * radius) {
        const pull = GRAVITY_PULL_PLAYER * speedScale;
        P.x -= pdx * pull;
        P.y -= pdy * pull * 0.6;
        P.x = Math.max(0, Math.min(W - P.w, P.x));
        P.y = Math.max(0, Math.min(H - P.h, P.y));
      }
      // 他の敵を吸引
      for (let k = 0; k < E.length; k++) {
        const other = E[k];
        if (other === e) continue;
        const odx = other.x + other.w * 0.5 - gx;
        const ody = other.y + other.h * 0.5 - gy;
        const od2 = odx * odx + ody * ody;
        if (od2 === 0 || od2 > radius * radius) continue;
        const pullE = GRAVITY_PULL_ENEMY * speedScale;
        other.x -= odx * pullE;
        other.y -= ody * pullE * 0.7;
        other.x = Math.max(0, Math.min(W - other.w, other.x));
        other.y = Math.max(-20, Math.min(H, other.y));
      }
    }
    if (e.followPlayer) {
      const dx = (P.x - e.x);
      const step = Math.sign(dx) * Math.min(Math.abs(dx), e.followStrength * speedScale);
      e.x += step;
      e.x = Math.max(0, Math.min(W - e.w, e.x));
    }
    if (e.zigzag && e.vx){
      e.x += e.vx * speedScale;
      if (e.x <= 0){
        e.x = 0;
        e.vx = Math.abs(e.vx);
      }else if (e.x + e.w >= W){
        e.x = W - e.w;
        e.vx = -Math.abs(e.vx);
      }
    }
    e.y+=e.v * speedScale;
  });
  angels.forEach(a=>a.y+=a.v);

  const dx=tx-P.x; P.x+=Math.sign(dx)*Math.min(Math.abs(dx),playerSpeed);
  P.x=Math.max(0,Math.min(W-P.w,P.x));

  angels = angels.filter(a=>{
    if(hitBox(P,a)){
      shieldCharges += 1;
      P.skin = ANGEL;
      shieldFlashFrames = SHIELD_FLASH_FRAMES;
      feverGauge = Math.min(FEVER_THRESHOLD_FRAMES, feverGauge + FEVER_GAUGE_BOOST_ON_PICKUP);
      return false;
    }
    return a.y<H+20;
  });

  for (let i = 0; i < E.length; i++) {
    const stickyEnemy = E[i];
    if (!stickyEnemy.sticky) continue;
    for (let j = E.length - 1; j >= 0; j--) {
      if (i === j) continue;
      const target = E[j];
      if (!rectsOverlap(stickyEnemy, target)) continue;
      stickyEnemy.v += target.v * 0.2;
      const newW = stickyEnemy.w * 1.05;
      const newH = stickyEnemy.h * 1.05;
      const deltaW = newW - stickyEnemy.w;
      const deltaH = newH - stickyEnemy.h;
      stickyEnemy.x -= deltaW / 2;
      stickyEnemy.y -= deltaH / 2;
      stickyEnemy.w = newW;
      stickyEnemy.h = newH;
      stickyEnemy.x = Math.max(0, Math.min(W - stickyEnemy.w, stickyEnemy.x));
      stickyEnemy.y = Math.max(-40, Math.min(H, stickyEnemy.y));
      stickyEnemy.absorbed = (stickyEnemy.absorbed || 0) + 1;
      E.splice(j, 1);
      if (j < i) {
        i--;
      }
    }
  }

  for(const e of E){
    if(hitBox(P,e)){
      if (e.ignoreShield) {
        triggerHitstop(HITSTOP_ON_FATAL_FRAMES, SHAKE_INTENSITY_FATAL);
        endRun();
        break;
      }
      if (feverFrames > 0){
        feverFrames = Math.min(FEVER_DURATION_FRAMES, feverFrames + FEVER_HIT_BONUS_FRAMES);
        e.y = H + 99; // 無敵中は敵を消す
        continue;
      }
      if(shieldCharges > 0){
        triggerHitstop(HITSTOP_ON_SHIELD_FRAMES, SHAKE_INTENSITY_SHIELD);
        shieldFlashFrames = SHIELD_FLASH_FRAMES;
        if (e.clearOnShieldHit) {
          shieldCharges = 0; // シールドを全消費
          P.skin = PLAYER;
        } else {
          shieldCharges -= 1;
          if (shieldCharges <= 0){
            shieldCharges = 0;
            P.skin = PLAYER;
          }
        }
        e.y=H+99;
      }else{
        triggerHitstop(HITSTOP_ON_FATAL_FRAMES, SHAKE_INTENSITY_FATAL);
        endRun();
        break;
      }
    }
  }
  E=E.filter(e=>e.y<H+20);
  if(feverFrames > 0){
    feverFrames--;
  }else{
    feverGauge = Math.min(FEVER_THRESHOLD_FRAMES, feverGauge + 1);
    if(feverGauge >= FEVER_THRESHOLD_FRAMES){
      startFever();
    }
  }
  const scoreGain = feverFrames > 0 ? FEVER_SCORE_MULT : 1;
  scoreCarry += scoreGain;
  const scoreAdd = Math.floor(scoreCarry);
  if(scoreAdd > 0){
    S += scoreAdd;
    scoreCarry -= scoreAdd;
  }
  starOffset = (starOffset + STAR_SCROLL_SPEED * speedScale);
  starOffsetNear = (starOffsetNear + STAR_SCROLL_SPEED_NEAR * speedScale);

  if(!alive && sharePanel.style.display==='none'){
    showSharePanel(S);
  }

  const elapsedSec = elapsedFrames / 60;
  if(elapsedSec - lastDifficultyUpdateSec >= DIFFICULTY_STEP_SEC){
    lastDifficultyUpdateSec += DIFFICULTY_STEP_SEC;
    difficultyLevel++;
    if(enemySpawnIntervalFrames > minSpawnIntervalFrames){
      if(enemySpawnIntervalFrames > SLOW_DECREASE_THRESHOLD_FRAMES){
        enemySpawnIntervalFrames = Math.max(SLOW_DECREASE_THRESHOLD_FRAMES, enemySpawnIntervalFrames - SPAWN_INTERVAL_DECREASE);
        if(enemySpawnIntervalFrames <= SLOW_DECREASE_THRESHOLD_FRAMES){
          slowDecreaseToggle = false; // 閾値以下に入った最初のステップは一度スキップする
        }
      }else{
        if(slowDecreaseToggle){
          enemySpawnIntervalFrames = Math.max(minSpawnIntervalFrames, enemySpawnIntervalFrames - SPAWN_INTERVAL_DECREASE);
        }
        slowDecreaseToggle = !slowDecreaseToggle;
      }
    }else{
      enemiesPerSpawn = Math.min(enemiesPerSpawn + 1, maxEnemiesPerSpawn);
    }
    if(difficultyLevel >= maxDifficultyLevel){
      difficultyLevel = maxDifficultyLevel;
      clearRun();
      return;
    }
  }
}
// ====== 描画 ======
function draw(){
  x.save();
  if(shakeFrames > 0){
    const shakePower = (shakeFrames / (shakeFrames + 6)) * shakeIntensity;
    const dx = (Math.random() * 2 - 1) * shakePower;
    const dy = (Math.random() * 2 - 1) * shakePower;
    x.translate(dx, dy);
    shakeFrames--;
  }
  x.drawImage(BG_LAYER,0,0,W,H);
  const offset = starOffset % H;
  x.drawImage(STAR_LAYER,0,offset - H,W,H);
  x.drawImage(STAR_LAYER,0,offset,W,H);
  const offsetNear = starOffsetNear % H;
  x.drawImage(STAR_LAYER_NEAR,0,offsetNear - H,W,H);
  x.drawImage(STAR_LAYER_NEAR,0,offsetNear,W,H);
  if(feverFrames > 0){
    const pulse = 0.08 + 0.06 * Math.sin(elapsedFrames * 0.3);
    x.fillStyle = `rgba(255,200,90,${0.12 + pulse})`;
    x.fillRect(0,0,W,H);
  }
  E.forEach(e=>{
    if(e.gravity){
      const radius = GRAVITY_RADIUS;
      const gx = e.x + e.w * 0.5;
      const gy = e.y + e.h * 0.5;
      const auraPulse = 0.6 + 0.15 * Math.sin(elapsedFrames * 0.3);
      const grad = x.createRadialGradient(gx, gy, radius * 0.35, gx, gy, radius);
      grad.addColorStop(0, `rgba(255, 120, 120, ${auraPulse})`);
      grad.addColorStop(0.7, 'rgba(230, 60, 60, 0.12)');
      grad.addColorStop(1, 'rgba(150, 20, 20, 0)');
      x.save();
      x.fillStyle = grad;
      x.beginPath();
      x.arc(gx, gy, radius, 0, Math.PI * 2);
      x.fill();
      x.restore();
    }
    if(e.ignoreShield){
      const pulse = ((Math.sin(elapsedFrames * 0.25) + 1) * 0.3) + 0.3; // 0.3〜0.9
      const cx = e.x + e.w * 0.5;
      const cy = e.y + e.h * 0.5;
      const radius = Math.max(e.w, e.h) * 0.5 + 6;
      const grad = x.createRadialGradient(cx, cy, radius * 0.25, cx, cy, radius);
      grad.addColorStop(0, `rgba(255,70,70,${pulse})`);
      grad.addColorStop(1, 'rgba(255,70,70,0)');
      x.fillStyle = grad;
      x.beginPath();
      x.arc(cx, cy, radius, 0, Math.PI * 2);
      x.fill();
    }
    if(e.skin.img.complete){
      x.drawImage(e.skin.img,e.x,e.y,e.w,e.h);
    }else{
      x.fillStyle='#f33'; x.fillRect(e.x,e.y,e.w,e.h);
    }
  });
  angels.forEach(a=>{
    const pulse = ((Math.sin(elapsedFrames * 0.2) + 1) * 0.25) + 0.35; // 0.35〜0.85
    const cx = a.x + a.w * 0.5;
    const cy = a.y + a.h * 0.5;
    const radius = Math.max(a.w, a.h) * 0.5 + 6;
    const grad = x.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
    grad.addColorStop(0, `rgba(16,255,180,${pulse})`);
    grad.addColorStop(1, 'rgba(16,255,180,0)');
    x.fillStyle = grad;
    x.beginPath();
    x.arc(cx, cy, radius, 0, Math.PI * 2);
    x.fill();
    if(a.skin.img.complete){
      x.drawImage(a.skin.img,a.x,a.y,a.w,a.h);
    }else{
      x.fillStyle='#fff'; x.fillRect(a.x,a.y,a.w,a.h);
    }
  });
  if(P.skin.img.complete) x.drawImage(P.skin.img,P.x,P.y,P.w,P.h); else { x.fillStyle='#0ff'; x.fillRect(P.x,P.y,P.w,P.h); }
  if(shieldFlashFrames > 0){
    const t = shieldFlashFrames / SHIELD_FLASH_FRAMES;
    const cx = P.x + P.w * 0.5;
    const cy = P.y + P.h * 0.5;
    const radius = 32 + (1 - t) * 10;
    const grad = x.createRadialGradient(cx, cy, P.w * 0.4, cx, cy, radius);
    grad.addColorStop(0, `rgba(200,255,255,${0.45 * t})`);
    grad.addColorStop(1, 'rgba(200,255,255,0)');
    x.fillStyle = grad;
    x.beginPath();
    x.arc(cx, cy, radius, 0, Math.PI*2);
    x.fill();
    shieldFlashFrames--;
  }

  x.fillStyle='#fff';
  x.font=HUD_FONT;
  x.fillText('S:'+S,4,16);
  x.font=HUD_FONT_SMALL;
  const iconSize = 12;
  const iconBaseX = 4;
  const iconBaseY = 24;
  const iconSpacing = iconSize + 2;
  if (heroShieldIcon && heroShieldIcon.complete) {
    if (shieldCharges <= 4) {
      if (shieldCharges === 0) {
        x.save();
        x.globalAlpha = 0.35;
        x.drawImage(heroShieldIcon, iconBaseX, iconBaseY, iconSize, iconSize);
        x.restore();
      } else {
        for (let i = 0; i < shieldCharges; i++) {
          x.drawImage(heroShieldIcon, iconBaseX + iconSpacing * i, iconBaseY, iconSize, iconSize);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        x.drawImage(heroShieldIcon, iconBaseX + iconSpacing * i, iconBaseY, iconSize, iconSize);
      }
      x.fillText('×' + shieldCharges, iconBaseX + iconSpacing * 4 + 2, iconBaseY + iconSize - 2);
    }
  } else {
    x.fillText(shieldCharges ? ('×' + shieldCharges) : '', iconBaseX, iconBaseY + iconSize);
  }
  const feverRatio = feverFrames > 0
    ? Math.max(0, feverFrames / FEVER_DURATION_FRAMES)
    : feverGauge / FEVER_THRESHOLD_FRAMES;
  const barW = 86;
  const barH = 6;
  const barX = W - barW - 6;
  const barY = iconBaseY + 10;
  x.fillStyle = 'rgba(255,255,255,0.18)';
  x.fillRect(barX, barY, barW, barH);
  x.fillStyle = feverFrames > 0 ? 'rgba(250,204,21,0.95)' : 'rgba(125,211,252,0.95)';
  x.fillRect(barX, barY, barW * feverRatio, barH);
  x.fillStyle = '#fff';
  x.fillText(feverFrames > 0 ? 'FEVER x2' : 'FEVER', barX, barY - 2);
  x.fillText('難易度: '+difficultyLevel,4,iconBaseY + 24);
  x.save();
  x.textAlign = 'right';
  x.fillText('モード: '+difficultyLabel,W-4,12);
  x.restore();

  if(!alive){
    // キャンバス上ではパネルを描かず、HTML側のUIに委ねる
  }
  x.restore();
}

// ====== ループ（固定タイムステップ 60Hz） ======
const FIXED_DT_MS = 1000/60;
let last = performance.now();
let acc  = 0;

function loop(now){
  let dt = now - last;
  last = now;
  if (dt > 1000) dt = 1000;
  acc += dt;

  const MAX_STEPS = 5;
  let steps = 0;
  while (acc >= FIXED_DT_MS && steps < MAX_STEPS){
    if (alive) step();
    acc -= FIXED_DT_MS;
    steps++;
  }

  draw();
  requestAnimationFrame(loop);
}
reset();
requestAnimationFrame(loop);

</script>
</body>
</html>
