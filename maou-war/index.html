<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
<meta name="theme-color" content="#0b1224"/>
<title>魔王奪還戦 | PiXiEED</title>
<meta name="description" content="タイルを進んで成長し、勇者の拠点を奪い返すグリッド戦略RPG。"/>
<link rel="canonical" href="https://pixieed.jp/maou-war/"/>
<meta property="og:type" content="website"/>
<meta property="og:title" content="魔王奪還戦 | PiXiEED"/>
<meta property="og:description" content="タイルを進んで成長し、勇者の拠点を奪い返すグリッド戦略RPG。"/>
<meta property="og:image" content="https://pixieed.jp/PiXiEEDogp.png"/>
<meta property="og:url" content="https://pixieed.jp/maou-war/"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:site" content="@PiXiEED_arta"/>
<meta name="twitter:url" content="https://pixieed.jp/maou-war/"/>
<meta name="twitter:title" content="魔王奪還戦 | PiXiEED"/>
<meta name="twitter:description" content="タイルを進んで成長し、勇者の拠点を奪い返すグリッド戦略RPG。"/>
<meta name="twitter:image" content="https://pixieed.jp/PiXiEEDogp.png"/>
<link rel="icon" type="image/png" href="../character-dots/mao1.png"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Fredoka:wght@600&display=swap" rel="stylesheet"/>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SZPVXMX85G"></script>
<script>
  const GA_MEASUREMENT_ID = 'G-SZPVXMX85G';
  const GA_PAGE_PATH = '/maou-war/';
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', GA_MEASUREMENT_ID, {
    page_path: GA_PAGE_PATH,
    page_title: document.title
  });
  gtag('event', 'project_open', {
    project_slug: 'maou-war',
    project_type: 'game',
    project_name: '魔王奪還戦'
  });
</script>
<script async crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9801602250480253"></script>
<style>
  :root {
    color-scheme: dark;
    --bg: radial-gradient(circle at 20% 20%, rgba(59,130,246,0.2), rgba(15,23,42,1)),
          radial-gradient(circle at 80% 0%, rgba(236,72,153,0.18), rgba(15,23,42,1)),
          #0b1224;
    --panel: rgba(255,255,255,0.06);
    --panel-strong: rgba(255,255,255,0.12);
    --border: rgba(255,255,255,0.16);
    --text: #e5e7eb;
    --muted: #cbd5e1;
    --accent: #ff9f43;
    --accent-2: #ff719a;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    font-family: 'Fredoka','DotGothic16',system-ui,sans-serif;
  }
  * {
    box-sizing: border-box;
    user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
  }
  html, body {
    margin: 0;
    height: 100%;
    width: 100%;
    max-width: 100vw;
    overflow: hidden;
    background: var(--bg);
    color: var(--text);
    touch-action: none;
    overscroll-behavior: none;
  }
  @supports (height: 100dvh) {
    html, body {
      height: 100dvh;
    }
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: calc(10px + var(--safe-top)) calc(12px + var(--safe-right)) calc(72px + var(--safe-bottom)) calc(12px + var(--safe-left));
  }
  a { color: inherit; text-decoration: none; }
  .game-shell {
    width: min(1200px, 100%);
    height: 100%;
    min-height: 0;
    display: grid;
    grid-template-rows: minmax(0, 1fr) auto;
    gap: 10px;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    background: rgba(10,18,36,0.9);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 8px 12px;
    min-width: 0;
  }
  .brand {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 800;
    letter-spacing: 0.02em;
    min-width: 0;
  }
  .brand img {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    padding: 4px;
    background: rgba(255,255,255,0.12);
    image-rendering: pixelated;
  }
  .brand small {
    display: block;
    color: var(--muted);
    font-size: 12px;
    font-weight: 600;
  }
  .top-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .btn {
    appearance: none;
    border: 0;
    border-radius: 10px;
    padding: 8px 12px;
    font: 700 13px/1.2 'Fredoka', system-ui, sans-serif;
    cursor: pointer;
    color: #fff;
    background: linear-gradient(135deg, #ff719a, #ff9f43);
    box-shadow: 0 4px 0 #e35c82, 0 8px 16px rgba(255,113,154,0.35);
  }
  .btn.secondary {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.2);
    color: var(--text);
    box-shadow: none;
  }
  .main {
    display: grid;
    grid-template-columns: minmax(0, 1.1fr) minmax(240px, 0.9fr);
    gap: 12px;
    min-height: 0;
    height: 100%;
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
    display: grid;
    gap: 10px;
    min-height: 0;
  }
  .map-panel {
    display: grid;
    grid-template-rows: auto minmax(0, 1fr);
    gap: 8px;
  }
  .map-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    width: 100%;
  }
  .map-title h1 {
    margin: 0;
    font-size: 18px;
  }
  .hud {
    display: grid;
    gap: 8px;
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    padding: 8px;
  }
  .hud-bars {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 8px;
  }
  .hud-bar {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--muted);
  }
  .hud-meter {
    height: 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.14);
    overflow: hidden;
  }
  .hud-meter__fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #22c55e, #86efac);
  }
  .hud-meter--mp .hud-meter__fill {
    background: linear-gradient(90deg, #38bdf8, #a5f3fc);
  }
  .hud-meter--shield .hud-meter__fill {
    background: linear-gradient(90deg, #a78bfa, #c4b5fd);
  }
  .hud-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }
  .hud-row--stats {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 6px;
    align-items: stretch;
  }
  .hud-row--stats .hud-chip {
    width: 100%;
    min-width: 0;
    justify-content: space-between;
  }
  .hud-row--bottom {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 6px;
    align-items: stretch;
  }
  .hud-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.35);
    font-size: 11px;
    color: var(--muted);
  }
  .hud-chip strong { color: #fff; font-size: 12px; }
  .hud-chip--coin {
    grid-column: 1 / span 3;
    justify-content: flex-start;
    width: 100%;
  }
  .hud-btn {
    margin-left: auto;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(0,0,0,0.5);
    color: #fff;
    font-size: 11px;
    cursor: pointer;
  }
  .hud-btn--status {
    grid-column: 4;
    margin-left: 0;
    width: 100%;
    min-height: 44px;
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 0.02em;
  }
  .map-frame {
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 6px;
    min-height: 0;
    min-width: 0;
    width: 100%;
    height: 100%;
    max-height: 100%;
    justify-self: stretch;
    align-self: stretch;
    max-width: 100%;
    overflow: hidden;
  }
  canvas {
    display: block;
    image-rendering: pixelated;
    max-width: 100%;
    max-height: 100%;
    cursor: pointer;
    touch-action: none;
  }
  .legend {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 6px;
    font-size: 12px;
    color: var(--muted);
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .legend-chip {
    width: 12px;
    height: 12px;
    border-radius: 4px;
    border: 1px solid rgba(255,255,255,0.2);
  }
  .status-panel h2 {
    margin: 0;
    font-size: 16px;
  }
  .stat-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }
  .stat {
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 10px;
    padding: 8px 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 12px;
  }
  .stat span { color: var(--muted); }
  .hud-icon {
    width: 14px;
    height: 14px;
    image-rendering: pixelated;
    vertical-align: -2px;
    margin-right: 4px;
  }
  .stat strong { font-size: 15px; }
  .status-log {
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 10px;
    padding: 8px;
    font-size: 12px;
    color: var(--muted);
    min-height: 120px;
    overflow: hidden;
  }
  .status-log p { margin: 0 0 6px; }
  .status-log p:last-child { margin-bottom: 0; }
  .footer-log {
    padding: 8px 10px;
    gap: 6px;
  }
  .footer-log__head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    flex-wrap: wrap;
  }
  .footer-log__title {
    font-size: 12px;
    color: var(--muted);
    letter-spacing: 0.08em;
  }
  .footer-log__actions {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  .footer-log .btn {
    padding: 6px 10px;
    font-size: 12px;
    box-shadow: 0 3px 0 #e35c82, 0 6px 12px rgba(255,113,154,0.25);
  }
  .footer-log .btn.secondary {
    box-shadow: none;
  }
  .footer-log .status-log {
    min-height: 0;
    height: clamp(96px, 14vh, 170px);
  }
  .ad-footer {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    width: min(720px, calc(100vw - env(safe-area-inset-left, 0px) - env(safe-area-inset-right, 0px) - 16px));
    margin: 0 auto;
    padding: 4px 0 calc(6px + var(--safe-bottom, 0px));
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    background: #000;
    border-top: 1px solid rgba(255,255,255,0.08);
    z-index: 30;
    min-height: clamp(48px, 9vw, 60px);
  }
  .ad-footer ins {
    display: block;
    width: 100%;
    max-width: 100%;
    min-height: clamp(48px, 9vw, 60px);
    overflow: hidden;
  }
  .adsbygoogle,
  ins.adsbygoogle {
    display: block !important;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
    margin: 0 auto;
    box-sizing: border-box;
    overflow: hidden;
  }
  .adsbygoogle iframe,
  ins.adsbygoogle iframe {
    display: block;
    width: 100% !important;
    max-width: 100% !important;
    min-width: 0 !important;
  }
  .sheet-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: flex-end;
    justify-content: center;
    background: rgba(6, 8, 16, 0.72);
    backdrop-filter: blur(6px);
    padding: calc(12px + var(--safe-top)) calc(12px + var(--safe-right)) calc(12px + var(--safe-bottom)) calc(12px + var(--safe-left));
    z-index: 65;
  }
  .sheet-overlay.is-open { display: flex; }
  .sheet {
    width: min(520px, 100%);
    height: min(70vh, 560px);
    max-height: min(70vh, 560px);
    background: rgba(12, 18, 40, 0.95);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 16px 16px 12px 12px;
    display: grid;
    grid-template-rows: auto 1fr;
    box-shadow: 0 20px 40px rgba(0,0,0,0.45);
    overflow: hidden;
  }
  .sheet-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.12);
  }
  .sheet-tabs {
    display: flex;
    gap: 6px;
  }
  .sheet-tab {
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.2);
    background: transparent;
    color: #cbd5e1;
    font-size: 12px;
    cursor: pointer;
  }
  .sheet-tab.is-active {
    background: linear-gradient(135deg, #ff719a, #ff9f43);
    color: #0b1224;
    border-color: transparent;
  }
  .sheet-close {
    margin-left: auto;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(0,0,0,0.45);
    color: #fff;
    font-size: 12px;
    cursor: pointer;
  }
  .sheet-body {
    padding: 12px;
    overflow: hidden auto;
    display: grid;
    gap: 12px;
  }
  .sheet-panel { display: none; }
  .sheet-panel.is-active { display: grid; gap: 10px; }
  .sheet-panel .status-log { min-height: 0; max-height: 220px; overflow: hidden auto; }
  .legend--sheet {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 8px;
  }
  .legend--sheet .legend-item {
    font-size: 12px;
  }
  .skill-panel {
    display: grid;
    gap: 10px;
  }
  .icon-grid {
    display: grid;
    grid-template-columns: repeat(6, minmax(0, 1fr));
    gap: 8px;
  }
  .icon-item {
    display: grid;
    place-items: center;
    padding: 0;
    appearance: none;
    -webkit-appearance: none;
    aspect-ratio: 1;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.18);
    background:
      linear-gradient(135deg, rgba(255,255,255,0.2), rgba(0,0,0,0.35)),
      var(--icon-color, rgba(255,255,255,0.08));
    cursor: pointer;
    position: relative;
  }
  .icon-item::after {
    content: '';
    position: absolute;
    inset: 6px;
    background: var(--icon-image) center / contain no-repeat;
    image-rendering: pixelated;
    pointer-events: none;
  }
  .icon-item.is-locked {
    opacity: 0.45;
  }
  .icon-item.is-unlocked {
    border-color: rgba(34,197,94,0.6);
    box-shadow: 0 0 0 1px rgba(34,197,94,0.35) inset;
  }
  .icon-item.is-selected {
    outline: 2px solid rgba(56,189,248,0.8);
    outline-offset: 2px;
  }
  .skill-detail {
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.35);
    padding: 10px;
    display: grid;
    gap: 6px;
    font-size: 12px;
    color: var(--muted);
  }
  .skill-detail strong {
    color: var(--text);
  }
  .skill-reqs {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .skill-req {
    padding: 4px 10px;
    border-radius: 999px;
    background: var(--req-color, rgba(255,255,255,0.08));
    color: #0b1224;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.02em;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
    opacity: 0.6;
  }
  .skill-req.is-met {
    opacity: 1;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25), 0 0 0 1px rgba(34,197,94,0.35);
  }
  .tag-progress {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 6px;
  }
  .tag-progress-item {
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.04);
    padding: 6px 8px;
    display: grid;
    gap: 2px;
  }
  .tag-progress-item strong {
    font-size: 11px;
    color: #dbeafe;
  }
  .tag-progress-item small {
    font-size: 11px;
    color: var(--muted);
  }
  .tag-progress-item.is-awakened {
    border-color: rgba(34,197,94,0.6);
    box-shadow: 0 0 0 1px rgba(34,197,94,0.3) inset;
  }
  .tag-progress-item.is-ready {
    border-color: rgba(250,204,21,0.65);
    box-shadow: 0 0 0 1px rgba(250,204,21,0.3) inset;
  }
  .skill-meta-line {
    font-size: 11px;
    color: #c7d2fe;
  }
  .battle-overlay,
  .result-overlay {
    position: fixed;
    inset: 0;
    background: rgba(6, 8, 16, 0.78);
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 16px;
    z-index: 60;
  }
  .battle-overlay.is-open,
  .result-overlay.is-open {
    display: flex;
  }
  .battle-panel,
  .result-panel {
    width: min(760px, 100%);
    background: rgba(12, 18, 40, 0.95);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 14px;
    padding: 16px;
    display: grid;
    gap: 12px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.4);
  }
  .battle-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }
  .battle-titles {
    display: flex;
    align-items: baseline;
    gap: 8px;
    min-width: 0;
  }
  .battle-header h2 { margin: 0; font-size: 18px; }
  .battle-skip {
    margin-left: auto;
    appearance: none;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    padding: 6px 10px;
    background: rgba(0,0,0,0.35);
    color: var(--text);
    font: 700 12px/1 'Fredoka', system-ui, sans-serif;
    cursor: pointer;
  }
  .battle-skip:disabled {
    opacity: 0.5;
    cursor: default;
  }
  .battle-actors {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
  }
  .actor {
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    padding: 10px;
    display: grid;
    gap: 8px;
    transition: transform 0.12s ease;
  }
  .actor.is-hit { transform: translateX(4px) translateY(-2px); }
  .actor-head {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 800;
  }
  .actor-icon {
    width: 42px;
    height: 42px;
    border-radius: 10px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
  }
  .hp-bar {
    height: 10px;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    overflow: hidden;
  }
  .hp-fill {
    height: 100%;
    background: linear-gradient(90deg, #22c55e, #86efac);
  }
  .mp-bar,
  .shield-bar {
    height: 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    overflow: hidden;
  }
  .mp-fill {
    height: 100%;
    background: linear-gradient(90deg, #38bdf8, #a5f3fc);
  }
  .shield-fill {
    height: 100%;
    background: linear-gradient(90deg, #a78bfa, #c4b5fd);
  }
  .battle-log {
    max-height: 180px;
    overflow: hidden;
    font-size: 12px;
    color: var(--muted);
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    padding: 10px;
  }
  .battle-log p { margin: 0 0 6px; }
  .battle-log p.is-player { color: #7dd3fc; }
  .battle-log p.is-enemy { color: #fca5a5; }
  .battle-log p:last-child { margin-bottom: 0; }
  .choice-overlay {
    position: fixed;
    inset: 0;
    background: rgba(6, 8, 16, 0.78);
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 16px;
    z-index: 70;
  }
  .choice-overlay.is-open { display: flex; }
  .choice-panel {
    width: min(680px, 100%);
    background: rgba(12, 18, 40, 0.95);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 14px;
    padding: 16px;
    display: grid;
    gap: 12px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.4);
  }
  .choice-sub { margin: 0; font-size: 12px; color: var(--muted); }
  .choice-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 10px;
  }
  .choice-card {
    appearance: none;
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 12px;
    padding: 10px;
    text-align: left;
    background: rgba(0,0,0,0.35);
    color: var(--text);
    display: grid;
    gap: 6px;
    cursor: pointer;
  }
  .choice-card:hover { border-color: rgba(56,189,248,0.6); }
  .choice-card strong { font-size: 13px; }
  .choice-card span { font-size: 11px; color: var(--muted); }
  .choice-card small { font-size: 10px; color: #bfdbfe; }
  .choice-icon {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background:
      linear-gradient(135deg, rgba(255,255,255,0.15), rgba(0,0,0,0.3)),
      var(--icon-color, rgba(255,255,255,0.08));
    display: grid;
    place-items: center;
  }
  .choice-icon::after {
    content: '';
    width: 20px;
    height: 20px;
    background: var(--icon-image) center / contain no-repeat;
    image-rendering: pixelated;
  }
  .choice-actions {
    display: flex;
    justify-content: flex-end;
  }
  .choice-actions .btn {
    background: rgba(0,0,0,0.4);
    box-shadow: none;
    border: 1px solid rgba(255,255,255,0.2);
    color: var(--text);
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .btn-coin {
    width: 14px;
    height: 14px;
    image-rendering: pixelated;
  }
  .result-title { margin: 0; font-size: 20px; }
  .result-stats { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
  .rank-list { list-style: none; padding: 0; margin: 0; display: grid; gap: 6px; }
  .rank-item { display: grid; grid-template-columns: 1fr auto; gap: 4px; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 10px; font-size: 12px; }
  .rank-item small { grid-column: 1 / -1; color: var(--muted); font-size: 11px; }
  .rank-status { margin: 6px 0 0; font-size: 12px; color: var(--muted); }
  .result-actions { display: flex; flex-wrap: wrap; gap: 8px; }
  .result-actions .btn { flex: 1 1 140px; }
  @media (max-width: 900px) {
    .main { grid-template-columns: 1fr; grid-template-rows: minmax(0, 1fr); }
    .map-panel { overflow: hidden; grid-template-rows: auto 1fr; }
    .map-frame { width: 100%; height: 100%; max-height: 100%; }
    .status-panel { display: none; }
    .sheet-overlay { padding: calc(10px + var(--safe-top)) calc(10px + var(--safe-right)) calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left)); }
    .legend { display: none; }
    .hud { gap: 6px; padding: 6px; }
    .hud-bars { grid-template-columns: 1fr; }
    .hud-row { gap: 4px; }
    .hud-row--stats, .hud-row--bottom { gap: 4px; }
    .hud-chip { font-size: 10px; padding: 3px 6px; }
    .hud-btn--status {
      min-height: 42px;
      font-size: 15px;
    }
    .top-bar { flex-direction: column; align-items: stretch; }
    .top-actions { width: 100%; justify-content: flex-end; }
    .footer-log .status-log { height: clamp(96px, 16vh, 180px); }
  }
  @media (max-width: 900px) and (orientation: portrait) {
    body {
      padding-top: calc(8px + var(--safe-top));
      padding-left: calc(8px + var(--safe-left));
      padding-right: calc(8px + var(--safe-right));
      padding-bottom: calc(70px + var(--safe-bottom));
    }
    .game-shell {
      gap: 8px;
    }
    .panel {
      padding: 8px;
      gap: 6px;
    }
    .map-panel {
      gap: 6px;
    }
    .hud {
      gap: 4px;
      padding: 4px;
    }
    .hud-bars {
      gap: 4px;
    }
    .hud-bar {
      gap: 4px;
      font-size: 11px;
    }
    .hud-meter {
      height: 7px;
    }
    .hud-row {
      gap: 3px;
    }
    .hud-row--stats, .hud-row--bottom {
      gap: 3px;
    }
    .hud-chip {
      padding: 2px 5px;
      font-size: 9px;
    }
    .hud-chip strong {
      font-size: 11px;
    }
    .hud-btn--status {
      min-height: 38px;
      font-size: 14px;
    }
    .footer-log {
      padding: 6px;
      gap: 4px;
    }
    .footer-log .status-log {
      height: clamp(72px, 10vh, 120px);
      padding: 6px;
      font-size: 11px;
    }
  }
</style>
<style id="interaction-guard">
  * { -webkit-touch-callout: none; -webkit-user-drag: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
  input, textarea, [contenteditable] { -webkit-user-select: none; -ms-user-select: none; user-select: none; }
</style>
<script id="interaction-guard-js">
  document.addEventListener('contextmenu', (event) => { event.preventDefault(); });
  document.addEventListener('dragstart', (event) => { event.preventDefault(); });
</script>
</head>
<body>
  <div class="game-shell">
    <div class="main">
      <section class="panel map-panel">
        <div class="hud">
          <div class="hud-bars">
            <div class="hud-bar">
              <span>たいりょく</span>
              <div class="hud-meter"><div class="hud-meter__fill" id="hpBar"></div></div>
              <strong id="hpShort">--</strong>
            </div>
            <div class="hud-bar">
              <span>まりょく</span>
              <div class="hud-meter hud-meter--mp"><div class="hud-meter__fill" id="mpBar"></div></div>
              <strong id="mpShort">--</strong>
            </div>
            <div class="hud-bar">
              <span>しーるど</span>
              <div class="hud-meter hud-meter--shield"><div class="hud-meter__fill" id="shieldBar"></div></div>
              <strong id="shieldShort">--</strong>
            </div>
          </div>
          <div class="hud-row hud-row--stats">
            <span class="hud-chip">こうげき <strong id="atkShort">--</strong></span>
            <span class="hud-chip">はやさ <strong id="spdShort">--</strong></span>
            <span class="hud-chip">ぼうぎょ <strong id="defShort">--</strong></span>
            <span class="hud-chip">うん <strong id="lucShort">--</strong></span>
          </div>
          <div class="hud-row hud-row--bottom">
            <span class="hud-chip hud-chip--coin"><img class="hud-icon" src="../character-dots/tyarin.png" alt="">チャリン <strong id="coinShort">--</strong></span>
            <button class="hud-btn hud-btn--status" id="openStatus" type="button">ステータス</button>
          </div>
        </div>
        <div class="map-frame">
          <canvas id="mapCanvas" width="480" height="480"></canvas>
        </div>
      </section>

      <aside class="panel status-panel">
        <h2>まおうさま すてーたす</h2>
        <div class="stat-grid">
          <div class="stat"><span>たいりょく</span><strong id="hpStat">--</strong></div>
          <div class="stat"><span>まりょく</span><strong id="mpStat">--</strong></div>
          <div class="stat"><span>こうげき</span><strong id="atkStat">--</strong></div>
          <div class="stat"><span>はやさ</span><strong id="spdStat">--</strong></div>
          <div class="stat"><span>ぼうぎょ</span><strong id="defStat">--</strong></div>
          <div class="stat"><span>うん</span><strong id="lucStat">--</strong></div>
        </div>
        <div class="stat-grid">
          <div class="stat"><span>れべる</span><strong id="levelStat">--</strong></div>
          <div class="stat"><span>ぼすだめーじ</span><strong id="expStat">--</strong></div>
          <div class="stat"><span>たから</span><strong id="itemStat">--</strong></div>
          <div class="stat"><span>チャリン</span><strong id="coinStat">--</strong></div>
          <div class="stat"><span>ほすう</span><strong id="stepStat">--</strong></div>
          <div class="stat"><span>とうばつ</span><strong id="killStat">--</strong></div>
          <div class="stat"><span>どく</span><strong id="poisonStat">--</strong></div>
        </div>
      </aside>
    </div>

    <div class="panel footer-log">
      <div class="status-log" id="footerLog"></div>
    </div>

  </div>

  <div class="sheet-overlay" id="statusSheet" aria-hidden="true">
    <div class="sheet">
      <div class="sheet-header">
        <div class="sheet-tabs">
          <button class="sheet-tab is-active" data-tab="stats" type="button">ステータス</button>
          <button class="sheet-tab" data-tab="log" type="button">ログ</button>
          <button class="sheet-tab" data-tab="skills" type="button">スキル</button>
          <button class="sheet-tab" data-tab="gear" type="button">装備</button>
        </div>
        <button class="sheet-close" id="closeStatus" type="button">閉じる</button>
      </div>
      <div class="sheet-body">
        <div class="sheet-panel is-active" data-panel="stats">
          <div class="stat-grid">
            <div class="stat"><span>たいりょく</span><strong id="hpStatSheet">--</strong></div>
            <div class="stat"><span>まりょく</span><strong id="mpStatSheet">--</strong></div>
            <div class="stat"><span>こうげき</span><strong id="atkStatSheet">--</strong></div>
            <div class="stat"><span>はやさ</span><strong id="spdStatSheet">--</strong></div>
            <div class="stat"><span>ぼうぎょ</span><strong id="defStatSheet">--</strong></div>
            <div class="stat"><span>うん</span><strong id="lucStatSheet">--</strong></div>
          </div>
          <div class="stat-grid">
            <div class="stat"><span>れべる</span><strong id="levelStatSheet">--</strong></div>
            <div class="stat"><span>ぼすだめーじ</span><strong id="expStatSheet">--</strong></div>
            <div class="stat"><span>たから</span><strong id="itemStatSheet">--</strong></div>
            <div class="stat"><span>チャリン</span><strong id="coinStatSheet">--</strong></div>
            <div class="stat"><span>ほすう</span><strong id="stepStatSheet">--</strong></div>
            <div class="stat"><span>とうばつ</span><strong id="killStatSheet">--</strong></div>
            <div class="stat"><span>どく</span><strong id="poisonStatSheet">--</strong></div>
          </div>
        </div>
        <div class="sheet-panel" data-panel="log">
          <div class="status-log" id="sheetLog"></div>
        </div>
        <div class="sheet-panel" data-panel="skills">
          <div class="skill-panel">
            <div class="icon-grid" id="skillList"></div>
            <div class="skill-detail" id="skillDetail">スキルはまだありません。</div>
          </div>
        </div>
        <div class="sheet-panel" data-panel="gear">
          <div class="skill-panel">
            <div class="icon-grid" id="gearList"></div>
            <div class="skill-detail" id="gearDetail">装備はまだありません。</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="battle-overlay" id="battleOverlay" aria-hidden="true">
    <div class="battle-panel">
      <div class="battle-header">
        <div class="battle-titles">
          <h2 id="battleTitle">戦闘開始</h2>
          <span id="battleSub">--</span>
        </div>
        <button class="battle-skip" id="battleSkipBtn" type="button" disabled>スキップ</button>
      </div>
      <div class="battle-actors">
        <div class="actor" id="playerActor">
          <div class="actor-head"><div class="actor-icon" id="playerIcon">魔</div><div id="playerName">魔王様</div></div>
          <div class="hp-bar"><div class="hp-fill" id="playerHpFill"></div></div>
          <div id="playerHpText">--</div>
          <div class="mp-bar"><div class="mp-fill" id="playerMpFill"></div></div>
          <div id="playerMpText">--</div>
          <div class="shield-bar"><div class="shield-fill" id="playerShieldFill"></div></div>
          <div id="playerShieldText">--</div>
        </div>
        <div class="actor" id="enemyActor">
          <div class="actor-head"><div class="actor-icon" id="enemyIcon">敵</div><div id="enemyName">--</div></div>
          <div class="hp-bar"><div class="hp-fill" id="enemyHpFill"></div></div>
          <div id="enemyHpText">--</div>
          <div class="mp-bar"><div class="mp-fill" id="enemyMpFill"></div></div>
          <div id="enemyMpText">--</div>
          <div class="shield-bar"><div class="shield-fill" id="enemyShieldFill"></div></div>
          <div id="enemyShieldText">--</div>
        </div>
      </div>
      <div class="battle-log" id="battleLog"></div>
    </div>
  </div>

  <div class="choice-overlay" id="skillChoiceOverlay" aria-hidden="true">
    <div class="choice-panel">
      <h2>宝箱のスキル</h2>
      <p class="choice-sub">1つ選んでください</p>
      <div class="choice-grid" id="skillChoiceList"></div>
      <div class="choice-actions">
        <button class="btn" id="skillRerollBtn" type="button">
          リロール (<img class="btn-coin" src="../character-dots/tyarin.png" alt="">100)
        </button>
      </div>
    </div>
  </div>

  <div class="result-overlay" id="resultOverlay" aria-hidden="true">
    <div class="result-panel">
      <h2 class="result-title" id="resultTitle">--</h2>
      <p id="resultSummary">--</p>
      <div class="result-stats" id="resultStats"></div>
      <div class="status-log">
        <p>ランキング</p>
        <ul class="rank-list" id="rankList"></ul>
        <p id="rankStatus" class="rank-status">ダメージ送信中...</p>
      </div>
      <div class="result-actions">
        <button class="btn" id="retryBtn">もう一度</button>
      </div>
    </div>
  </div>

  <div class="ad-footer">
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-9801602250480253"
         data-ad-slot="2141591954"></ins>
  </div>

<script>
(() => {
  const MAP_SIZE = 9;
  const NORMAL_VIEW_TILES = 9;
  const HEAL_RATE = 0.2;
  const TRAP_DAMAGE = 6;
  const MIMIC_DAMAGE_RATE = 0.1;
  const MIN_HP = 10;
  const MIN_STAT = 1;
  const POISON_STEPS = 5;
  const ENEMY_BASE_POISON_STEPS = 1;
  const POISON_DAMAGE_PER_STACK = 1;
  const MAX_POISON_STACKS = 9;
  const BASE_FIRE_MAX_STACKS = 3;
  const AWAKEN_FIRE_MAX_STACKS = 6;
  const FIRE_DAMAGE_RATE = 0.01;
  const RANDOM_WALL_COUNT = 5;
  const RANDOM_WALL_ATTEMPTS = 40;
  const ENEMY_ORDER = ['slime', 'bat', 'golem', 'mage', 'assassin'];
  const TAG_IDS = ['crit', 'dot', 'multi', 'guard', 'stat'];
  const TAG_LABELS = {
    crit: '会心',
    dot: '継続',
    multi: '連撃',
    guard: '防御',
    stat: '成長'
  };
  const AWAKEN_THRESHOLD = 3;
  const MAX_EXTRA_HITS_PER_ACTION = 2;
  const MAX_HITS_PER_ACTION = 5;
  const MAX_REFLECT_RATE = 0.3;
  const AWAKEN_DOT_STACK_CHANCE = 0.5;
  const AWAKEN_GUARD_SHIELD_RATE = 0.35;
  const AWAKEN_GUARD_REFLECT_BONUS = 0.08;
  const AWAKEN_STAT_DAMAGE_PER_TILE = 0.03;
  const AWAKEN_STAT_DAMAGE_CAP = 0.6;
  const AWAKEN_STAT_TURN_GAIN_CAP = 6;
  const BASE_ACTION_CHAIN_RATE = 0.06;
  const NO_SUB_CRIT_CAP_BONUS = 0.25;
  const NO_SUB_DOT_CRIT_BONUS = 0.3;
  const NO_SUB_TOXIC_LENGTH_BONUS = 3;
  const NO_SUB_DOT_REND_MULT = 1.22;
  const NO_SUB_CHAIN_CHANCE_BONUS = 0.16;
  const NO_SUB_COMBO_POWER_STEP = 0.12;
  const NO_SUB_COMBO_POWER_CAP = 0.6;
  const NO_SUB_LAST_CRIT_BONUS = 0.45;
  const NO_SUB_OVERHEAL_SHIELD_MULT = 1.35;
  const NO_SUB_OVERHEAL_DAMAGE_MULT = 1.35;
  const NO_SUB_DAMAGE_CUT_RATE = 0.18;
  const NO_SUB_STAT_DEF_GAIN = 3;
  const NO_SUB_STAT_LUC_GAIN = 3;
  const NO_SUB_STAT_HP_GAIN = 8;
  const STAT_COMBO_LABELS = { atk: '攻', spd: '速', def: '防', hp: 'HP', luc: '運' };
  const ROUTE_FOCUS_TILE_ORDER = ['treasure', 'mimic', 'key', 'atk', 'spd', 'def', 'hp', 'luc', 'monster'];
  const ROUTE_FOCUS_TILE_LABELS = {
    treasure: '宝箱',
    mimic: '偽宝箱',
    key: '鍵',
    atk: '攻',
    spd: '速',
    def: '防',
    hp: 'HP',
    luc: '運',
    monster: '敵'
  };
  const BLOCKING_TILE_IDS = new Set(['wall']);
  const TRAIL_IMMUNE_TILE_IDS = new Set(['wall', 'start', 'boss', 'mimic', 'warp', 'inn', 'weaponShop', 'armorShop', 'accessoryShop']);
  const BASE_PARAM_TILE_CAPS = { atk: 2, spd: 2, hp: 2, def: 1, luc: 1 };
  const BASE_PARAM_TILE_LIMIT = Object.values(BASE_PARAM_TILE_CAPS).reduce((sum, value) => sum + value, 0);
  const STAT_TILE_IDS = ['atk', 'spd', 'def', 'hp', 'luc'];
  const TRAIL_STAT_BASE_GAINS = { atk: 1, spd: 1, def: 1, hp: 2, luc: 1 };
  const CHUNK_SIZE = 3;
  const POISON_FILL_CHUNKS = [
    { col: 1, row: 0 }, // 1B
    { col: 2, row: 0 }, // 1C (右上の敵拠点側)
    { col: 2, row: 1 }  // 2C
  ];
  const ATTACK_TILE_MAX = 13;
  const BOSS_GROWTH = { atk: 0.2, def: 0.15, spd: 0.15, luc: 0.05, mp: 0.05 };
  const BOSS_HP_PER_LEVEL = 1;
  const COIN_STORAGE_KEY = 'maou-war_coins';
  const BATTLE_FAST_HIT_DELAY = 40;
  const BATTLE_FAST_TURN_DELAY = 60;
  const BATTLE_SLOW_HIT_DELAY = 260;
  const BATTLE_SLOW_TURN_DELAY = 220;
  const BATTLE_SLOW_START_MS = 1800;
  const BATTLE_SPEED_RAMP_MS = 800;
  const BATTLE_END_SLOW_START = 0.85;
  const BATTLE_END_SLOW_RANGE = 0.15;
  const BATTLE_PACE_MIN_DELAY = 10;
  const BATTLE_PACE_MAX_DELAY = 900;
  const BATTLE_SLOW_BOOST = 1.25;
  const BATTLE_LOG_REVEAL_MS = 80;
  const PLAYER_ATTACK_MP_GAIN = 1;
  const PLAYER_ACTIVE_SKILL_CHANCE = 0.35;
  const PLAYER_ACTIVE_SKILL = { type: 'magic', label: '魔王の魔法', power: 1.25, ignoreDef: true, mpCost: 2 };
  const TRIPLE_STRIKE_MP_COST = 2;
  const TREASURE_TILE_COUNT = 5;
  const MAX_SKILL_COUNT = 8;
  const SKILL_REROLL_COST = 100;
  const INN_REST_COST = 15;
  const SHOP_BASE_COSTS = { weapon: 35, armor: 35, accessory: 45 };
  const SHOP_COST_GROWTH = { weapon: 25, armor: 25, accessory: 30 };
  const SHOP_VARIANTS = {
    weapon: [
      { id: 'iron_blade', name: '鉄刃', bonus: { atk: 3 }, costAdd: 0, iconTileKey: 'tile4' },
      { id: 'swift_dagger', name: '疾風短剣', bonus: { atk: 1, spd: 2 }, costAdd: 5, iconTileKey: 'tile1' },
      { id: 'war_axe', name: '戦斧', bonus: { atk: 4, def: 1 }, costAdd: 12, iconTileKey: 'tile4' },
      { id: 'arc_gun', name: '魔弾銃', bonus: { atk: 2, luc: 2, mp: 1 }, costAdd: 10, iconTileKey: 'tile26' },
      { id: 'dragoon_spear', name: '竜槍', bonus: { atk: 3, spd: 1, luc: 1 }, costAdd: 14, iconTileKey: 'tile4' }
    ],
    armor: [
      { id: 'leather_mail', name: '革鎧', bonus: { def: 2, hp: 4 }, costAdd: 0, iconTileKey: 'tile2' },
      { id: 'plate_mail', name: '鋼鎧', bonus: { def: 3, hp: 6 }, costAdd: 8, iconTileKey: 'tile2' },
      { id: 'mobile_armor', name: '機動鎧', bonus: { def: 2, hp: 3, spd: 1 }, costAdd: 6, iconTileKey: 'tile1' },
      { id: 'barrier_cloak', name: '結界衣', bonus: { def: 2, hp: 3, mp: 1, luc: 1 }, costAdd: 10, iconTileKey: 'tile27' },
      { id: 'fortress_guard', name: '城塞装甲', bonus: { def: 4, hp: 8 }, costAdd: 16, iconTileKey: 'tile2' }
    ],
    accessory: [
      { id: 'fortune_ring', name: '幸運指輪', bonus: { luc: 3 }, costAdd: 0, iconTileKey: 'tile26' },
      { id: 'mana_charm', name: '魔力護符', bonus: { mp: 2, luc: 1 }, costAdd: 6, iconTileKey: 'tile26' },
      { id: 'swift_charm', name: '疾風チャーム', bonus: { spd: 2, luc: 1 }, costAdd: 6, iconTileKey: 'tile1' },
      { id: 'power_brooch', name: '剛力ブローチ', bonus: { atk: 2, luc: 1 }, costAdd: 8, iconTileKey: 'tile4' },
      { id: 'guardian_amulet', name: '守護アミュレット', bonus: { def: 2, hp: 4, luc: 1 }, costAdd: 10, iconTileKey: 'tile2' }
    ]
  };
  const SKILL_DEFS = [
    { id: 'critRate', name: '狙撃眼', desc: '会心率+10%', tags: ['crit'], subTags: ['multi'] },
    { id: 'critCap', name: '臨戦感覚', desc: '会心率の上限+25%', tags: ['crit'] },
    { id: 'critDamage', name: '急所破壊', desc: '会心ダメージ+30%', tags: ['crit'], subTags: ['dot'] },
    { id: 'critLifesteal', name: '吸命刃', desc: '会心時に与ダメの10%回復', tags: ['crit'], subTags: ['guard'] },
    { id: 'dotCrit', name: '弱点穿ち', desc: 'DoT中の敵への会心率+30%', tags: ['crit'] },

    { id: 'poisonStrike', name: '毒牙', desc: '会心時に毒スタック+1', tags: ['dot'], subTags: ['crit'] },
    { id: 'fireStrike', name: '炎爪', desc: '会心時に炎スタック+1 / 攻撃時に炎ダメージ', tags: ['dot'], subTags: ['multi'] },
    { id: 'toxicLength', name: '腐蝕延長', desc: '敵毒の持続歩数+3', tags: ['dot'] },
    { id: 'dotAmp', name: '侵食加速', desc: '毒/炎ダメージ+40%', tags: ['dot'], subTags: ['stat'] },
    { id: 'dotRend', name: '蝕み追撃', desc: 'DoT中の敵へ与ダメ+22%', tags: ['dot'] },

    { id: 'tripleStrike', name: '三連撃', desc: '10%で3連撃', tags: ['multi'], subTags: ['crit'] },
    { id: 'chainChance', name: '連刃', desc: '連撃発生率+16%', tags: ['multi'] },
    { id: 'multiMp', name: '連撃充填', desc: '追加ヒット時にMP+1', tags: ['multi'], subTags: ['stat'] },
    { id: 'comboPower', name: 'コンボ倍率', desc: '同一行動の後段ほど与ダメ増加(最大+60%)', tags: ['multi'] },
    { id: 'lastCrit', name: '終段会心', desc: '連撃の最終段で会心率+45%', tags: ['multi'] },

    { id: 'stepHeal', name: '歩行回復', desc: '歩くたび最大HP10%回復', tags: ['guard'], subTags: ['dot'] },
    { id: 'overhealShield', name: '過剰装甲', desc: '回復超過分の135%がシールドになる', tags: ['guard'] },
    { id: 'overhealDamage', name: '過剰反撃', desc: '回復超過分の135%を敵へ与える', tags: ['guard'] },
    { id: 'reflect', name: '反射', desc: '被ダメージの10%を反射', tags: ['guard'], subTags: ['crit'] },
    { id: 'damageCut', name: '防御姿勢', desc: '被ダメージ-18%', tags: ['guard'] },

    { id: 'statAtk', name: '剛力結晶', desc: '習得時にこうげき+2', tags: ['stat'], subTags: ['crit'] },
    { id: 'statSpd', name: '疾風結晶', desc: '習得時にはやさ+2', tags: ['stat'], subTags: ['multi'] },
    { id: 'statDef', name: '鉄壁結晶', desc: '習得時にぼうぎょ+3', tags: ['stat'] },
    { id: 'statLuc', name: '幸運結晶', desc: '習得時にうん+3', tags: ['stat'] },
    { id: 'statHp', name: '生命結晶', desc: '習得時にたいりょく+8', tags: ['stat'] },
    { id: 'trailDouble', name: '路線倍化', desc: '路タイルの能力上昇が2倍になる', tags: ['stat'], mapOnly: true }
  ];
  const SYNERGY_DEFS = [
    {
      id: 'crit_stat',
      name: '会心 x 成長',
      requires: ['crit', 'stat'],
      rewards: [
        { id: 'critStatCapBreak', name: '臨界会心', desc: '会心率上限90%、会心率+5%' },
        { id: 'lucidCrit', name: '幸運増幅', desc: '会心ダメージがうんに応じて上昇' }
      ]
    },
    {
      id: 'dot_multi',
      name: '継続 x 連撃',
      requires: ['dot', 'multi'],
      rewards: [
        { id: 'dotMultiSpread', name: '連鎖侵食', desc: '追加ヒット時に毒/炎を追加しやすくなる' },
        { id: 'dotMultiTick', name: '追撃燃焼', desc: '連撃後に毒と炎で追加ダメージ' }
      ]
    },
    {
      id: 'guard_dot',
      name: '防御 x 継続',
      requires: ['guard', 'dot'],
      rewards: [
        { id: 'guardDotThorn', name: '毒棘反射', desc: '反射時に毒スタック+1を付与' },
        { id: 'guardDotPurge', name: '燃える再生', desc: '回復時に敵へ炎スタック+1' }
      ]
    }
  ];
  const SKILL_ICON_KEYS = ['tile16', 'tile17', 'tile18', 'tile19', 'tile20', 'tile21', 'tile22', 'tile23', 'tile24', 'tile25', 'tile26'];
  const FIXED_WALLS = [
    { x: CHUNK_SIZE * 2 + 1, y: 1 },
    { x: CHUNK_SIZE + 1, y: CHUNK_SIZE + 1 }
  ];
  const SKILL_SPRITE_KEYS = SKILL_DEFS.reduce((acc, skill, index) => {
    acc[skill.id] = SKILL_ICON_KEYS[index % SKILL_ICON_KEYS.length];
    return acc;
  }, {});
  SKILL_SPRITE_KEYS.trailDouble = 'tile26';
  const MAP_ONLY_SKILL_IDS = new Set(SKILL_DEFS.filter(skill => skill.mapOnly).map(skill => skill.id));

  const FIXED_MAP = [
    ['empty', 'empty', 'poison', 'empty', 'empty', 'treasure', 'empty', 'luc', 'boss'],
    ['treasure', 'empty', 'key', 'heal', 'empty', 'hp', 'empty', 'wall', 'skill'],
    ['empty', 'empty', 'empty', 'treasure', 'empty', 'empty', 'warp', 'spd', 'empty'],
    ['empty', 'empty', 'empty', 'trap', 'empty', 'empty', 'empty', 'empty', 'empty'],
    ['empty', 'poison', 'def', 'empty', 'empty', 'empty', 'treasure', 'empty', 'heal'],
    ['empty', 'weaponShop', 'empty', 'hp', 'empty', 'empty', 'atk', 'empty', 'empty'],
    ['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'mimic', 'empty', 'empty'],
    ['spd', 'treasure', 'empty', 'empty', 'armorShop', 'empty', 'empty', 'empty', 'empty'],
    ['start', 'empty', 'atk', 'empty', 'empty', 'empty', 'accessoryShop', 'empty', 'inn']
  ];

  const FIXED_ENEMIES = [];
  const FIXED_SKILL_TILES = [
    { x: MAP_SIZE - 1, y: 1, skillId: 'trailDouble' }  // 勇者拠点の下
  ];

  let fullMapView = true;
  let viewTiles = fullMapView ? MAP_SIZE : NORMAL_VIEW_TILES;
  let itemTileTotal = 0;

  const TILE_TYPES = {
    empty: { id: 'empty', color: '#1f2538', name: '平地' },
    atk: { id: 'atk', color: '#ef4444', name: 'こうげき' },
    spd: { id: 'spd', color: '#60a5fa', name: 'はやさ' },
    def: { id: 'def', color: '#22c55e', name: 'ぼうぎょ' },
    hp: { id: 'hp', color: '#f472b6', name: 'たいりょく' },
    luc: { id: 'luc', color: '#facc15', name: 'うん' },
    heal: { id: 'heal', color: '#10b981', name: '回復' },
    poison: { id: 'poison', color: '#a855f7', name: '毒' },
    warp: { id: 'warp', color: '#9ca3af', name: '魔法陣' },
    ice: { id: 'ice', color: '#93c5fd', name: '氷' },
    key: { id: 'key', color: '#fbbf24', name: '鍵' },
    inn: { id: 'inn', color: '#14b8a6', name: '宿屋' },
    weaponShop: { id: 'weaponShop', color: '#dc2626', name: 'ぶきや' },
    armorShop: { id: 'armorShop', color: '#2563eb', name: 'ぼうぐや' },
    accessoryShop: { id: 'accessoryShop', color: '#d97706', name: 'ほうしょくや' },
    skill: { id: 'skill', color: '#f59e0b', name: 'スキル' },
    treasure: { id: 'treasure', color: '#facc15', name: '宝箱' },
    mimic: { id: 'mimic', color: '#f97316', name: '偽宝箱' },
    trap: { id: 'trap', color: '#9ca3af', name: 'トラップ' },
    monster: { id: 'monster', color: '#111827', name: '敵' },
    start: { id: 'start', color: '#2563eb', name: '拠点' },
    boss: { id: 'boss', color: '#1e3a8a', name: 'ボス' },
    wall: { id: 'wall', color: '#0b0f1d', name: '岩壁' }
  };
  const TILE_WEIGHTS = [
    { id: 'atk', weight: 0.13 },
    { id: 'spd', weight: 0.13 },
    { id: 'def', weight: 0.13 },
    { id: 'hp', weight: 0.13 },
    { id: 'luc', weight: 0.08 },
    { id: 'heal', weight: 0.08 },
    { id: 'poison', weight: 0.08 },
    { id: 'treasure', weight: 0.05 },
    { id: 'mimic', weight: 0.02 },
    { id: 'monster', weight: 0.08 },
    { id: 'empty', weight: 0.06 }
  ];

  const tileSpritePaths = {
    tile1: './ground-sprite-01.png',
    tile2: './ground-sprite-02.png',
    tile3: './ground-sprite-03.png',
    tile4: './ground-sprite-04.png',
    tile5: './ground-sprite-05.png',
    tile6: './ground-sprite-06.png',
    tile7: './ground-sprite-07.png',
    tile8: './ground-sprite-08.png',
    tile9: './ground-sprite-09.png',
    tile10: './ground-sprite-10.png',
    tile11: './ground-sprite-11.png',
    tile12: './ground-sprite-12.png',
    tile13: './ground-sprite-13.png',
    tile14: './ground-sprite-14.png',
    tile15: './ground-sprite-15.png',
    tile16: './ground-sprite-16.png',
    tile17: './ground-sprite-17.png',
    tile18: './ground-sprite-18.png',
    tile19: './ground-sprite-19.png',
    tile20: './ground-sprite-20.png',
    tile21: './ground-sprite-21.png',
    tile22: './ground-sprite-22.png',
    tile23: './ground-sprite-23.png',
    tile24: './ground-sprite-24.png',
    tile25: './ground-sprite-25.png',
    tile26: './ground-sprite-26.png',
    tile27: './ground-sprite-27.png',
    tile28: './ground-sprite-28.png',
    tile29: './ground-sprite-29.png',
    tile30: './ground-sprite-30.png',
    tile31: './ground-sprite-31.png'
  };
  const SKILL_SPRITE_PATHS = Object.entries(SKILL_SPRITE_KEYS).reduce((acc, [id, key]) => {
    acc[id] = tileSpritePaths[key];
    return acc;
  }, {});
  const tileSprites = {};
  Object.entries(tileSpritePaths).forEach(([id, src]) => {
    const img = new Image();
    img.decoding = 'async';
    img.src = src;
    img.onload = () => {
      if (tileSize) renderMap();
    };
    tileSprites[id] = img;
  });

  const tileBaseSpriteMap = {
    empty: 'tile9',
    atk: 'tile4',
    spd: 'tile1',
    def: 'tile2',
    hp: 'tile3',
    luc: 'tile6',
    heal: 'tile9',
    poison: 'tile7',
    warp: 'tile9',
    ice: 'tile9',
    key: 'tile9',
    skill: 'tile9',
    treasure: 'tile9',
    mimic: 'tile9',
    trap: 'tile9',
    monster: 'tile9',
    start: 'tile9',
    boss: 'tile9',
    wall: null
  };
  const tileOverlaySpriteMap = {
    start: 'tile10',
    boss: 'tile11',
    treasure: 'tile12',
    heal: 'tile13',
    mimic: 'tile14',
    trap: 'tile15',
    warp: 'tile15',
    ice: 'tile27',
    key: 'tile28',
    weaponShop: 'tile29',
    armorShop: 'tile30',
    accessoryShop: 'tile31'
  };

  const ENEMY_TYPE_LABELS = {
    slime: '1',
    bat: '2',
    golem: '3',
    mage: '4',
    assassin: '5',
    mimic: 'M'
  };

  const playerSpritePaths = {
    down: './buburin-1.png',
    right: './buburin-2.png',
    up: './buburin-3.png',
    left: './buburin-4.png'
  };
  const playerSprites = {};
  Object.entries(playerSpritePaths).forEach(([dir, src]) => {
    const img = new Image();
    img.decoding = 'async';
    img.src = src;
    img.onload = () => {
      if (tileSize) renderMap();
    };
    playerSprites[dir] = img;
  });

  const ENEMY_TYPES = [
    {
      id: 'slime',
      name: 'スライム兵',
      color: '#7dd3fc',
      exp: 6,
      level: 10,
      stats: { hp: 10, atk: 3, spd: 2, def: 1, luc: 1, mp: 1 },
      growth: { hp: 0.35, mp: 0.05, atk: 0.18, spd: 0.16, def: 0.16, luc: 0.1 },
      noScale: true,
      ai: (state) => (Math.random() < 0.25 ? { type: 'guard', label: 'ぷるるガード', guard: 2 } : { type: 'attack', label: '体当たり', power: 1 })
    },
    {
      id: 'bat',
      name: '影コウモリ',
      color: '#c4b5fd',
      exp: 7,
      level: 25,
      stats: { hp: 10, atk: 3, spd: 5, def: 1, luc: 3, mp: 1 },
      growth: { hp: 0.28, mp: 0.05, atk: 0.2, spd: 0.3, def: 0.12, luc: 0.22 },
      noScale: true,
      ai: () => (Math.random() < 0.3 ? { type: 'multi', label: '連続噛み', power: 0.7, hits: 2 } : { type: 'attack', label: '噛みつき', power: 1 })
    },
    {
      id: 'golem',
      name: '土塊ゴーレム',
      color: '#fca5a5',
      exp: 10,
      level: 40,
      stats: { hp: 14, atk: 4, spd: 1, def: 2, luc: 1, mp: 1 },
      growth: { hp: 0.45, mp: 0.03, atk: 0.16, spd: 0.08, def: 0.26, luc: 0.05 },
      noScale: true,
      ai: () => (Math.random() < 0.25 ? { type: 'heavy', label: '大地の一撃', power: 1.4 } : { type: 'attack', label: '拳打', power: 1 })
    },
    {
      id: 'mage',
      name: '黒魔導士',
      color: '#f9a8d4',
      exp: 9,
      level: 60,
      stats: { hp: 12, atk: 4, spd: 4, def: 2, luc: 2, mp: 8 },
      growth: { hp: 0.34, mp: 0.34, atk: 0.22, spd: 0.18, def: 0.12, luc: 0.18 },
      noScale: true,
      ai: (state) => (state.mp >= 2 && Math.random() < 0.3 ? { type: 'magic', label: '闇の魔法', power: 1.2, ignoreDef: true, mpCost: 2 } : { type: 'attack', label: '杖撃', power: 1 })
    },
    {
      id: 'assassin',
      name: '夜襲アサシン',
      color: '#fcd34d',
      exp: 8,
      level: 80,
      stats: { hp: 12, atk: 5, spd: 7, def: 2, luc: 5, mp: 1 },
      growth: { hp: 0.32, mp: 0.05, atk: 0.28, spd: 0.36, def: 0.14, luc: 0.28 },
      noScale: true,
      ai: () => (Math.random() < 0.25 ? { type: 'crit', label: '影縫い', power: 1.1, critBonus: 0.2 } : { type: 'attack', label: '斬撃', power: 1 })
    },
    {
      id: 'mimic',
      name: 'ミミック',
      color: '#fb7185',
      exp: 10,
      level: 50,
      stats: { hp: 14, atk: 5, spd: 3, def: 2, luc: 2, mp: 1 },
      growth: { hp: 0.3, mp: 0.05, atk: 0.22, spd: 0.18, def: 0.18, luc: 0.12 },
      noScale: true,
      ai: () => (Math.random() < 0.3 ? { type: 'heavy', label: '噛み砕き', power: 1.2 } : { type: 'attack', label: '宝箱バイト', power: 1 })
    }
  ];

  const ENEMY_TIERS = [
    { tier: 1, count: 1, type: 'slime' },
    { tier: 2, count: 1, type: 'bat' },
    { tier: 3, count: 1, type: 'golem' },
    { tier: 4, count: 1, type: 'mage' },
    { tier: 5, count: 1, type: 'assassin' }
  ];

  const HERO_BOSS = {
    id: 'hero',
    name: '勇者',
    color: '#f97316',
    level: 100,
    exp: 24,
    stats: { hp: 28, atk: 7, spd: 5, def: 3, luc: 5, mp: 4 },
    growth: { hp: 0.4, mp: 0.2, atk: 0.22, spd: 0.2, def: 0.18, luc: 0.18 },
    noScale: true,
    ai: (state) => (state.mp >= 2 && Math.random() < 0.4 ? { type: 'heavy', label: '聖剣斬り', power: 1.4, mpCost: 2 } : { type: 'attack', label: '勇者の一撃', power: 1 })
  };

  const GEAR_RARITIES = [
    { id: 'N', label: 'N', color: '#94a3b8', factor: 0.05, min: 0 },
    { id: 'HR', label: 'HR', color: '#34d399', factor: 0.12, min: 1 },
    { id: 'SR', label: 'SR', color: '#a78bfa', factor: 0.2, min: 2 },
    { id: 'SSR', label: 'SSR', color: '#f472b6', factor: 0.28, min: 3 },
    { id: 'UR', label: 'UR', color: '#f97316', factor: 0.36, min: 4 },
    { id: 'L', label: 'L', color: '#facc15', factor: 0.44, min: 5 }
  ];
  const GEAR_RARITY_ORDER = GEAR_RARITIES.map(r => r.id);

  const mapCanvas = document.getElementById('mapCanvas');
  const ctx = mapCanvas.getContext('2d');
  const mapStatus = document.getElementById('mapStatus');
  const baseDirection = document.getElementById('baseDirection');
  const footerLog = document.getElementById('footerLog');
  const sheetLog = document.getElementById('sheetLog');
  const hpBar = document.getElementById('hpBar');
  const mpBar = document.getElementById('mpBar');
  const shieldBar = document.getElementById('shieldBar');
  const statsEl = {
    hp: document.getElementById('hpStat'),
    mp: document.getElementById('mpStat'),
    atk: document.getElementById('atkStat'),
    spd: document.getElementById('spdStat'),
    def: document.getElementById('defStat'),
    luc: document.getElementById('lucStat'),
    level: document.getElementById('levelStat'),
    exp: document.getElementById('expStat'),
    items: document.getElementById('itemStat'),
    coins: document.getElementById('coinStat'),
    steps: document.getElementById('stepStat'),
    kills: document.getElementById('killStat'),
    poison: document.getElementById('poisonStat')
  };
  const sheetStatsEl = {
    hp: document.getElementById('hpStatSheet'),
    mp: document.getElementById('mpStatSheet'),
    atk: document.getElementById('atkStatSheet'),
    spd: document.getElementById('spdStatSheet'),
    def: document.getElementById('defStatSheet'),
    luc: document.getElementById('lucStatSheet'),
    level: document.getElementById('levelStatSheet'),
    exp: document.getElementById('expStatSheet'),
    items: document.getElementById('itemStatSheet'),
    coins: document.getElementById('coinStatSheet'),
    steps: document.getElementById('stepStatSheet'),
    kills: document.getElementById('killStatSheet'),
    poison: document.getElementById('poisonStatSheet')
  };
  const hudStatsEl = {
    hp: document.getElementById('hpShort'),
    mp: document.getElementById('mpShort'),
    shield: document.getElementById('shieldShort'),
    atk: document.getElementById('atkShort'),
    spd: document.getElementById('spdShort'),
    def: document.getElementById('defShort'),
    luc: document.getElementById('lucShort'),
    level: document.getElementById('levelShort'),
    exp: document.getElementById('expShort'),
    items: document.getElementById('itemShort'),
    coins: document.getElementById('coinShort'),
    steps: document.getElementById('stepShort'),
    kills: document.getElementById('killShort'),
    poison: document.getElementById('poisonShort')
  };

  const skillListEl = document.getElementById('skillList');
  const skillDetailEl = document.getElementById('skillDetail');
  const gearListEl = document.getElementById('gearList');
  const gearDetailEl = document.getElementById('gearDetail');

  const statusSheet = document.getElementById('statusSheet');
  const openStatusBtn = document.getElementById('openStatus');
  const closeStatusBtn = document.getElementById('closeStatus');
  const toggleViewBtn = document.getElementById('toggleView');

  const battleOverlay = document.getElementById('battleOverlay');
  const battleTitle = document.getElementById('battleTitle');
  const battleSub = document.getElementById('battleSub');
  const battleLog = document.getElementById('battleLog');
  const battleSkipBtn = document.getElementById('battleSkipBtn');
  const skillChoiceOverlay = document.getElementById('skillChoiceOverlay');
  const skillChoiceList = document.getElementById('skillChoiceList');
  const skillRerollBtn = document.getElementById('skillRerollBtn');
  const skillChoiceTitleEl = skillChoiceOverlay?.querySelector('h2') || null;
  const skillChoiceSubEl = skillChoiceOverlay?.querySelector('.choice-sub') || null;
  const playerActor = document.getElementById('playerActor');
  const enemyActor = document.getElementById('enemyActor');
  const playerHpFill = document.getElementById('playerHpFill');
  const enemyHpFill = document.getElementById('enemyHpFill');
  const playerMpFill = document.getElementById('playerMpFill');
  const enemyMpFill = document.getElementById('enemyMpFill');
  const playerShieldFill = document.getElementById('playerShieldFill');
  const enemyShieldFill = document.getElementById('enemyShieldFill');
  const playerHpText = document.getElementById('playerHpText');
  const enemyHpText = document.getElementById('enemyHpText');
  const playerMpText = document.getElementById('playerMpText');
  const enemyMpText = document.getElementById('enemyMpText');
  const playerShieldText = document.getElementById('playerShieldText');
  const enemyShieldText = document.getElementById('enemyShieldText');
  const enemyNameEl = document.getElementById('enemyName');
  const enemyIcon = document.getElementById('enemyIcon');
  const playerNameEl = document.getElementById('playerName');
  const playerIcon = document.getElementById('playerIcon');

  const resultOverlay = document.getElementById('resultOverlay');
  const resultTitle = document.getElementById('resultTitle');
  const resultSummary = document.getElementById('resultSummary');
  const resultStats = document.getElementById('resultStats');
  const rankList = document.getElementById('rankList');
  const rankStatus = document.getElementById('rankStatus');

  if (battleSkipBtn) {
    battleSkipBtn.addEventListener('click', () => {
      if (!battleActive || battleSkipActive) return;
      battleSkipActive = true;
      battleSkipBtn.disabled = true;
      battleSkipBtn.textContent = 'スキップ中';
      setBattleLogDelayProvider(() => 0);
    });
  }
  if (skillRerollBtn) {
    skillRerollBtn.addEventListener('click', () => {
      if (!isChoosingSkill) return;
      if (!activeChoiceContext?.allowReroll) return;
      if (!spendCoins(SKILL_REROLL_COST, 'リロール')) {
        addLog('チャリンが足りない');
        updateSkillRerollState();
        return;
      }
      updateStats();
      const choices = activeChoiceContext.buildOptions?.() || [];
      if (!choices.length) {
        addLog(activeChoiceContext.emptyLog || '習得できるスキルがない');
        closeSkillChoice(null);
        return;
      }
      renderSkillChoiceOptions(choices, activeChoiceContext.onPick);
      updateSkillRerollState();
    });
  }

  let spawn = { x: 0, y: 0 };
  let bossPos = { x: 0, y: 0 };
  let tiles = [];
  let trailTileOwners = [];
  let enemies = [];
  let visited = [];
  let skillTiles = [];
  let enemyCount = 0;
  let healTileCount = 0;
  let trapTileCount = 0;
  let poisonTileCount = 0;
  let treasureTileCount = 0;
  let mimicTileCount = 0;
  let revealedMimics = new Set();
  let tileSize = 0;
  let viewSizePx = 0;
  let battleActive = false;
  let isChoosingSkill = false;
  let gameOver = false;
  let isMoving = false;
  let isAutoPathMoving = false;
  let moveAnim = null;
  let playerFacing = 'down';
  let lastBossLevel = 0;
  let treasureOpenedCount = 0;
  let warpSelectionActive = false;
  let routeInsightSeen = new Set();
  const MOVE_ANIM_MS = 180;

  const BASE_STATS = { hp: 10, mp: 1, atk: 1, spd: 1, def: 1, luc: 1 };
  const DEFAULT_CHOICE_TITLE = '宝箱のスキル';
  const DEFAULT_CHOICE_SUBTITLE = '1つ選んでください';

  function createTagCounter() {
    return TAG_IDS.reduce((acc, tag) => {
      acc[tag] = 0;
      return acc;
    }, {});
  }

  function createStatCounter() {
    return STAT_TILE_IDS.reduce((acc, stat) => {
      acc[stat] = 0;
      return acc;
    }, {});
  }

  function createShopCounter() {
    return { weapon: 0, armor: 0, accessory: 0 };
  }

  function createShopPurchaseState() {
    return { weapon: false, armor: false, accessory: false };
  }

  const player = {
    x: 0,
    y: 0,
    level: 1,
    bossDamage: 0,
    coins: loadStoredCoins(),
    itemsCollected: 0,
    baseStats: { ...BASE_STATS },
    hp: BASE_STATS.hp,
    maxHp: BASE_STATS.hp,
    mp: BASE_STATS.mp,
    maxMp: BASE_STATS.mp,
    atk: BASE_STATS.atk,
    spd: BASE_STATS.spd,
    def: BASE_STATS.def,
    luc: BASE_STATS.luc,
    kills: 0,
    steps: 0,
    gear: { accessory: null },
    gearBonus: { atk: 0, spd: 0, def: 0, luc: 0 },
    gearInventory: [],
    skills: {},
    hasKey: false,
    shield: 0,
    tagCounts: createTagCounter(),
    awakenedTags: {},
    synergyTaken: {},
    synergyPerks: {},
    statTilesCollected: 0,
    activeStatMode: null,
    trailStatCounts: createStatCounter(),
    shopLevels: createShopCounter(),
    shopPurchased: createShopPurchaseState(),
    poisonStacks: 0,
    poisonSteps: 0
  };

  let rngSeed = Date.now() % 2147483647;
  function rand() {
    rngSeed = rngSeed * 16807 % 2147483647;
    return (rngSeed - 1) / 2147483646;
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function loadStoredCoins() {
    try {
      const raw = localStorage.getItem(COIN_STORAGE_KEY);
      const value = parseInt(raw, 10);
      return Number.isFinite(value) && value >= 0 ? value : 0;
    } catch (_) {
      return 0;
    }
  }

  function saveStoredCoins(value) {
    try {
      localStorage.setItem(COIN_STORAGE_KEY, String(Math.max(0, Math.floor(value))));
    } catch (_) {}
  }
  const DEFAULT_GROWTH = { hp: 0.32, mp: 0.1, atk: 0.2, spd: 0.18, def: 0.16, luc: 0.1 };
  const ENEMY_ARCHETYPES = {
    default: { hp: 1, atk: 1, def: 1, spd: 1, luc: 1, mp: 1 },
    slime: { hp: 1.1, atk: 0.9, def: 1.05, spd: 0.85, luc: 0.9, mp: 0.8 },
    bat: { hp: 0.85, atk: 0.9, def: 0.8, spd: 1.4, luc: 1.2, mp: 0.8 },
    golem: { hp: 1.3, atk: 1.1, def: 1.5, spd: 0.6, luc: 0.8, mp: 0.6 },
    mage: { hp: 1.0, atk: 1.0, def: 0.9, spd: 1.1, luc: 1.1, mp: 1.6 },
    assassin: { hp: 0.9, atk: 1.2, def: 0.85, spd: 1.4, luc: 1.2, mp: 0.8 },
    mimic: { hp: 1.1, atk: 1.05, def: 1.0, spd: 0.9, luc: 1.0, mp: 0.8 },
    hero: { hp: 1.05, atk: 1.05, def: 1.05, spd: 1.05, luc: 1.05, mp: 1.0 }
  };
  function buildStatsFromLevel(level, profile = ENEMY_ARCHETYPES.default) {
    const stats = {
      hp: 10 + 0.5 * level,
      atk: 2 + 0.2 * level,
      def: 1 + 0.15 * level,
      spd: 1 + 0.15 * level,
      luc: 1 + 0.05 * level,
      mp: 1 + 0.05 * level
    };
    return {
      hp: Math.max(MIN_HP, Math.round(stats.hp * profile.hp)),
      atk: Math.max(MIN_STAT, Math.round(stats.atk * profile.atk)),
      def: Math.max(MIN_STAT, Math.round(stats.def * profile.def)),
      spd: Math.max(MIN_STAT, Math.round(stats.spd * profile.spd)),
      luc: Math.max(MIN_STAT, Math.round(stats.luc * profile.luc)),
      mp: Math.max(MIN_STAT, Math.round(stats.mp * profile.mp))
    };
  }

  function getEnemyLevel(enemy) {
    const level = enemy.level ?? enemy.recommended ?? 1;
    return Math.max(1, Math.round(level));
  }

  function resolveEnemyStats(enemy) {
    const level = getEnemyLevel(enemy);
    const profile = ENEMY_ARCHETYPES[enemy.id] || ENEMY_ARCHETYPES.default;
    return buildStatsFromLevel(level, profile);
  }

  function generateNoiseField(scale) {
    const gridW = Math.ceil(MAP_SIZE / scale) + 2;
    const gridH = Math.ceil(MAP_SIZE / scale) + 2;
    const grid = Array.from({ length: gridH }, () =>
      Array.from({ length: gridW }, () => rand())
    );
    const lerp = (a, b, t) => a + (b - a) * t;
    return (x, y) => {
      const gx = x / scale;
      const gy = y / scale;
      const x0 = Math.floor(gx);
      const y0 = Math.floor(gy);
      const tx = gx - x0;
      const ty = gy - y0;
      const v00 = grid[y0]?.[x0] ?? 0;
      const v10 = grid[y0]?.[x0 + 1] ?? v00;
      const v01 = grid[y0 + 1]?.[x0] ?? v00;
      const v11 = grid[y0 + 1]?.[x0 + 1] ?? v00;
      const v0 = lerp(v00, v10, tx);
      const v1 = lerp(v01, v11, tx);
      return lerp(v0, v1, ty);
    };
  }

  function buildIslandMask() {
    if (MAP_SIZE <= 9) {
      return Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(true));
    }
    const land = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(false));
    const noise = generateNoiseField(7);
    const normX = (x) => x / (MAP_SIZE - 1);
    const normY = (y) => y / (MAP_SIZE - 1);
    const addEllipse = (cx, cy, rx, ry, rough = 0.2) => {
      const minX = Math.max(0, Math.floor((cx - rx - 0.06) * (MAP_SIZE - 1)));
      const maxX = Math.min(MAP_SIZE - 1, Math.ceil((cx + rx + 0.06) * (MAP_SIZE - 1)));
      const minY = Math.max(0, Math.floor((cy - ry - 0.06) * (MAP_SIZE - 1)));
      const maxY = Math.min(MAP_SIZE - 1, Math.ceil((cy + ry + 0.06) * (MAP_SIZE - 1)));
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const dx = (normX(x) - cx) / rx;
          const dy = (normY(y) - cy) / ry;
          const dist = dx * dx + dy * dy;
          const jitter = (noise(x, y) - 0.5) * rough;
          if (dist <= 1 + jitter) land[y][x] = true;
        }
      }
    };
    const carveEllipse = (cx, cy, rx, ry, rough = 0.15) => {
      const minX = Math.max(0, Math.floor((cx - rx - 0.04) * (MAP_SIZE - 1)));
      const maxX = Math.min(MAP_SIZE - 1, Math.ceil((cx + rx + 0.04) * (MAP_SIZE - 1)));
      const minY = Math.max(0, Math.floor((cy - ry - 0.04) * (MAP_SIZE - 1)));
      const maxY = Math.min(MAP_SIZE - 1, Math.ceil((cy + ry + 0.04) * (MAP_SIZE - 1)));
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const dx = (normX(x) - cx) / rx;
          const dy = (normY(y) - cy) / ry;
          const dist = dx * dx + dy * dy;
          const jitter = (noise(x, y) - 0.5) * rough;
          if (dist <= 1 + jitter) land[y][x] = false;
        }
      }
    };
    const drawBridge = (x1, y1, x2, y2, width = 1) => {
      const ax = Math.round(x1 * (MAP_SIZE - 1));
      const ay = Math.round(y1 * (MAP_SIZE - 1));
      const bx = Math.round(x2 * (MAP_SIZE - 1));
      const by = Math.round(y2 * (MAP_SIZE - 1));
      const dx = Math.abs(bx - ax);
      const dy = Math.abs(by - ay);
      const sx = ax < bx ? 1 : -1;
      const sy = ay < by ? 1 : -1;
      let err = dx - dy;
      let x = ax;
      let y = ay;
      while (true) {
        for (let oy = -width; oy <= width; oy++) {
          for (let ox = -width; ox <= width; ox++) {
            const nx = x + ox;
            const ny = y + oy;
            if (nx >= 0 && ny >= 0 && nx < MAP_SIZE && ny < MAP_SIZE) {
              land[ny][nx] = true;
            }
          }
        }
        if (x === bx && y === by) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
    };

    addEllipse(0.18, 0.28, 0.17, 0.12, 0.3);
    addEllipse(0.12, 0.18, 0.08, 0.06, 0.28);
    addEllipse(0.25, 0.42, 0.07, 0.06, 0.26);
    addEllipse(0.28, 0.35, 0.06, 0.08, 0.22);
    addEllipse(0.32, 0.12, 0.05, 0.03, 0.2);

    addEllipse(0.28, 0.63, 0.07, 0.18, 0.28);
    addEllipse(0.30, 0.80, 0.04, 0.10, 0.24);

    addEllipse(0.47, 0.28, 0.07, 0.05, 0.26);
    addEllipse(0.43, 0.24, 0.03, 0.03, 0.2);
    addEllipse(0.52, 0.20, 0.04, 0.06, 0.22);
    addEllipse(0.50, 0.34, 0.05, 0.03, 0.2);

    addEllipse(0.52, 0.58, 0.12, 0.22, 0.3);
    addEllipse(0.56, 0.72, 0.06, 0.12, 0.24);

    addEllipse(0.62, 0.46, 0.05, 0.07, 0.22);
    addEllipse(0.67, 0.52, 0.05, 0.08, 0.22);

    addEllipse(0.73, 0.30, 0.20, 0.12, 0.3);
    addEllipse(0.80, 0.38, 0.12, 0.07, 0.26);
    addEllipse(0.86, 0.32, 0.04, 0.05, 0.18);
    addEllipse(0.88, 0.34, 0.03, 0.05, 0.18);

    addEllipse(0.76, 0.56, 0.08, 0.06, 0.24);
    addEllipse(0.82, 0.60, 0.06, 0.04, 0.22);

    addEllipse(0.82, 0.76, 0.10, 0.07, 0.22);

    addEllipse(0.45, 0.12, 0.18, 0.03, 0.18);
    addEllipse(0.62, 0.14, 0.10, 0.03, 0.16);

    carveEllipse(0.25, 0.40, 0.05, 0.04, 0.16);
    carveEllipse(0.50, 0.32, 0.06, 0.03, 0.14);
    carveEllipse(0.58, 0.45, 0.03, 0.06, 0.14);
    carveEllipse(0.70, 0.45, 0.05, 0.03, 0.14);
    carveEllipse(0.62, 0.25, 0.05, 0.03, 0.12);

    drawBridge(0.26, 0.48, 0.28, 0.52, 1);
    drawBridge(0.56, 0.46, 0.60, 0.46, 1);
    drawBridge(0.78, 0.62, 0.82, 0.70, 1);
    drawBridge(0.86, 0.34, 0.84, 0.33, 1);

    let seed = null;
    for (let y = 0; y < MAP_SIZE && !seed; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (land[y][x]) { seed = { x, y }; break; }
      }
    }
    if (!seed) return land;

    const dirs = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    const floodMain = () => {
      const main = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(false));
      const queue = [{ x: seed.x, y: seed.y }];
      main[seed.y][seed.x] = true;
      while (queue.length) {
        const current = queue.shift();
        for (const [dx, dy] of dirs) {
          const nx = current.x + dx;
          const ny = current.y + dy;
          if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
          if (main[ny][nx] || !land[ny][nx]) continue;
          main[ny][nx] = true;
          queue.push({ x: nx, y: ny });
        }
      }
      return main;
    };
    const connectAllLand = () => {
      while (true) {
        const main = floodMain();
        let hasOther = false;
        for (let y = 0; y < MAP_SIZE && !hasOther; y++) {
          for (let x = 0; x < MAP_SIZE; x++) {
            if (land[y][x] && !main[y][x]) { hasOther = true; break; }
          }
        }
        if (!hasOther) break;

        const size = MAP_SIZE * MAP_SIZE;
        const parent = new Int32Array(size);
        const visited = new Uint8Array(size);
        parent.fill(-1);
        const queue = [];
        for (let y = 0; y < MAP_SIZE; y++) {
          for (let x = 0; x < MAP_SIZE; x++) {
            if (main[y][x]) {
              const key = x + y * MAP_SIZE;
              visited[key] = 1;
              parent[key] = key;
              queue.push({ x, y });
            }
          }
        }
        let target = null;
        while (queue.length && !target) {
          const current = queue.shift();
          for (const [dx, dy] of dirs) {
            const nx = current.x + dx;
            const ny = current.y + dy;
            if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
            const key = nx + ny * MAP_SIZE;
            if (visited[key]) continue;
            visited[key] = 1;
            parent[key] = current.x + current.y * MAP_SIZE;
            if (land[ny][nx] && !main[ny][nx]) {
              target = { x: nx, y: ny };
              break;
            }
            queue.push({ x: nx, y: ny });
          }
        }
        if (!target) break;
        let currentKey = target.x + target.y * MAP_SIZE;
        while (parent[currentKey] !== currentKey && parent[currentKey] !== -1) {
          const cx = currentKey % MAP_SIZE;
          const cy = Math.floor(currentKey / MAP_SIZE);
          land[cy][cx] = true;
          currentKey = parent[currentKey];
        }
      }
    };
    connectAllLand();
    return land;
  }

  function buildDistanceMap(start, landMask) {
    const size = MAP_SIZE * MAP_SIZE;
    const dist = new Int32Array(size);
    dist.fill(-1);
    const queue = new Int32Array(size);
    let head = 0;
    let tail = 0;
    const startKey = start.x + start.y * MAP_SIZE;
    dist[startKey] = 0;
    queue[tail++] = startKey;
    const neighbors = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    while (head < tail) {
      const key = queue[head++];
      const cx = key % MAP_SIZE;
      const cy = Math.floor(key / MAP_SIZE);
      const nextDist = dist[key] + 1;
      for (const [dx, dy] of neighbors) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
        if (!landMask[ny][nx]) continue;
        const nKey = nx + ny * MAP_SIZE;
        if (dist[nKey] !== -1) continue;
        dist[nKey] = nextDist;
        queue[tail++] = nKey;
      }
    }
    return dist;
  }

  function placeSpawnAndBase(landMask) {
    const candidates = [];
    const fallback = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (!landMask[y][x]) continue;
        const entry = { x, y, key: x + y * MAP_SIZE };
        fallback.push(entry);
        if (x < EDGE_MARGIN || y < EDGE_MARGIN || x >= MAP_SIZE - EDGE_MARGIN || y >= MAP_SIZE - EDGE_MARGIN) continue;
        candidates.push(entry);
      }
    }
    const pool = candidates.length ? candidates : fallback;
    if (!pool.length) return;
    const inSpawnRegion = (x, y) => {
      const nx = x / (MAP_SIZE - 1);
      const ny = y / (MAP_SIZE - 1);
      return nx >= SPAWN_REGION.xMin && nx <= SPAWN_REGION.xMax &&
        ny >= SPAWN_REGION.yMin && ny <= SPAWN_REGION.yMax;
    };
    const inBaseRegion = (x, y) => {
      const nx = x / (MAP_SIZE - 1);
      const ny = y / (MAP_SIZE - 1);
      return nx >= BASE_REGION.xMin && nx <= BASE_REGION.xMax &&
        ny >= BASE_REGION.yMin && ny <= BASE_REGION.yMax;
    };
    const spawnPool = pool.filter(entry => inSpawnRegion(entry.x, entry.y));
    const startPool = spawnPool.length ? spawnPool : pool;
    const basePool = pool.filter(entry => inBaseRegion(entry.x, entry.y));
    const targetPool = basePool.length ? basePool : pool;

    const size = MAP_SIZE * MAP_SIZE;
    const dist = new Int32Array(size);
    const queue = new Int32Array(size);
    const neighbors = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];

    let bestSpawn = startPool[0];
    let bestBase = targetPool[0];
    let bestDelta = Infinity;
    let bestDist = -1;

    for (const start of startPool) {
      dist.fill(-1);
      let head = 0;
      let tail = 0;
      dist[start.key] = 0;
      queue[tail++] = start.key;
      while (head < tail) {
        const key = queue[head++];
        const cx = key % MAP_SIZE;
        const cy = Math.floor(key / MAP_SIZE);
        const nextDist = dist[key] + 1;
        for (const [dx, dy] of neighbors) {
          const nx = cx + dx;
          const ny = cy + dy;
          if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
          if (!landMask[ny][nx]) continue;
          const nKey = nx + ny * MAP_SIZE;
          if (dist[nKey] !== -1) continue;
          dist[nKey] = nextDist;
          queue[tail++] = nKey;
        }
      }

      let foundExact = null;
      for (const end of targetPool) {
        const d = dist[end.key];
        if (d < 0) continue;
        if (d === TARGET_BASE_DISTANCE) {
          foundExact = end;
          break;
        }
        const delta = Math.abs(d - TARGET_BASE_DISTANCE);
        if (delta < bestDelta || (delta === bestDelta && d > bestDist)) {
          bestDelta = delta;
          bestDist = d;
          bestSpawn = start;
          bestBase = end;
        }
      }
      if (foundExact) {
        spawn = { x: start.x, y: start.y };
        heroBase = { x: foundExact.x, y: foundExact.y };
        return;
      }
    }

    spawn = { x: bestSpawn.x, y: bestSpawn.y };
    heroBase = { x: bestBase.x, y: bestBase.y };
  }

  function findPath(start, goal) {
    if (start.x === goal.x && start.y === goal.y) return [start];
    const size = MAP_SIZE * MAP_SIZE;
    const startKey = start.x + start.y * MAP_SIZE;
    const goalKey = goal.x + goal.y * MAP_SIZE;
    const cameFrom = new Int32Array(size);
    const gScore = new Float32Array(size);
    const fScore = new Float32Array(size);
    const inOpen = new Uint8Array(size);
    cameFrom.fill(-1);
    gScore.fill(Infinity);
    fScore.fill(Infinity);

    const heuristic = (x, y) => Math.abs(x - goal.x) + Math.abs(y - goal.y);
    gScore[startKey] = 0;
    fScore[startKey] = heuristic(start.x, start.y);
    const open = [startKey];
    inOpen[startKey] = 1;

    const neighbors = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];

    while (open.length) {
      let bestIndex = 0;
      let bestKey = open[0];
      let bestScore = fScore[bestKey];
      for (let i = 1; i < open.length; i++) {
        const key = open[i];
        const score = fScore[key];
        if (score < bestScore) {
          bestScore = score;
          bestKey = key;
          bestIndex = i;
        }
      }

      open.splice(bestIndex, 1);
      inOpen[bestKey] = 0;

      if (bestKey === goalKey) {
        const path = [];
        let current = bestKey;
        while (current !== -1) {
          const x = current % MAP_SIZE;
          const y = Math.floor(current / MAP_SIZE);
          path.push({ x, y });
          if (current === startKey) break;
          current = cameFrom[current];
        }
        path.reverse();
        return path;
      }

      const cx = bestKey % MAP_SIZE;
      const cy = Math.floor(bestKey / MAP_SIZE);
      for (const [dx, dy] of neighbors) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
        if (tiles[ny]?.[nx] === 'sea') continue;
        const nKey = nx + ny * MAP_SIZE;
        const tentative = gScore[bestKey] + 1;
        if (tentative < gScore[nKey]) {
          cameFrom[nKey] = bestKey;
          gScore[nKey] = tentative;
          fScore[nKey] = tentative + heuristic(nx, ny);
          if (!inOpen[nKey]) {
            inOpen[nKey] = 1;
            open.push(nKey);
          }
        }
      }
    }
    return null;
  }

  function pickTileType() {
    const roll = rand();
    let acc = 0;
    for (const entry of TILE_WEIGHTS) {
      acc += entry.weight;
      if (roll <= acc) return entry.id;
    }
    return 'neutral';
  }

  function shuffleList(list) {
    for (let i = list.length - 1; i > 0; i--) {
      const j = Math.floor(rand() * (i + 1));
      [list[i], list[j]] = [list[j], list[i]];
    }
    return list;
  }

  function getSideGroups(centerX, centerY) {
    const positions = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (x === centerX && y === centerY) continue;
        positions.push({ x, y });
      }
    }
    positions.sort((a, b) => (a.y - b.y) || (a.x - b.x));
    const half = Math.floor(positions.length / 2);
    return {
      top: positions.slice(0, half),
      bottom: positions.slice(half)
    };
  }

  function buildBalancedTiles(landMask, centerX, centerY) {
    const tilesOut = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill('sea'));
    const { top, bottom } = getSideGroups(centerX, centerY);
    const counts = {};
    COUNTABLE_TILE_IDS.forEach((id) => { counts[id] = 0; });

    const isSpecial = (x, y) =>
      (x === spawn.x && y === spawn.y) || (x === heroBase.x && y === heroBase.y);

    if (landMask[centerY]?.[centerX]) {
      tilesOut[centerY][centerX] = 'neutral';
    }

    top.forEach(({ x, y }) => {
      if (!landMask[y]?.[x]) {
        tilesOut[y][x] = 'sea';
        return;
      }
      if (isSpecial(x, y)) {
        tilesOut[y][x] = (x === spawn.x && y === spawn.y) ? 'spawn' : 'base';
        return;
      }
      const tileId = pickTileType();
      tilesOut[y][x] = tileId;
      if (counts[tileId] != null) counts[tileId] += 1;
    });

    const bottomTiles = [];
    COUNTABLE_TILE_IDS.forEach((id) => {
      for (let i = 0; i < counts[id]; i++) bottomTiles.push(id);
    });
    shuffleList(bottomTiles);
    let idx = 0;
    bottom.forEach(({ x, y }) => {
      if (!landMask[y]?.[x]) {
        tilesOut[y][x] = 'sea';
        return;
      }
      if (isSpecial(x, y)) {
        tilesOut[y][x] = (x === spawn.x && y === spawn.y) ? 'spawn' : 'base';
        return;
      }
      tilesOut[y][x] = bottomTiles[idx] || 'neutral';
      idx += 1;
    });

    return tilesOut;
  }

  function buildMainPath() {
    const path = [];
    let x = spawn.x;
    let y = spawn.y;
    path.push({ x, y });
    const leftBound = 1;
    const rightBound = MAP_SIZE - 2;
    let goRight = false;
    for (let row = spawn.y; row > 1; row--) {
      const targetX = goRight ? rightBound : leftBound;
      while (x !== targetX) {
        x += x < targetX ? 1 : -1;
        path.push({ x, y });
      }
      y -= 1;
      path.push({ x, y });
      goRight = !goRight;
    }
    while (x !== bossPos.x) {
      x += x < bossPos.x ? 1 : -1;
      path.push({ x, y });
    }
    y -= 1;
    path.push({ x, y });
    return path;
  }

  function pickEvenly(list, count) {
    if (!list.length || count <= 0) return [];
    const result = [];
    const step = Math.max(1, Math.floor(list.length / (count + 1)));
    let index = step;
    while (result.length < count && index < list.length) {
      result.push(list[index]);
      index += step;
    }
    let cursor = list.length - 1;
    while (result.length < count && cursor >= 0) {
      const candidate = list[cursor];
      if (!result.includes(candidate)) result.push(candidate);
      cursor -= 1;
    }
    return result.slice(0, count);
  }

  function buildDistanceFromSpawn() {
    const size = MAP_SIZE * MAP_SIZE;
    const dist = new Int32Array(size);
    dist.fill(-1);
    const queue = new Int32Array(size);
    let head = 0;
    let tail = 0;
    const startKey = spawn.x + spawn.y * MAP_SIZE;
    dist[startKey] = 0;
    queue[tail++] = startKey;
    const neighbors = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    while (head < tail) {
      const key = queue[head++];
      const cx = key % MAP_SIZE;
      const cy = Math.floor(key / MAP_SIZE);
      const nextDist = dist[key] + 1;
      for (const [dx, dy] of neighbors) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
        if (tiles[ny]?.[nx] === 'wall') continue;
        const nKey = nx + ny * MAP_SIZE;
        if (dist[nKey] !== -1) continue;
        dist[nKey] = nextDist;
        queue[tail++] = nKey;
      }
    }
    return dist;
  }

  function enforceBaseParamTileCaps(grid) {
    const used = { atk: 0, spd: 0, def: 0, hp: 0, luc: 0 };
    let total = 0;
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tileId = grid[y]?.[x];
        if (!STAT_TILE_IDS.includes(tileId)) continue;
        const typeCap = BASE_PARAM_TILE_CAPS[tileId] || 0;
        if (used[tileId] >= typeCap || total >= BASE_PARAM_TILE_LIMIT) {
          grid[y][x] = 'empty';
          continue;
        }
        used[tileId] += 1;
        total += 1;
      }
    }
    return { used, total };
  }

  function fillEmptyTilesInChunks(
    grid,
    chunkDefs,
    fillTileId = 'poison',
    perChunkLimit = Infinity,
    totalLimit = Infinity
  ) {
    if (!Array.isArray(chunkDefs) || !chunkDefs.length) return 0;
    let filled = 0;
    const canPlaceWithoutAdjacentMatch = (x, y) => {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
          if (grid[ny]?.[nx] === fillTileId) return false;
        }
      }
      return true;
    };
    for (const { col, row } of chunkDefs) {
      if (filled >= totalLimit) break;
      if (!Number.isFinite(col) || !Number.isFinite(row)) continue;
      const minX = col * CHUNK_SIZE;
      const maxX = Math.min(MAP_SIZE - 1, minX + CHUNK_SIZE - 1);
      const minY = row * CHUNK_SIZE;
      const maxY = Math.min(MAP_SIZE - 1, minY + CHUNK_SIZE - 1);
      let chunkFilled = 0;
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (chunkFilled >= perChunkLimit || filled >= totalLimit) break;
          if (grid[y]?.[x] !== 'empty') continue;
          if (!canPlaceWithoutAdjacentMatch(x, y)) continue;
          grid[y][x] = fillTileId;
          filled += 1;
          chunkFilled += 1;
        }
        if (chunkFilled >= perChunkLimit || filled >= totalLimit) break;
      }
    }
    return filled;
  }

  function clearTileTypeInChunk(grid, col, row, tileId = 'poison') {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return 0;
    const minX = col * CHUNK_SIZE;
    const maxX = Math.min(MAP_SIZE - 1, minX + CHUNK_SIZE - 1);
    const minY = row * CHUNK_SIZE;
    const maxY = Math.min(MAP_SIZE - 1, minY + CHUNK_SIZE - 1);
    let cleared = 0;
    for (let y = minY; y <= maxY; y++) {
      for (let x = minX; x <= maxX; x++) {
        if (grid[y]?.[x] !== tileId) continue;
        grid[y][x] = 'empty';
        cleared += 1;
      }
    }
    return cleared;
  }

  function assignEnemyOrder() {
    const dist = buildDistanceFromSpawn();
    const list = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const enemy = enemies[y]?.[x];
        if (!enemy) continue;
        const key = x + y * MAP_SIZE;
        const d = dist[key] < 0 ? 999 : dist[key];
        list.push({ x, y, d });
      }
    }
    list.sort((a, b) => (a.d - b.d) || (a.y - b.y) || (a.x - b.x));
    list.forEach((entry, idx) => {
      const order = idx + 1;
      const typeId = ENEMY_ORDER[idx] || ENEMY_TYPES[Math.floor(rand() * ENEMY_TYPES.length)].id;
      const baseEnemy = ENEMY_TYPES.find(enemy => enemy.id === typeId) || ENEMY_TYPES[0];
      enemies[entry.y][entry.x] = {
        ...baseEnemy,
        order,
        level: Math.max(0, order - 1),
        baseStats: { ...baseEnemy.stats }
      };
    });
  }

  function buildMap() {
    tiles = FIXED_MAP.map(row => row.slice());
    trailTileOwners = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(null));
    enemies = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(null));
    visited = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(false));
    skillTiles = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(null));
    revealedMimics = new Set();
    warpSelectionActive = false;
    enemyCount = 0;
    itemTileTotal = 0;

    spawn = { x: 0, y: MAP_SIZE - 1 };
    bossPos = { x: MAP_SIZE - 1, y: 0 };
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (tiles[y][x] === 'start') spawn = { x, y };
        if (tiles[y][x] === 'boss') bossPos = { x, y };
      }
    }
    healTileCount = 0;
    trapTileCount = 0;
    poisonTileCount = 0;
    treasureTileCount = 0;
    mimicTileCount = 0;
    FIXED_WALLS.forEach((entry) => {
      if (!tiles[entry.y]?.[entry.x]) return;
      if (entry.x === spawn.x && entry.y === spawn.y) return;
      if (entry.x === bossPos.x && entry.y === bossPos.y) return;
      tiles[entry.y][entry.x] = 'wall';
    });
    enforceBaseParamTileCaps(tiles);
    const bossChunkCol = Math.floor(bossPos.x / CHUNK_SIZE);
    const bossChunkRow = Math.floor(bossPos.y / CHUNK_SIZE);
    clearTileTypeInChunk(tiles, bossChunkCol, bossChunkRow, 'poison');
    const poisonChunks = POISON_FILL_CHUNKS.filter(({ col, row }) => (
      col !== bossChunkCol || row !== bossChunkRow
    ));
    fillEmptyTilesInChunks(tiles, poisonChunks, 'poison', 2, 4);
    FIXED_SKILL_TILES.forEach((entry) => {
      if (!tiles[entry.y]?.[entry.x]) return;
      if (entry.x === spawn.x && entry.y === spawn.y) return;
      if (entry.x === bossPos.x && entry.y === bossPos.y) return;
      tiles[entry.y][entry.x] = 'skill';
      if (skillTiles[entry.y]) skillTiles[entry.y][entry.x] = entry.skillId || null;
    });
    player.x = spawn.x;
    player.y = spawn.y;
    HERO_BOSS.baseStats = { ...HERO_BOSS.stats };

    FIXED_ENEMIES.forEach((entry, idx) => {
      const baseEnemy = ENEMY_TYPES.find(enemy => enemy.id === entry.id) || ENEMY_TYPES[0];
      if (!baseEnemy) return;
      tiles[entry.y][entry.x] = 'monster';
      enemies[entry.y][entry.x] = {
        ...baseEnemy,
        order: idx + 1,
        tier: 0,
        level: baseEnemy.level,
        baseStats: { ...baseEnemy.stats }
      };
      enemyCount += 1;
    });

    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tileId = tiles[y][x];
        if (tileId === 'treasure') {
          itemTileTotal += 1;
        }
      }
    }

    tiles[spawn.y][spawn.x] = 'start';
    tiles[bossPos.y][bossPos.x] = 'boss';
    updatePlayerLevel();
  }


  function placeOddTiles(tileId, count) {
    if (!count) return;
    const dist = buildDistanceFromSpawn();
    const candidates = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (tiles[y][x] !== 'empty') continue;
        if (x === spawn.x && y === spawn.y) continue;
        if (x === bossPos.x && y === bossPos.y) continue;
        const d = dist[x + y * MAP_SIZE];
        if (d < 0 || d % 2 !== 0) continue;
        candidates.push({ x, y });
      }
    }
    if (!candidates.length) return;
    shuffleList(candidates);
    const placeCount = Math.min(count, candidates.length);
    for (let i = 0; i < placeCount; i++) {
      const pos = candidates[i];
      tiles[pos.y][pos.x] = tileId;
    }
  }

  function placeStatTiles() {
    const dist = buildDistanceFromSpawn();
    const atkCandidates = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (tiles[y][x] !== 'empty') continue;
        if (x === spawn.x && y === spawn.y) continue;
        if (x === bossPos.x && y === bossPos.y) continue;
        const d = dist[x + y * MAP_SIZE];
        if (d < 0 || d % 2 !== 1) continue;
        const chunkType = getChunkType(x, y);
        if (!chunkType) continue;
        if (chunkType === 'atk') {
          atkCandidates.push({ x, y });
        } else {
          tiles[y][x] = chunkType;
        }
      }
    }
    if (!atkCandidates.length) return;
    shuffleList(atkCandidates);
    const count = Math.min(ATTACK_TILE_MAX, atkCandidates.length);
    for (let i = 0; i < count; i++) {
      const pos = atkCandidates[i];
      tiles[pos.y][pos.x] = 'atk';
    }
  }

  function applyRandomWalls() {
    const distBase = buildDistanceFromSpawn();
    const candidates = [];
    let baseAtkSlots = 0;
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (x === 0 || y === 0 || x === MAP_SIZE - 1 || y === MAP_SIZE - 1) continue;
        if (tiles[y][x] !== 'empty') continue;
        if (x === spawn.x && y === spawn.y) continue;
        if (x === bossPos.x && y === bossPos.y) continue;
        const d = distBase[x + y * MAP_SIZE];
        if (d < 0 || d % 2 !== 0) continue;
        candidates.push({ x, y });
      }
    }
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        if (tiles[y][x] !== 'empty') continue;
        const d = distBase[x + y * MAP_SIZE];
        if (d < 0 || d % 2 !== 1) continue;
        if (getChunkType(x, y) === 'atk') baseAtkSlots += 1;
      }
    }
    if (!candidates.length) return;
    const requiredAtkSlots = Math.min(ATTACK_TILE_MAX, baseAtkSlots);
    const maxWalls = Math.min(RANDOM_WALL_COUNT, candidates.length);
    const baseTiles = candidates.map(({ x, y }) => ({ x, y, tile: tiles[y][x] }));
    for (let attempt = 0; attempt < RANDOM_WALL_ATTEMPTS; attempt++) {
      shuffleList(candidates);
      const placed = [];
      for (let i = 0; i < maxWalls; i++) {
        const { x, y } = candidates[i];
        tiles[y][x] = 'wall';
        placed.push({ x, y });
      }
      const dist = buildDistanceFromSpawn();
      const bossKey = bossPos.x + bossPos.y * MAP_SIZE;
      const hasPath = dist[bossKey] >= 0;
      const hasMove = hasAvailableMoveAt(spawn.x, spawn.y);
      let evenSlots = 0;
      let atkSlots = 0;
      for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
          if (tiles[y][x] !== 'empty') continue;
          const d = dist[x + y * MAP_SIZE];
          if (d >= 0 && d % 2 === 0) evenSlots += 1;
          if (d >= 0 && d % 2 === 1 && getChunkType(x, y) === 'atk') atkSlots += 1;
        }
      }
      const evenNeeded = healTileCount + trapTileCount + poisonTileCount + treasureTileCount + mimicTileCount;
      if (hasPath && hasMove && evenSlots >= evenNeeded && atkSlots >= requiredAtkSlots) return;
      placed.forEach(({ x, y }) => { tiles[y][x] = 'empty'; });
    }
    baseTiles.forEach(({ x, y, tile }) => { tiles[y][x] = tile; });
  }

  function getChunkType(x, y) {
    const col = Math.floor(x / CHUNK_SIZE);
    const row = Math.floor(y / CHUNK_SIZE);
    if (row === 0 && col === 2) return 'atk'; // 3A
    if (row === 1 && col === 1) return 'atk'; // 2B
    if (row === 2 && col === 0) return 'atk'; // 1C
    if (row === 0 && col === 0) return 'luc'; // 1A
    if (row === 2 && col === 2) return 'spd'; // 3C
    if (row === 1 && col === 0) return 'hp'; // 1B
    if (row === 1 && col === 2) return 'hp'; // 3B
    if (row === 0 && col === 1) return 'def'; // 2A
    if (row === 2 && col === 1) return 'def'; // 2C
    return null;
  }

  function resizeCanvas() {
    const frame = mapCanvas.parentElement;
    if (!frame) return;
    const width = Math.max(0, frame.clientWidth - 12);
    const height = Math.max(0, frame.clientHeight - 12);
    const minSide = Math.max(0, Math.min(width, height));
    if (!minSide) return;
    const minTileSize = fullMapView ? 2 : 12;
    tileSize = Math.max(minTileSize, Math.floor(minSide / viewTiles));
    viewSizePx = tileSize * viewTiles;
    const dpr = window.devicePixelRatio || 1;
    mapCanvas.width = viewSizePx * dpr;
    mapCanvas.height = viewSizePx * dpr;
    mapCanvas.style.width = `${viewSizePx}px`;
    mapCanvas.style.height = `${viewSizePx}px`;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;
    renderMap();
  }

  function getCamera() {
    const half = Math.floor(viewTiles / 2);
    const maxX = MAP_SIZE - viewTiles;
    const maxY = MAP_SIZE - viewTiles;
    return {
      x: clamp(player.x - half, 0, maxX),
      y: clamp(player.y - half, 0, maxY)
    };
  }

  function getCameraInfo(posX, posY) {
    const half = Math.floor(viewTiles / 2);
    const maxX = MAP_SIZE - viewTiles;
    const maxY = MAP_SIZE - viewTiles;
    const topLeftX = clamp(posX - half, 0, maxX);
    const topLeftY = clamp(posY - half, 0, maxY);
    const baseX = Math.floor(topLeftX);
    const baseY = Math.floor(topLeftY);
    const offsetX = Math.round((topLeftX - baseX) * tileSize);
    const offsetY = Math.round((topLeftY - baseY) * tileSize);
    return { baseX, baseY, offsetX, offsetY };
  }

  function drawTileIcon(tileId, x, y, enemy) {
    const cx = x + tileSize / 2;
    const cy = y + tileSize / 2;
    const size = Math.max(6, Math.floor(tileSize * 0.38));
    const drawBadge = (label, bg = 'rgba(15, 23, 42, 0.75)') => {
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(cx, cy, size * 0.62, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f8fafc';
      ctx.font = `${Math.max(10, Math.floor(tileSize * 0.45))}px 'Fredoka'`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, cx, cy + 1);
    };
    switch (tileId) {
      case 'monster': {
        const label = ENEMY_TYPE_LABELS[enemy?.id] || '1';
        drawBadge(label);
        break;
      }
      case 'skill': {
        drawBadge('技');
        break;
      }
      case 'ice': {
        drawBadge('氷');
        break;
      }
      case 'key': {
        drawBadge('鍵');
        break;
      }
      case 'inn': {
        drawBadge('宿', 'rgba(13, 148, 136, 0.82)');
        break;
      }
      case 'weaponShop': {
        drawBadge('武', 'rgba(185, 28, 28, 0.82)');
        break;
      }
      case 'armorShop': {
        drawBadge('防', 'rgba(37, 99, 235, 0.82)');
        break;
      }
      case 'accessoryShop': {
        drawBadge('飾', 'rgba(161, 98, 7, 0.86)');
        break;
      }
      default:
        break;
    }
  }

  function drawTile(x, y, tileId, isVisited, enemy, skillId, mimicRevealed) {
    const tile = TILE_TYPES[tileId] || TILE_TYPES.empty;
    const baseSpriteKey = Object.prototype.hasOwnProperty.call(tileBaseSpriteMap, tileId)
      ? tileBaseSpriteMap[tileId]
      : tileBaseSpriteMap.empty;
    const baseSprite = baseSpriteKey ? tileSprites[baseSpriteKey] : null;
    let overlayKey = tileOverlaySpriteMap[tileId];
    if (tileId === 'skill' && skillId) {
      overlayKey = SKILL_SPRITE_KEYS[skillId] || overlayKey;
    }
    if (tileId === 'mimic' && !mimicRevealed) {
      overlayKey = tileOverlaySpriteMap.treasure || overlayKey;
    }
    const overlaySprite = overlayKey ? tileSprites[overlayKey] : null;
    ctx.fillStyle = tile.color;
    ctx.fillRect(x, y, tileSize, tileSize);
    if (baseSprite && baseSprite.complete && baseSprite.naturalWidth) {
      ctx.drawImage(baseSprite, x, y, tileSize, tileSize);
    }
    if (overlaySprite && overlaySprite.complete && overlaySprite.naturalWidth) {
      ctx.drawImage(overlaySprite, x, y, tileSize, tileSize);
    }
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 0.5, y + 0.5, tileSize - 1, tileSize - 1);
    if (
      tileId === 'monster'
      || (tileId === 'ice' && !overlaySprite)
      || (tileId === 'key' && !overlaySprite)
      || tileId === 'inn'
      || (tileId === 'weaponShop' && !overlaySprite)
      || (tileId === 'armorShop' && !overlaySprite)
      || (tileId === 'accessoryShop' && !overlaySprite)
      || (tileId === 'skill' && !overlaySprite)
    ) {
      drawTileIcon(tileId, x, y, enemy);
    }
  }

  function drawMarker(x, y, color, label) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x + tileSize / 2, y + tileSize / 2, Math.max(6, tileSize * 0.28), 0, Math.PI * 2);
    ctx.fill();
    if (label) {
      ctx.fillStyle = '#0b1224';
      ctx.font = `${Math.max(10, tileSize * 0.4)}px 'Fredoka'`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x + tileSize / 2, y + tileSize / 2 + 1);
    }
  }

  function setPlayerFacing(dx, dy) {
    if (dx > 0) playerFacing = 'right';
    else if (dx < 0) playerFacing = 'left';
    else if (dy > 0) playerFacing = 'down';
    else if (dy < 0) playerFacing = 'up';
  }

  function drawPlayer(x, y) {
    const sprite = playerSprites[playerFacing];
    if (sprite && sprite.complete && sprite.naturalWidth) {
      ctx.drawImage(sprite, Math.round(x), Math.round(y), tileSize, tileSize);
      return;
    }
    drawMarker(x, y, '#60a5fa', '魔');
  }

  function renderMap(offsets = null) {
    if (!tileSize) return;
    ctx.clearRect(0, 0, viewSizePx, viewSizePx);
    let offsetX = 0;
    let offsetY = 0;
    if (offsets && offsets.player) {
      offsetX = offsets.player.x || 0;
      offsetY = offsets.player.y || 0;
    } else if (isMoving && moveAnim && moveAnim.player) {
      offsetX = moveAnim.player.dx * moveAnim.progress;
      offsetY = moveAnim.player.dy * moveAnim.progress;
    }
    const posX = player.x + offsetX;
    const posY = player.y + offsetY;
    const camera = getCameraInfo(posX, posY);
    const drawCount = viewTiles + 1;
    for (let vy = 0; vy < drawCount; vy++) {
      const mapY = camera.baseY + vy;
      if (mapY < 0 || mapY >= MAP_SIZE) continue;
      const screenY = vy * tileSize - camera.offsetY;
      for (let vx = 0; vx < drawCount; vx++) {
        const mapX = camera.baseX + vx;
        if (mapX < 0 || mapX >= MAP_SIZE) continue;
        const tileId = tiles[mapY]?.[mapX] || 'empty';
        const enemy = enemies[mapY]?.[mapX];
        const skillId = skillTiles?.[mapY]?.[mapX] || null;
        const screenX = vx * tileSize - camera.offsetX;
        const isVisited = visited[mapY]?.[mapX];
        const mimicRevealed = tileId === 'mimic'
          ? revealedMimics.has(mapX + mapY * MAP_SIZE)
          : false;
        drawTile(screenX, screenY, tileId, isVisited, enemy, skillId, mimicRevealed);
      }
    }
    const px = (posX - camera.baseX) * tileSize - camera.offsetX;
    const py = (posY - camera.baseY) * tileSize - camera.offsetY;
    drawPlayer(px, py);
  }

  function clearRouteLogTyping() {
    routeLogQueue = [];
    routeLogBusy = false;
    if (routeLogTimer) {
      clearTimeout(routeLogTimer);
      routeLogTimer = null;
    }
  }

  function trimRouteLogNodes(log) {
    while (log.children.length > ROUTE_LOG_MAX_LINES) {
      log.removeChild(log.lastChild);
    }
  }

  function processRouteLogQueue() {
    if (!routeLogQueue.length) {
      routeLogBusy = false;
      routeLogTimer = null;
      return;
    }
    routeLogBusy = true;
    const text = String(routeLogQueue.shift() ?? '');
    const chars = Array.from(text);
    const targets = [footerLog, sheetLog].filter(Boolean);
    if (!targets.length) {
      routeLogBusy = false;
      routeLogTimer = null;
      return;
    }
    const lines = targets.map((log) => {
      const p = document.createElement('p');
      p.textContent = '';
      log.prepend(p);
      trimRouteLogNodes(log);
      return { log, p };
    });
    let cursor = 0;
    const typeNext = () => {
      if (cursor >= chars.length) {
        routeLogBusy = false;
        routeLogTimer = null;
        processRouteLogQueue();
        return;
      }
      const ch = chars[cursor];
      cursor += 1;
      lines.forEach(({ log, p }) => {
        p.textContent += ch;
        // prependで先頭に追加しているので先頭表示を維持する
        log.scrollTop = 0;
      });
      routeLogTimer = setTimeout(typeNext, ROUTE_LOG_CHAR_DELAY_MS);
    };
    if (!chars.length) {
      routeLogBusy = false;
      routeLogTimer = null;
      processRouteLogQueue();
      return;
    }
    typeNext();
  }

  function addLog(text) {
    const message = String(text ?? '');
    if (!message) return;
    routeLogQueue.push(message);
    if (!routeLogBusy) processRouteLogQueue();
  }

  function addCoins(amount, reason = '') {
    const gain = Math.max(0, Math.floor(amount));
    if (!gain) return;
    player.coins = (player.coins || 0) + gain;
    saveStoredCoins(player.coins);
    const suffix = reason ? `(${reason})` : '';
    addLog(`チャリン +${gain}${suffix}`);
  }

  function spendCoins(amount, reason = '') {
    const cost = Math.max(0, Math.floor(amount));
    if (!cost) return true;
    const current = player.coins || 0;
    if (current < cost) return false;
    player.coins = current - cost;
    saveStoredCoins(player.coins);
    const suffix = reason ? `(${reason})` : '';
    addLog(`チャリン -${cost}${suffix}`);
    return true;
  }

  function ensurePlayerShopState() {
    if (!player.shopLevels) player.shopLevels = createShopCounter();
    ['weapon', 'armor', 'accessory'].forEach((key) => {
      if (!Number.isFinite(player.shopLevels[key])) player.shopLevels[key] = 0;
    });
    if (!player.shopPurchased) player.shopPurchased = createShopPurchaseState();
    ['weapon', 'armor', 'accessory'].forEach((key) => {
      if (typeof player.shopPurchased[key] !== 'boolean') player.shopPurchased[key] = false;
    });
  }

  function getShopCost(shopKey) {
    ensurePlayerShopState();
    const base = SHOP_BASE_COSTS[shopKey] || 0;
    const growth = SHOP_COST_GROWTH[shopKey] || 0;
    const level = player.shopLevels?.[shopKey] || 0;
    return Math.max(0, base + growth * level);
  }

  function getShopVariantCost(shopKey, variant) {
    const add = Math.max(0, Math.floor(variant?.costAdd || 0));
    return getShopCost(shopKey) + add;
  }

  function formatShopBonusText(bonus = {}) {
    const order = ['atk', 'spd', 'def', 'hp', 'luc', 'mp'];
    const labels = {
      atk: 'こうげき',
      spd: 'はやさ',
      def: 'ぼうぎょ',
      hp: 'たいりょく',
      luc: 'うん',
      mp: 'まりょく'
    };
    const parts = [];
    order.forEach((key) => {
      const value = Number(bonus[key] || 0);
      if (!value) return;
      const label = labels[key] || key;
      parts.push(`${label}+${value}`);
    });
    return parts.join(' / ') || '効果なし';
  }

  function applyPermanentStatBonus(bonus = {}) {
    const safe = {
      atk: Math.max(0, Number(bonus.atk || 0)),
      spd: Math.max(0, Number(bonus.spd || 0)),
      def: Math.max(0, Number(bonus.def || 0)),
      hp: Math.max(0, Number(bonus.hp || 0)),
      luc: Math.max(0, Number(bonus.luc || 0)),
      mp: Math.max(0, Number(bonus.mp || 0))
    };
    player.baseStats.atk += safe.atk;
    player.baseStats.spd += safe.spd;
    player.baseStats.def += safe.def;
    player.baseStats.hp += safe.hp;
    player.baseStats.luc += safe.luc;
    player.baseStats.mp += safe.mp;
    if (safe.hp > 0) player.hp += safe.hp;
    if (safe.mp > 0) player.mp += safe.mp;
    return safe;
  }

  function buyShopVariant(shopKey, shopLabel, variant) {
    ensurePlayerShopState();
    if (!variant) return false;
    if (player.shopPurchased?.[shopKey]) {
      addLog(`${shopLabel}は売り切れ`);
      return false;
    }
    const cost = getShopVariantCost(shopKey, variant);
    if (!spendCoins(cost, shopLabel)) {
      addLog('チャリンが足りない');
      return false;
    }
    player.shopLevels[shopKey] = (player.shopLevels[shopKey] || 0) + 1;
    player.shopPurchased[shopKey] = true;
    const applied = applyPermanentStatBonus(variant.bonus);
    addLog(`${shopLabel}で${variant.name}を購入: ${formatShopBonusText(applied)} (この冒険中のみ)`);
    updateStats();
    return true;
  }

  function makeEventChoice(id, name, desc, meta = '', apply = null, iconTileKey = null) {
    return {
      id,
      name,
      desc,
      meta,
      apply,
      iconTileKey,
      choiceType: 'event',
      tags: [],
      subTags: []
    };
  }

  async function openEventChoices(title, subtitle, choices) {
    const options = Array.isArray(choices) ? choices.filter(Boolean) : [];
    if (!options.length) return null;
    return openSkillChoice(options, {
      title,
      subtitle,
      allowReroll: false,
      showTagGuide: false,
      onPick: (choice) => {
        if (typeof choice?.apply === 'function') {
          choice.apply();
        }
      },
      emptyLog: '選択肢がない'
    });
  }

  function applyInnRest() {
    const cost = INN_REST_COST;
    if (!spendCoins(cost, '宿屋')) {
      addLog('チャリンが足りない');
      return false;
    }
    const hpBefore = player.hp;
    const mpBefore = player.mp;
    const poisonBefore = player.poisonStacks;
    updateUnitStats(player);
    player.hp = player.maxHp;
    player.mp = player.maxMp;
    player.poisonStacks = 0;
    player.poisonSteps = 0;
    const hpGain = Math.max(0, player.hp - hpBefore);
    const mpGain = Math.max(0, player.mp - mpBefore);
    if (hpGain > 0 || mpGain > 0 || poisonBefore > 0) {
      addLog(`宿屋で休んだ: HP+${hpGain} MP+${mpGain} 毒解除`);
    } else {
      addLog('宿屋で休んだ (変化なし)');
    }
    updateStats();
    return true;
  }

  async function handleInnEvent() {
    const cost = INN_REST_COST;
    await openEventChoices('宿屋', `HP/MP全回復 + 毒解除 (${cost}チャリン)`, [
      makeEventChoice(
        'inn_rest',
        `休む (${cost})`,
        '状態異常とHP/MPを全回復する',
        '全回復',
        () => { applyInnRest(); },
        'tile13'
      ),
      makeEventChoice('inn_skip', '見送る', '今回は立ち寄らない', 'スキップ', () => {
        addLog('宿屋を見送った');
      }, 'tile9')
    ]);
  }

  async function handleWeaponShopEvent() {
    ensurePlayerShopState();
    if (player.shopPurchased.weapon) {
      addLog('ぶきやは売り切れ');
      return false;
    }
    const purchasedBefore = player.shopPurchased.weapon;
    const baseCost = getShopCost('weapon');
    const choices = SHOP_VARIANTS.weapon.map((variant) => {
      const cost = getShopVariantCost('weapon', variant);
      return makeEventChoice(
        `shop_weapon_${variant.id}`,
        `${variant.name} (${cost})`,
        formatShopBonusText(variant.bonus),
        'この冒険中のみ',
        () => { buyShopVariant('weapon', 'ぶきや', variant); },
        variant.iconTileKey || 'tile4'
      );
    });
    choices.push(makeEventChoice('shop_weapon_skip', '見送る', '今回は買わない', 'スキップ', () => {
      addLog('ぶきやを見送った');
    }, 'tile9'));
    await openEventChoices('ぶきや', `5種類から1つ購入 (基礎${baseCost}チャリン)`, choices);
    return !purchasedBefore && !!player.shopPurchased.weapon;
  }

  async function handleArmorShopEvent() {
    ensurePlayerShopState();
    if (player.shopPurchased.armor) {
      addLog('ぼうぐやは売り切れ');
      return false;
    }
    const purchasedBefore = player.shopPurchased.armor;
    const baseCost = getShopCost('armor');
    const choices = SHOP_VARIANTS.armor.map((variant) => {
      const cost = getShopVariantCost('armor', variant);
      return makeEventChoice(
        `shop_armor_${variant.id}`,
        `${variant.name} (${cost})`,
        formatShopBonusText(variant.bonus),
        'この冒険中のみ',
        () => { buyShopVariant('armor', 'ぼうぐや', variant); },
        variant.iconTileKey || 'tile2'
      );
    });
    choices.push(makeEventChoice('shop_armor_skip', '見送る', '今回は買わない', 'スキップ', () => {
      addLog('ぼうぐやを見送った');
    }, 'tile9'));
    await openEventChoices('ぼうぐや', `5種類から1つ購入 (基礎${baseCost}チャリン)`, choices);
    return !purchasedBefore && !!player.shopPurchased.armor;
  }

  async function handleAccessoryShopEvent() {
    ensurePlayerShopState();
    if (player.shopPurchased.accessory) {
      addLog('ほうしょくやは売り切れ');
      return false;
    }
    const purchasedBefore = player.shopPurchased.accessory;
    const baseCost = getShopCost('accessory');
    const choices = SHOP_VARIANTS.accessory.map((variant) => {
      const cost = getShopVariantCost('accessory', variant);
      return makeEventChoice(
        `shop_accessory_${variant.id}`,
        `${variant.name} (${cost})`,
        formatShopBonusText(variant.bonus),
        'この冒険中のみ',
        () => { buyShopVariant('accessory', 'ほうしょくや', variant); },
        variant.iconTileKey || 'tile26'
      );
    });
    choices.push(makeEventChoice('shop_accessory_skip', '見送る', '今回は買わない', 'スキップ', () => {
      addLog('ほうしょくやを見送った');
    }, 'tile9'));
    await openEventChoices('ほうしょくや', `5種類から1つ購入 (基礎${baseCost}チャリン)`, choices);
    return !purchasedBefore && !!player.shopPurchased.accessory;
  }

  let selectedSkillId = null;
  let selectedGearId = null;
  const ROUTE_LOG_MAX_LINES = 6;
  const ROUTE_LOG_CHAR_DELAY_MS = 18;
  let routeLogQueue = [];
  let routeLogBusy = false;
  let routeLogTimer = null;

  function getSkillMainTag(skill) {
    const tags = Array.isArray(skill?.tags) ? skill.tags : [];
    const tag = tags[0] || null;
    return TAG_IDS.includes(tag) ? tag : null;
  }

  function getSkillSubTags(skill) {
    const main = getSkillMainTag(skill);
    const subs = Array.isArray(skill?.subTags) ? skill.subTags : [];
    return Array.from(new Set(subs.filter(tag => TAG_IDS.includes(tag) && tag !== main)));
  }

  function getSkillAllTags(skill) {
    const list = [];
    const main = getSkillMainTag(skill);
    if (main) list.push(main);
    getSkillSubTags(skill).forEach((tag) => {
      if (!list.includes(tag)) list.push(tag);
    });
    return list;
  }

  function formatTagLabel(tag) {
    return TAG_LABELS[tag] || tag;
  }

  function formatSkillTags(skill) {
    const main = getSkillMainTag(skill);
    const sub = getSkillSubTags(skill);
    if (!main) return 'タグなし';
    if (!sub.length) return `主: ${formatTagLabel(main)}`;
    return `主: ${formatTagLabel(main)} / 副: ${sub.map(formatTagLabel).join(', ')}`;
  }

  function formatSkillTagGainPreview(skill) {
    ensurePlayerProgressState();
    const tags = getSkillAllTags(skill);
    if (!tags.length) return 'タグ加算なし';
    return tags.map((tag) => {
      const current = player.tagCounts?.[tag] || 0;
      const next = current + 1;
      if (player.awakenedTags?.[tag]) return `${formatTagLabel(tag)} +1`;
      if (next >= AWAKEN_THRESHOLD) return `${formatTagLabel(tag)} ${current}->${next} (覚醒)`;
      return `${formatTagLabel(tag)} ${current}->${next}`;
    }).join(' / ');
  }

  function renderTagProgressHtml(previewSkill = null) {
    ensurePlayerProgressState();
    const previewTags = previewSkill ? getSkillAllTags(previewSkill) : [];
    const cards = TAG_IDS.map((tag) => {
      const current = player.tagCounts?.[tag] || 0;
      const willGain = previewTags.includes(tag) ? 1 : 0;
      const next = current + willGain;
      const awakened = !!player.awakenedTags?.[tag];
      const willAwaken = !awakened && next >= AWAKEN_THRESHOLD;
      const cls = `tag-progress-item${awakened ? ' is-awakened' : ''}${willAwaken ? ' is-ready' : ''}`;
      const progressText = awakened
        ? '覚醒済み'
        : `${current}/${AWAKEN_THRESHOLD}${willGain ? ` -> ${next}/${AWAKEN_THRESHOLD}` : ''}`;
      const effectText = getAwakenDescription(tag);
      return `<div class="${cls}"><strong>${formatTagLabel(tag)}</strong><small>${progressText}</small><small>${effectText}</small></div>`;
    }).join('');
    return `<div class="tag-progress">${cards}</div>`;
  }

  function showSkillDetail(skill) {
    if (!skillDetailEl) return;
    if (!skill) {
      skillDetailEl.innerHTML = `
        <strong>タグ進行</strong>
        <div class="skill-meta-line">同タグを3つ集めると覚醒します</div>
        ${renderTagProgressHtml(null)}
      `;
      return;
    }
    const owned = player.skills?.[skill.id];
    const mainTag = getSkillMainTag(skill);
    const subTags = getSkillSubTags(skill);
    skillDetailEl.innerHTML = `
      <strong>${skill.name}</strong>
      <div>${skill.desc}</div>
      <div class="skill-meta-line">タグ: ${formatSkillTags(skill)}</div>
      <div class="skill-meta-line">取得時: ${formatSkillTagGainPreview(skill)}</div>
      <div class="skill-meta-line">主タグ効果: ${mainTag ? getAwakenDescription(mainTag) : 'なし'}</div>
      ${subTags.length ? `<div class="skill-meta-line">副タグ効果: ${subTags.map(tag => getAwakenDescription(tag)).join(' / ')}</div>` : ''}
      <div>${owned ? '習得済み' : '未習得'}</div>
      ${renderTagProgressHtml(skill)}
    `;
  }

  function renderSkillList() {
    if (!skillListEl || !skillDetailEl) return;
    skillListEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    SKILL_DEFS.forEach((skill) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      const unlocked = !!player.skills?.[skill.id];
      btn.className = `icon-item${unlocked ? ' is-unlocked' : ' is-locked'}${selectedSkillId === skill.id ? ' is-selected' : ''}`;
      const spritePath = SKILL_SPRITE_PATHS[skill.id];
      if (spritePath) btn.style.setProperty('--icon-image', `url(${spritePath})`);
      btn.setAttribute('aria-label', skill.name);
      btn.title = skill.name;
      btn.addEventListener('click', () => {
        selectedSkillId = skill.id;
        showSkillDetail(skill);
        renderSkillList();
      });
      fragment.appendChild(btn);
    });
    skillListEl.appendChild(fragment);
    const fallback = SKILL_DEFS.find(skill => player.skills?.[skill.id]) || SKILL_DEFS[0];
    if (!selectedSkillId) {
      selectedSkillId = fallback?.id || null;
    }
    if (selectedSkillId) {
      const selected = SKILL_DEFS.find(skill => skill.id === selectedSkillId) || fallback;
      if (selected) showSkillDetail(selected);
    } else {
      showSkillDetail(null);
    }
  }

  function getBaseStats() {
    const base = player.baseStats || BASE_STATS;
    return {
      atk: base.atk,
      spd: base.spd,
      def: base.def,
      luc: base.luc
    };
  }

  function getGearRarity(id) {
    return GEAR_RARITIES.find(rarity => rarity.id === id) || GEAR_RARITIES[0];
  }

  function getRarityWeights(luc) {
    const base = { N: 50, HR: 25, SR: 12, SSR: 7, UR: 4, L: 2 };
    const boost = Math.min(30, Math.floor(luc * 1.2));
    const addHR = Math.floor(boost * 0.4);
    const addSR = Math.floor(boost * 0.3);
    const addSSR = Math.floor(boost * 0.18);
    const addUR = Math.floor(boost * 0.08);
    const addL = boost - addHR - addSR - addSSR - addUR;
    base.N = Math.max(5, base.N - (addHR + addSR + addSSR + addUR + addL));
    base.HR += addHR;
    base.SR += addSR;
    base.SSR += addSSR;
    base.UR += addUR;
    base.L += addL;
    return base;
  }

  function rollGearRarity(luc) {
    const weights = getRarityWeights(luc);
    let roll = Math.random() * 100;
    for (const rarityId of GEAR_RARITY_ORDER) {
      roll -= weights[rarityId];
      if (roll <= 0) return rarityId;
    }
    return 'N';
  }


  function calcAccessoryBonus(baseStats, rarity) {
    const calc = (value) => Math.round(value * rarity.factor);
    return {
      atk: Math.max(rarity.min, calc(baseStats.atk)),
      spd: Math.max(rarity.min, calc(baseStats.spd)),
      def: Math.max(rarity.min, calc(baseStats.def)),
      luc: Math.max(rarity.min, calc(baseStats.luc))
    };
  }

  function buildAccessory(rarityId) {
    const rarity = getGearRarity(rarityId);
    const baseStats = getBaseStats();
    const bonus = calcAccessoryBonus(baseStats, rarity);
    return {
      id: `acc-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      name: `${rarity.label}装飾品`,
      rarity: rarity.id,
      color: rarity.color,
      bonus
    };
  }

  function buildHeroGear() {
    const rarity = getGearRarity('L');
    const baseStats = getBaseStats();
    const bonus = calcAccessoryBonus(baseStats, rarity);
    return {
      id: `hero-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      name: '対勇者装備',
      rarity: rarity.id,
      color: HERO_BOSS.color,
      bonus
    };
  }

  function getGearScore(gear) {
    if (!gear) return 0;
    return gear.bonus.atk + gear.bonus.spd + gear.bonus.def + gear.bonus.luc;
  }

  function shouldAutoEquip(gear) {
    if (!gear) return false;
    if (!player.gear.accessory) return true;
    const current = player.gear.accessory;
    const rankNew = GEAR_RARITY_ORDER.indexOf(gear.rarity);
    const rankOld = GEAR_RARITY_ORDER.indexOf(current.rarity);
    if (rankNew !== rankOld) return rankNew > rankOld;
    return getGearScore(gear) > getGearScore(current);
  }

  function equipAccessory(gear) {
    if (!gear) return;
    player.gearBonus = { ...gear.bonus };
    player.gear.accessory = gear;
    updateUnitStats(player);
  }

  function showGearDetail(gear) {
    if (!gearDetailEl) return;
    if (!gear) {
      gearDetailEl.textContent = '装備はまだありません。';
      return;
    }
    const equipped = player.gear.accessory && player.gear.accessory.id === gear.id;
    gearDetailEl.innerHTML = `
      <strong>${gear.name}</strong>
      <div>レアリティ: ${gear.rarity}</div>
      <div>効果: こうげき+${gear.bonus.atk} / はやさ+${gear.bonus.spd} / ぼうぎょ+${gear.bonus.def} / うん+${gear.bonus.luc}</div>
      <div>状態: ${equipped ? '装備中' : '未装備'}</div>
      <div>所持数: ${player.gearInventory.length}</div>
    `;
  }

  function renderGearList() {
    if (!gearListEl || !gearDetailEl) return;
    gearListEl.innerHTML = '';
    const items = [...player.gearInventory].sort((a, b) => {
      const rankA = GEAR_RARITY_ORDER.indexOf(a.rarity);
      const rankB = GEAR_RARITY_ORDER.indexOf(b.rarity);
      if (rankA !== rankB) return rankB - rankA;
      return a.id.localeCompare(b.id);
    });
    if (!items.length) {
      showGearDetail(null);
      return;
    }
    if (!selectedGearId || !items.find(item => item.id === selectedGearId)) {
      selectedGearId = (player.gear.accessory && player.gear.accessory.id) || items[0].id;
    }
    const fragment = document.createDocumentFragment();
    items.forEach((gear) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = `icon-item${selectedGearId === gear.id ? ' is-selected' : ''}`;
      btn.style.setProperty('--icon-color', gear.color);
      btn.setAttribute('aria-label', gear.name);
      btn.title = gear.name;
      btn.addEventListener('click', () => {
        equipAccessory(gear);
        selectedGearId = gear.id;
        updateStats();
      });
      fragment.appendChild(btn);
    });
    gearListEl.appendChild(fragment);
    const selected = items.find(item => item.id === selectedGearId) || items[0];
    showGearDetail(selected);
  }

  function handleEnemyDrop(enemyState) {
    if (enemyState.id === 'mimic') {
      addLog('ミミックを倒した');
    }
  }

  function updateStats() {
    updateUnitStats(player);
    updatePlayerLevel();
    const hpText = `${player.hp} / ${player.maxHp}`;
    const mpText = `${player.mp} / ${player.maxMp}`;
    const shieldText = player.shield > 0 ? `+${player.shield}` : '0';
    const damageText = `${player.bossDamage}`;
    const itemText = itemTileTotal > 0 ? `${player.itemsCollected}/${itemTileTotal}` : `${player.itemsCollected}`;
    const poisonText = player.poisonStacks > 0 ? `${player.poisonStacks}(${player.poisonSteps}歩)` : 'なし';
    const setText = (el, value) => { if (el) el.textContent = value; };

    setText(statsEl.hp, hpText);
    setText(statsEl.mp, mpText);
    setText(statsEl.atk, `${player.atk}`);
    setText(statsEl.spd, `${player.spd}`);
    setText(statsEl.def, `${player.def}`);
    setText(statsEl.luc, `${player.luc}`);
    setText(statsEl.level, `${player.level}`);
    setText(statsEl.exp, damageText);
    setText(statsEl.items, itemText);
    setText(statsEl.coins, `${player.coins ?? 0}`);
    setText(statsEl.steps, `${player.steps}`);
    setText(statsEl.kills, `${player.kills}`);
    setText(statsEl.poison, poisonText);

    setText(sheetStatsEl.hp, hpText);
    setText(sheetStatsEl.mp, mpText);
    setText(sheetStatsEl.atk, `${player.atk}`);
    setText(sheetStatsEl.spd, `${player.spd}`);
    setText(sheetStatsEl.def, `${player.def}`);
    setText(sheetStatsEl.luc, `${player.luc}`);
    setText(sheetStatsEl.level, `${player.level}`);
    setText(sheetStatsEl.exp, damageText);
    setText(sheetStatsEl.items, itemText);
    setText(sheetStatsEl.coins, `${player.coins ?? 0}`);
    setText(sheetStatsEl.steps, `${player.steps}`);
    setText(sheetStatsEl.kills, `${player.kills}`);
    setText(sheetStatsEl.poison, poisonText);

    setText(hudStatsEl.hp, hpText);
    setText(hudStatsEl.mp, mpText);
    setText(hudStatsEl.shield, shieldText);
    setText(hudStatsEl.atk, `${player.atk}`);
    setText(hudStatsEl.spd, `${player.spd}`);
    setText(hudStatsEl.def, `${player.def}`);
    setText(hudStatsEl.luc, `${player.luc}`);
    setText(hudStatsEl.level, `${player.level}`);
    setText(hudStatsEl.exp, damageText);
    setText(hudStatsEl.items, itemText);
    setText(hudStatsEl.coins, `${player.coins ?? 0}`);
    setText(hudStatsEl.steps, `${player.steps}`);
    setText(hudStatsEl.kills, `${player.kills}`);
    setText(hudStatsEl.poison, poisonText);

    if (hpBar) {
      const hpRate = player.maxHp ? (player.hp / player.maxHp) * 100 : 0;
      hpBar.style.width = `${clamp(hpRate, 0, 100)}%`;
    }
    if (mpBar) {
      const mpRate = player.maxMp ? (player.mp / player.maxMp) * 100 : 0;
      mpBar.style.width = `${clamp(mpRate, 0, 100)}%`;
    }
    if (shieldBar) {
      const shieldRate = player.maxHp ? (player.shield / player.maxHp) * 100 : 0;
      shieldBar.style.width = `${clamp(shieldRate, 0, 100)}%`;
    }
    updateMapReadouts();
    renderSkillList();
    renderGearList();
  }

  function isTileBlocked(tileId) {
    return !tileId || BLOCKING_TILE_IDS.has(tileId);
  }

  function countAvailableMovesAt(x, y, grid = tiles) {
    const dirs = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    let count = 0;
    for (const [dx, dy] of dirs) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
      const tileId = grid[ny]?.[nx];
      if (isTileBlocked(tileId)) continue;
      count += 1;
    }
    return count;
  }

  function buildRouteStateInfo(startX = player.x, startY = player.y) {
    const counts = {};
    ROUTE_FOCUS_TILE_ORDER.forEach((tileId) => { counts[tileId] = 0; });
    const distMap = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(-1));
    const startTile = tiles[startY]?.[startX];
    if (isTileBlocked(startTile)) {
      return {
        counts,
        branchChoices: 0,
        bossReachable: false,
        bossDist: -1,
        itemReachable: 0,
        statReachable: 0,
        monsterReachable: 0
      };
    }
    const queue = [{ x: startX, y: startY }];
    let head = 0;
    distMap[startY][startX] = 0;
    const dirs = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    while (head < queue.length) {
      const current = queue[head++];
      const currentDist = distMap[current.y][current.x];
      const tileId = tiles[current.y]?.[current.x];
      if (Object.prototype.hasOwnProperty.call(counts, tileId)) {
        counts[tileId] += 1;
      }
      for (const [dx, dy] of dirs) {
        const nx = current.x + dx;
        const ny = current.y + dy;
        if (nx < 0 || ny < 0 || nx >= MAP_SIZE || ny >= MAP_SIZE) continue;
        if (distMap[ny][nx] !== -1) continue;
        const nextTile = tiles[ny]?.[nx];
        if (isTileBlocked(nextTile)) continue;
        distMap[ny][nx] = currentDist + 1;
        queue.push({ x: nx, y: ny });
      }
    }
    const bossDist = distMap[bossPos.y]?.[bossPos.x] ?? -1;
    const itemReachable = (counts.treasure || 0) + (counts.mimic || 0) + (counts.key || 0);
    const statReachable = (counts.atk || 0) + (counts.spd || 0) + (counts.def || 0) + (counts.hp || 0) + (counts.luc || 0);
    const monsterReachable = counts.monster || 0;
    return {
      counts,
      branchChoices: countAvailableMovesAt(startX, startY),
      bossReachable: bossDist >= 0,
      bossDist,
      itemReachable,
      statReachable,
      monsterReachable
    };
  }

  function formatRouteFocusCounts(counts) {
    const parts = [];
    ROUTE_FOCUS_TILE_ORDER.forEach((tileId) => {
      const value = counts?.[tileId] || 0;
      if (value <= 0) return;
      const label = ROUTE_FOCUS_TILE_LABELS[tileId] || tileId;
      parts.push(`${label}${value > 1 ? `x${value}` : ''}`);
    });
    return parts.length ? parts.join(' ') : 'なし';
  }

  function maybeLogRouteInsight(pruneSummary = null) {
    return;
  }

  function getActiveStatModeText() {
    if (!STAT_TILE_IDS.includes(player.activeStatMode)) return 'なし';
    return STAT_COMBO_LABELS[player.activeStatMode] || player.activeStatMode;
  }

  function getTrailStatSummaryText() {
    const parts = STAT_TILE_IDS.map((stat) => {
      const label = STAT_COMBO_LABELS[stat] || stat;
      const count = player.trailStatCounts?.[stat] || 0;
      return `${label}${count}`;
    });
    return parts.join(' ');
  }

  function updateMapReadouts() {
    if (!mapStatus && !baseDirection) return;
    const info = buildRouteStateInfo(player.x, player.y);
    const dist = Math.abs(player.x - bossPos.x) + Math.abs(player.y - bossPos.y);
    const statusText = `歩数: ${player.steps} / 残り敵: ${enemyCount} / 分岐: ${info.branchChoices} / 到達: 宝${info.itemReachable} 強${info.statReachable} / モード:${getActiveStatModeText()} / 路:${getTrailStatSummaryText()}`;
    if (mapStatus) mapStatus.textContent = statusText;
    if (baseDirection) {
      const dir = getDirectionInfo(bossPos.x - player.x, bossPos.y - player.y);
      baseDirection.textContent = `ボス方向: ${dir.arrow} ${dir.label} (${dist}マス)`;
    }
  }

  function getDirectionInfo(dx, dy) {
    if (dx === 0 && dy === 0) {
      return { label: '到達', arrow: '◎' };
    }
    const angle = Math.atan2(dy, dx);
    const steps = [
      { label: '東', arrow: '→' },
      { label: '南東', arrow: '↘' },
      { label: '南', arrow: '↓' },
      { label: '南西', arrow: '↙' },
      { label: '西', arrow: '←' },
      { label: '北西', arrow: '↖' },
      { label: '北', arrow: '↑' },
      { label: '北東', arrow: '↗' }
    ];
    const index = (Math.round(angle / (Math.PI / 4)) + steps.length) % steps.length;
    return steps[index];
  }

  function updateViewToggleLabel() {
    if (!toggleViewBtn) return;
    toggleViewBtn.textContent = fullMapView ? '通常表示' : '全体表示';
  }

  function setViewMode(isFull) {
    fullMapView = Boolean(isFull);
    viewTiles = fullMapView ? MAP_SIZE : NORMAL_VIEW_TILES;
    updateViewToggleLabel();
    resizeCanvas();
    renderMap();
  }

  function updateUnitStats(unit) {
    const base = unit.baseStats || BASE_STATS;
    const gearBonus = unit === player ? unit.gearBonus : { atk: 0, spd: 0, def: 0, luc: 0 };
    unit.atk = Math.max(MIN_STAT, base.atk + gearBonus.atk);
    unit.spd = Math.max(MIN_STAT, base.spd + gearBonus.spd);
    unit.def = Math.max(MIN_STAT, base.def + gearBonus.def);
    unit.luc = Math.max(MIN_STAT, base.luc + gearBonus.luc);
    unit.maxHp = Math.max(MIN_HP, base.hp);
    unit.hp = clamp(unit.hp ?? unit.maxHp, 0, unit.maxHp);
    unit.maxMp = Math.max(MIN_STAT, base.mp);
    unit.mp = clamp(unit.mp ?? unit.maxMp, 0, unit.maxMp);
  }

  function createMimicEnemy() {
    const baseEnemy = ENEMY_TYPES.find(enemy => enemy.id === 'mimic') || ENEMY_TYPES[0];
    return {
      ...baseEnemy,
      order: 0,
      tier: 0,
      level: 0,
      baseStats: { ...baseEnemy.stats }
    };
  }

  function updateBossBattleLabel(enemyState) {
    battleSub.textContent = `Lv ${enemyState.level} / 現在 ${player.level}`;
  }

  function syncBossStats(enemyState) {
    const level = Math.max(1, enemyState.level || 1);
    enemyState.atk = Math.max(MIN_STAT, Math.round(HERO_BOSS.stats.atk + (level - 1) * BOSS_GROWTH.atk));
    enemyState.def = Math.max(MIN_STAT, Math.round(HERO_BOSS.stats.def + (level - 1) * BOSS_GROWTH.def));
    enemyState.spd = Math.max(MIN_STAT, Math.round(HERO_BOSS.stats.spd + (level - 1) * BOSS_GROWTH.spd));
    enemyState.luc = Math.max(MIN_STAT, Math.round(HERO_BOSS.stats.luc + (level - 1) * BOSS_GROWTH.luc));
    enemyState.mp = Math.max(MIN_STAT, Math.round(HERO_BOSS.stats.mp + (level - 1) * BOSS_GROWTH.mp));
    if (enemyState.maxMp == null) enemyState.maxMp = enemyState.mp;
    if (enemyState.mp > enemyState.maxMp) enemyState.maxMp = enemyState.mp;
  }

  function applyBossDamage(enemyState, damage) {
    let remaining = damage;
    let leveledUp = false;
    while (remaining > 0) {
      const chunk = Math.min(remaining, enemyState.hp);
      enemyState.hp -= chunk;
      player.bossDamage += chunk;
      remaining -= chunk;
      if (enemyState.hp <= 0) {
        enemyState.level += 1;
        enemyState.maxHp = enemyState.level * BOSS_HP_PER_LEVEL;
        enemyState.hp = enemyState.maxHp;
        syncBossStats(enemyState);
        leveledUp = true;
        appendBattleLog(`勇者がLv${enemyState.level}に強化された`, 'enemy');
      }
    }
    if (leveledUp) enemyState.bossLevelUp = true;
    updateBossBattleLabel(enemyState);
  }

  async function resolveBossBattle() {
    const boss = {
      ...HERO_BOSS,
      level: 1,
      order: 0,
      baseStats: { ...HERO_BOSS.stats }
    };
    await runBattle(boss, { actor: player, actorLabel: '魔王様', allowDefeat: true, isBoss: true });
  }

  function updatePlayerLevel() {
    const levelFromStats = 1
      + (player.atk - BASE_STATS.atk)
      + (player.def - BASE_STATS.def)
      + (player.spd - BASE_STATS.spd)
      + (player.luc - BASE_STATS.luc)
      + (player.maxHp - BASE_STATS.hp);
    player.level = Math.max(1, levelFromStats);
  }

  function getTrailStatGainPerTile(statKey) {
    if (!STAT_TILE_IDS.includes(statKey)) return 0;
    let gain = TRAIL_STAT_BASE_GAINS[statKey] || 1;
    if (player.skills?.trailDouble) gain *= 2;
    return gain;
  }

  function refreshTrailStatCollected() {
    player.statTilesCollected = STAT_TILE_IDS.reduce((sum, stat) => {
      return sum + Math.max(0, player.trailStatCounts?.[stat] || 0);
    }, 0);
  }

  function applyTrailStatDelta(statKey, tileDelta) {
    if (!STAT_TILE_IDS.includes(statKey)) return;
    if (!Number.isFinite(tileDelta) || tileDelta === 0) return;
    const perTile = getTrailStatGainPerTile(statKey);
    if (perTile <= 0) return;
    const current = player.trailStatCounts?.[statKey] || 0;
    const next = Math.max(0, current + tileDelta);
    const appliedDelta = next - current;
    if (!appliedDelta) return;
    player.trailStatCounts[statKey] = next;
    player.baseStats[statKey] = (player.baseStats[statKey] || 0) + appliedDelta * perTile;
    if (statKey === 'hp' && appliedDelta > 0) {
      player.hp += appliedDelta * perTile;
    }
    refreshTrailStatCollected();
    updateUnitStats(player);
    updatePlayerLevel();
  }

  function setActiveStatMode(statKey, label) {
    if (!STAT_TILE_IDS.includes(statKey)) return;
    const switched = player.activeStatMode !== statKey;
    player.activeStatMode = statKey;
    if (switched) {
      addLog(`${label}モードに切替`);
    }
  }

  function canPaintTrailTile(tileId) {
    return Boolean(tileId) && !TRAIL_IMMUNE_TILE_IDS.has(tileId);
  }

  function applyTrailModeToTile(x, y) {
    const statKey = player.activeStatMode;
    if (!STAT_TILE_IDS.includes(statKey)) return;
    if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return;
    const tileId = tiles[y]?.[x];
    if (!canPaintTrailTile(tileId)) return;
    if (!trailTileOwners[y]) return;
    const previousOwner = trailTileOwners[y][x];
    if (previousOwner && previousOwner === statKey) {
      tiles[y][x] = statKey;
      return;
    }
    if (STAT_TILE_IDS.includes(previousOwner)) {
      applyTrailStatDelta(previousOwner, -1);
    }
    trailTileOwners[y][x] = statKey;
    tiles[y][x] = statKey;
    applyTrailStatDelta(statKey, 1);
    const label = STAT_COMBO_LABELS[statKey] || statKey;
    addLog(`${label}路 +${getTrailStatGainPerTile(statKey)} (合計${player.trailStatCounts[statKey]})`);
  }

  function applyStatBoost(statKey, label) {
    setActiveStatMode(statKey, label);
  }

  function ensurePlayerProgressState() {
    if (!player.tagCounts) player.tagCounts = createTagCounter();
    TAG_IDS.forEach((tag) => {
      if (!Number.isFinite(player.tagCounts[tag])) player.tagCounts[tag] = 0;
    });
    if (!player.awakenedTags) player.awakenedTags = {};
    if (!player.synergyTaken) player.synergyTaken = {};
    if (!player.synergyPerks) player.synergyPerks = {};
    if (!Number.isFinite(player.statTilesCollected)) player.statTilesCollected = 0;
    if (!player.trailStatCounts) player.trailStatCounts = createStatCounter();
    STAT_TILE_IDS.forEach((stat) => {
      if (!Number.isFinite(player.trailStatCounts[stat])) player.trailStatCounts[stat] = 0;
    });
    if (!STAT_TILE_IDS.includes(player.activeStatMode)) player.activeStatMode = null;
  }

  function getAwakenDescription(tag) {
    const descriptions = {
      crit: '会心時に追撃+MP+DoT付与が発動',
      dot: '毒/炎の上限が伸び、DoT中の敵へ追加入れ直し',
      multi: '連撃中に会心再抽選、ヒットごとに連撃率上昇',
      guard: '被弾時シールド+反射強化、超過回復を装甲化',
      stat: 'ステタイル累計で与ダメ増幅、戦闘中に能力成長'
    };
    return descriptions[tag] || '';
  }

  function applyImmediateSkillEffects(skillId) {
    let changed = false;
    if (skillId === 'statAtk') {
      player.baseStats.atk += 2;
      addLog('こうげき +2');
      changed = true;
    } else if (skillId === 'statSpd') {
      player.baseStats.spd += 2;
      addLog('はやさ +2');
      changed = true;
    } else if (skillId === 'statDef') {
      player.baseStats.def += NO_SUB_STAT_DEF_GAIN;
      addLog(`ぼうぎょ +${NO_SUB_STAT_DEF_GAIN}`);
      changed = true;
    } else if (skillId === 'statLuc') {
      player.baseStats.luc += NO_SUB_STAT_LUC_GAIN;
      addLog(`うん +${NO_SUB_STAT_LUC_GAIN}`);
      changed = true;
    } else if (skillId === 'statHp') {
      player.baseStats.hp += NO_SUB_STAT_HP_GAIN;
      player.hp += NO_SUB_STAT_HP_GAIN;
      addLog(`たいりょく +${NO_SUB_STAT_HP_GAIN}`);
      changed = true;
    }
    if (changed) {
      updateUnitStats(player);
      updatePlayerLevel();
    }
    return changed;
  }

  function queueUnlockedSynergies() {
    ensurePlayerProgressState();
    SYNERGY_DEFS.forEach((def) => {
      if (player.synergyTaken[def.id]) return;
      const unlocked = def.requires.every(tag => (player.tagCounts[tag] || 0) >= 1);
      if (!unlocked) return;
      if (!pendingSynergyQueue.includes(def.id)) pendingSynergyQueue.push(def.id);
    });
  }

  function applySynergyReward(synergyId, reward) {
    if (!reward) return null;
    ensurePlayerProgressState();
    player.synergyPerks[reward.id] = true;
    player.synergyTaken[synergyId] = true;
    addLog(`シナジー獲得: ${reward.name}`);
    return reward;
  }

  async function resolvePendingSynergyChoices() {
    ensurePlayerProgressState();
    while (pendingSynergyQueue.length) {
      const synergyId = pendingSynergyQueue.shift();
      const synergy = SYNERGY_DEFS.find(def => def.id === synergyId);
      if (!synergy) continue;
      if (player.synergyTaken[synergy.id]) continue;
      const ready = synergy.requires.every(tag => (player.tagCounts[tag] || 0) >= 1);
      if (!ready) continue;
      const options = synergy.rewards.map(reward => ({ ...reward, tags: synergy.requires }));
      addLog(`シナジー成立: ${synergy.name}`);
      await openSkillChoice(options, {
        title: `シナジー報酬: ${synergy.name}`,
        subtitle: '1つ選択 (各組み合わせ1回)',
        allowReroll: false,
        showTagGuide: false,
        buildOptions: () => options,
        onPick: (reward) => applySynergyReward(synergy.id, reward),
        emptyLog: '選べるシナジーがない'
      });
    }
  }

  function learnSkill(skill) {
    if (!skill) return false;
    ensurePlayerProgressState();
    if (player.skills[skill.id]) {
      addLog(`スキルは習得済み: ${skill.name}`);
      return false;
    }
    const bypassSkillCap = Boolean(skill.mapOnly);
    if (!bypassSkillCap && !canLearnMoreSkills()) {
      addLog('スキル枠がいっぱい');
      return false;
    }
    player.skills[skill.id] = true;
    addLog(`スキル獲得: ${skill.name}`);
    const tags = getSkillAllTags(skill);
    tags.forEach((tag) => {
      const nextCount = (player.tagCounts[tag] || 0) + 1;
      player.tagCounts[tag] = nextCount;
      if (!player.awakenedTags[tag] && nextCount >= AWAKEN_THRESHOLD) {
        player.awakenedTags[tag] = true;
        addLog(`【覚醒】${TAG_LABELS[tag]}: ${getAwakenDescription(tag)}`);
      }
    });
    applyImmediateSkillEffects(skill.id);
    queueUnlockedSynergies();
    if (!isChoosingSkill) {
      void resolvePendingSynergyChoices();
    }
    return true;
  }

  async function handleTreasureReward() {
    ensurePlayerProgressState();
    if (!canLearnMoreSkills()) {
      addLog('スキル枠がいっぱい');
      return;
    }
    const choices = buildTreasureSkillChoices();
    const picked = await openSkillChoice(choices, {
      title: DEFAULT_CHOICE_TITLE,
      subtitle: DEFAULT_CHOICE_SUBTITLE,
      allowReroll: true,
      buildOptions: buildTreasureSkillChoices,
      onPick: (skill) => grantSkillById(skill.id),
      emptyLog: '習得できるスキルがない'
    });
    treasureOpenedCount += 1;
    if (picked) {
      await resolvePendingSynergyChoices();
    }
  }

  function grantRandomSkill() {
    ensurePlayerProgressState();
    if (!canLearnMoreSkills()) {
      addLog('スキル枠がいっぱい');
      return null;
    }
    const available = SKILL_DEFS.filter(skill => !skill.mapOnly && !player.skills[skill.id]);
    if (!available.length) {
      addLog('スキルはもう習得できない');
      return null;
    }
    const pick = available[Math.floor(rand() * available.length)] || null;
    if (!pick) return null;
    grantSkillById(pick.id);
    return pick;
  }

  function grantSkillById(skillId) {
    ensurePlayerProgressState();
    if (!skillId) return grantRandomSkill();
    const skill = SKILL_DEFS.find(entry => entry.id === skillId);
    if (!skill) return grantRandomSkill();
    learnSkill(skill);
    return skill;
  }

  function applyDamageToEnemy(enemyState, damage, isBoss) {
    if (!enemyState || damage <= 0) return;
    if (isBoss) {
      applyBossDamage(enemyState, damage);
    } else {
      enemyState.hp = clamp(enemyState.hp - damage, 0, enemyState.maxHp);
    }
  }

  function takeBossSlow(enemyState, isBoss) {
    if (!isBoss || !enemyState?.bossLevelUp) return false;
    enemyState.bossLevelUp = false;
    return true;
  }

  function hasDotStatus(target) {
    if (!target) return false;
    return (target.poisonStacks || 0) > 0 || (target.fireStacks || 0) > 0;
  }

  function getFireStackCap(attackerState) {
    return attackerState?.awakenedTags?.dot ? AWAKEN_FIRE_MAX_STACKS : BASE_FIRE_MAX_STACKS;
  }

  function getEnemyPoisonStepGain(attackerState) {
    let steps = ENEMY_BASE_POISON_STEPS;
    if (attackerState?.skills?.toxicLength) steps += NO_SUB_TOXIC_LENGTH_BONUS;
    if (attackerState?.awakenedTags?.dot) steps += 2;
    return steps;
  }

  function applyPoisonToEnemy(enemyState, attackerState, amount = 1) {
    if (!enemyState || amount <= 0) return 0;
    const next = Math.min(MAX_POISON_STACKS, (enemyState.poisonStacks || 0) + amount);
    const gained = Math.max(0, next - (enemyState.poisonStacks || 0));
    enemyState.poisonStacks = next;
    enemyState.poisonSteps = Math.max(enemyState.poisonSteps || 0, getEnemyPoisonStepGain(attackerState));
    return gained;
  }

  function applyFireToEnemy(enemyState, attackerState, amount = 1) {
    if (!enemyState || amount <= 0) return 0;
    const cap = getFireStackCap(attackerState);
    const next = Math.min(cap, (enemyState.fireStacks || 0) + amount);
    const gained = Math.max(0, next - (enemyState.fireStacks || 0));
    enemyState.fireStacks = next;
    return gained;
  }

  function getReflectRate(unitState) {
    let rate = 0;
    if (unitState?.skills?.reflect) rate += 0.1;
    if (unitState?.awakenedTags?.guard) rate += AWAKEN_GUARD_REFLECT_BONUS;
    if (unitState?.synergyPerks?.guardDotThorn) rate += 0.07;
    return clamp(rate, 0, MAX_REFLECT_RATE);
  }

  function applyHeal(target, amount, opts = {}) {
    if (!target || amount <= 0) {
      return { actual: 0, overflow: 0, shieldAdded: 0, overflowDamage: 0 };
    }
    const missing = target.maxHp - target.hp;
    const actual = Math.min(missing, amount);
    target.hp = clamp(target.hp + actual, 0, target.maxHp);
    const overflow = Math.max(0, amount - actual);
    let shieldAdded = 0;
    if (overflow > 0 && (target.skills?.overhealShield || target.awakenedTags?.guard)) {
      const shieldGain = target.skills?.overhealShield
        ? Math.max(1, Math.floor(overflow * NO_SUB_OVERHEAL_SHIELD_MULT))
        : overflow;
      target.shield = (target.shield || 0) + shieldGain;
      shieldAdded = shieldGain;
    }
    let overflowDamage = 0;
    if (overflow > 0 && target.skills?.overhealDamage && opts.enemyState) {
      overflowDamage = Math.max(1, Math.floor(overflow * NO_SUB_OVERHEAL_DAMAGE_MULT));
      applyDamageToEnemy(opts.enemyState, overflowDamage, opts.isBoss);
    }
    if (actual > 0 && target.synergyPerks?.guardDotPurge && opts.enemyState) {
      const gained = applyFireToEnemy(opts.enemyState, target, 1);
      if (gained > 0) appendBattleLog(`${opts.enemyState.name}に炎 +${gained}`, 'player');
    }
    return { actual, overflow, shieldAdded, overflowDamage };
  }

  function applyEnemyPoisonTick(enemyState, isBoss, attackerState, critMultiplier = 1) {
    if (!enemyState || enemyState.poisonStacks <= 0 || enemyState.poisonSteps <= 0) return false;
    let baseDamage = Math.max(1, enemyState.poisonStacks * POISON_DAMAGE_PER_STACK);
    if (attackerState?.skills?.dotAmp) baseDamage = Math.max(1, Math.floor(baseDamage * 1.4));
    if (attackerState?.awakenedTags?.dot) baseDamage = Math.max(1, Math.floor(baseDamage * 1.2));
    const damage = Math.max(1, Math.floor(baseDamage * critMultiplier));
    applyDamageToEnemy(enemyState, damage, isBoss);
    enemyState.poisonSteps -= 1;
    appendBattleLog(`${enemyState.name}に毒 ${damage}ダメージ`, 'player');
    if (enemyState.poisonSteps <= 0) {
      enemyState.poisonStacks = 0;
      appendBattleLog(`${enemyState.name}の毒が切れた`);
    }
    return enemyState.hp <= 0;
  }

  function applyDamageToPlayer(playerState, damage) {
    let remaining = damage;
    let absorbed = 0;
    if (playerState.shield > 0) {
      absorbed = Math.min(playerState.shield, remaining);
      playerState.shield -= absorbed;
      remaining -= absorbed;
    }
    if (remaining > 0) {
      playerState.hp = clamp(playerState.hp - remaining, 0, playerState.maxHp);
    }
    return { absorbed, taken: remaining };
  }

  function applyStepHeal() {
    if (!player.skills.stepHeal) return;
    const amount = Math.max(1, Math.floor(player.maxHp * 0.1));
    const result = applyHeal(player, amount);
    if (result.actual > 0) addLog(`歩行回復 +${result.actual}`);
    if (result.shieldAdded > 0) addLog(`シールド +${result.shieldAdded}`);
  }

  function handleMimicBump(x, y) {
    const key = x + y * MAP_SIZE;
    if (!revealedMimics.has(key)) {
      revealedMimics.add(key);
      addLog('ミミックが現れた！');
    }
    const damage = Math.max(1, Math.floor(player.maxHp * MIMIC_DAMAGE_RATE));
    player.hp = clamp(player.hp - damage, 0, player.maxHp);
    addLog(`ミミックに噛まれた -${damage}`);
    updateStats();
    renderMap();
    if (player.hp <= 0) {
      endGame(false);
    }
  }

  async function resolveTileEvent(x, y) {
    const tileId = tiles[y]?.[x];
    if (!tileId) return;
    if (tileId === 'monster') {
      const enemy = enemies[y][x];
      if (enemy) {
        const result = await runBattle(enemy, { actor: player, actorLabel: '魔王様', allowDefeat: true });
        if (gameOver) return;
        if (result?.winner === 'player') {
          enemies[y][x] = null;
          enemyCount = Math.max(0, enemyCount - 1);
          tiles[y][x] = 'empty';
        }
      }
    } else if (tileId === 'treasure') {
      await handleTreasureReward();
      player.itemsCollected += 1;
      tiles[y][x] = 'empty';
    } else if (tileId === 'mimic') {
      if (player.hasKey) {
        player.hasKey = false;
        addLog('鍵で宝箱を開けた');
        await handleTreasureReward();
        player.itemsCollected += 1;
        tiles[y][x] = 'empty';
      } else {
        handleMimicBump(x, y);
        if (gameOver) return;
      }
    } else if (tileId === 'key') {
      if (player.hasKey) {
        addLog('鍵はもう持っている');
      } else {
        player.hasKey = true;
        addLog('鍵を手に入れた');
      }
      tiles[y][x] = 'empty';
    } else if (tileId === 'warp') {
      warpSelectionActive = true;
      tiles[y][x] = 'empty';
      addLog('魔法陣が起動: 転移先をクリック (現在地クリックでキャンセル)');
      addLog('魔法陣は崩れて消えた');
    } else if (tileId === 'inn') {
      await handleInnEvent();
    } else if (tileId === 'weaponShop') {
      const purchased = await handleWeaponShopEvent();
      if (purchased) tiles[y][x] = 'empty';
    } else if (tileId === 'armorShop') {
      const purchased = await handleArmorShopEvent();
      if (purchased) tiles[y][x] = 'empty';
    } else if (tileId === 'accessoryShop') {
      const purchased = await handleAccessoryShopEvent();
      if (purchased) tiles[y][x] = 'empty';
    } else if (tileId === 'skill') {
      const fixedSkillId = skillTiles?.[y]?.[x] || null;
      let grantedSkill = null;
      let consumed = false;
      if (fixedSkillId && !player.skills?.[fixedSkillId]) {
        const fixedSkill = SKILL_DEFS.find(entry => entry.id === fixedSkillId);
        if (fixedSkill && learnSkill(fixedSkill)) {
          grantedSkill = fixedSkill;
          consumed = true;
        }
      }
      if (!grantedSkill) {
        grantedSkill = grantRandomSkill();
        if (grantedSkill) consumed = true;
      }
      if (!consumed && fixedSkillId && player.skills?.[fixedSkillId]) {
        addLog('倍化スキルは習得済み');
        consumed = true;
      }
      if (consumed) {
        if (grantedSkill) player.itemsCollected += 1;
        tiles[y][x] = 'empty';
        if (skillTiles[y]) skillTiles[y][x] = null;
      }
    } else if (tileId === 'atk') {
      applyStatBoost('atk', 'こうげき');
    } else if (tileId === 'def') {
      applyStatBoost('def', 'ぼうぎょ');
    } else if (tileId === 'spd') {
      applyStatBoost('spd', 'はやさ');
    } else if (tileId === 'hp') {
      applyStatBoost('hp', 'たいりょく');
    } else if (tileId === 'luc') {
      applyStatBoost('luc', 'うん');
    } else if (tileId === 'heal') {
      const heal = Math.max(1, Math.floor(player.maxHp * HEAL_RATE));
      const result = applyHeal(player, heal);
      if (result.actual > 0) addLog(`回復 +${result.actual}`);
      if (result.shieldAdded > 0) addLog(`シールド +${result.shieldAdded}`);
    } else if (tileId === 'poison') {
      player.poisonStacks += 1;
      player.poisonSteps = POISON_STEPS;
      addLog(`毒を受けた +1 (合計${player.poisonStacks} / ${player.poisonSteps}歩)`);
    } else if (tileId === 'trap') {
      player.hp = clamp(player.hp - TRAP_DAMAGE, 0, player.maxHp);
      addLog(`トラップ -${TRAP_DAMAGE}`);
      tiles[y][x] = 'empty';
      if (player.hp <= 0) {
        endGame(false);
        return;
      }
    } else if (tileId === 'boss') {
      await resolveBossBattle();
      return;
    }
  }

  function applyPoisonTick() {
    if (player.poisonStacks <= 0 || player.poisonSteps <= 0) return false;
    const damage = Math.max(1, player.poisonStacks * POISON_DAMAGE_PER_STACK);
    player.hp = clamp(player.hp - damage, 0, player.maxHp);
    player.poisonSteps -= 1;
    addLog(`毒ダメージ -${damage}`);
    if (player.poisonSteps <= 0) {
      player.poisonStacks = 0;
      addLog('毒が回復した');
    }
    if (player.hp <= 0) {
      endGame(false);
      return true;
    }
    return false;
  }

  function hasAvailableMoveAt(x, y) {
    return countAvailableMovesAt(x, y) > 0;
  }

  function canMoveTo(x, y) {
    if (x < 0 || y < 0 || x >= MAP_SIZE || y >= MAP_SIZE) return false;
    const tileId = tiles[y]?.[x];
    return !isTileBlocked(tileId);
  }

  function findAStarPath(startX, startY, goalX, goalY) {
    if (startX === goalX && startY === goalY) return [];
    if (!canMoveTo(goalX, goalY)) return null;
    const size = MAP_SIZE * MAP_SIZE;
    const toKey = (x, y) => x + y * MAP_SIZE;
    const startKey = toKey(startX, startY);
    const goalKey = toKey(goalX, goalY);
    const cameFrom = new Int32Array(size);
    const gScore = new Float32Array(size);
    const fScore = new Float32Array(size);
    const inOpen = new Uint8Array(size);
    cameFrom.fill(-1);
    gScore.fill(Infinity);
    fScore.fill(Infinity);

    const heuristic = (x, y) => Math.abs(x - goalX) + Math.abs(y - goalY);
    const open = [startKey];
    gScore[startKey] = 0;
    fScore[startKey] = heuristic(startX, startY);
    inOpen[startKey] = 1;
    const dirs = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];

    while (open.length) {
      let bestIndex = 0;
      let currentKey = open[0];
      let bestScore = fScore[currentKey];
      for (let i = 1; i < open.length; i++) {
        const key = open[i];
        const score = fScore[key];
        if (score < bestScore) {
          bestScore = score;
          currentKey = key;
          bestIndex = i;
        }
      }
      open.splice(bestIndex, 1);
      inOpen[currentKey] = 0;

      if (currentKey === goalKey) {
        const path = [];
        let cursor = currentKey;
        while (cursor !== -1) {
          const x = cursor % MAP_SIZE;
          const y = Math.floor(cursor / MAP_SIZE);
          path.push({ x, y });
          if (cursor === startKey) break;
          cursor = cameFrom[cursor];
        }
        path.reverse();
        path.shift();
        return path;
      }

      const cx = currentKey % MAP_SIZE;
      const cy = Math.floor(currentKey / MAP_SIZE);
      for (const [dx, dy] of dirs) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (!canMoveTo(nx, ny)) continue;
        const nextKey = toKey(nx, ny);
        const tentative = gScore[currentKey] + 1;
        if (tentative >= gScore[nextKey]) continue;
        cameFrom[nextKey] = currentKey;
        gScore[nextKey] = tentative;
        fScore[nextKey] = tentative + heuristic(nx, ny);
        if (!inOpen[nextKey]) {
          inOpen[nextKey] = 1;
          open.push(nextKey);
        }
      }
    }
    return null;
  }

  async function movePlayerByAStar(goalX, goalY) {
    if (battleActive || isChoosingSkill || gameOver || isMoving || isAutoPathMoving) return;
    isAutoPathMoving = true;
    try {
      const guardLimit = MAP_SIZE * MAP_SIZE * 4;
      let guard = 0;
      while (guard < guardLimit) {
        guard += 1;
        if (battleActive || isChoosingSkill || gameOver || isMoving || warpSelectionActive) break;
        if (player.x === goalX && player.y === goalY) break;
        const path = findAStarPath(player.x, player.y, goalX, goalY);
        if (!path || !path.length) break;
        const next = path[0];
        await movePlayerTo(next.x, next.y);
      }
    } finally {
      isAutoPathMoving = false;
    }
  }

  function hasAvailableMove() {
    return hasAvailableMoveAt(player.x, player.y);
  }

  async function resolveMovementAfterLanding(dirX, dirY, allowIceSlide = true) {
    if (gameOver) return;
    applyTrailModeToTile(player.x, player.y);
    maybeLogRouteInsight();
    applyStepHeal();
    if (applyPoisonTick()) return;
    updateStats();
    renderMap();
    if (!warpSelectionActive && tiles[player.y]?.[player.x] !== 'boss' && !hasAvailableMove()) {
      endGame(false);
      return;
    }
    const currentTile = tiles[player.y]?.[player.x];
    if (!allowIceSlide) return;
    if (currentTile === 'ice' && (dirX || dirY)) {
      const nextX = player.x + dirX;
      const nextY = player.y + dirY;
      if (canMoveTo(nextX, nextY)) {
        await movePlayerTo(nextX, nextY, { dx: dirX, dy: dirY });
      }
    }
  }

  async function movePlayerTo(targetX, targetY, slideDir = null) {
    if (battleActive || isChoosingSkill || gameOver || isMoving) return;
    const prevX = player.x;
    const prevY = player.y;
    const dx = targetX - prevX;
    const dy = targetY - prevY;
    const dirX = slideDir?.dx ?? Math.sign(dx);
    const dirY = slideDir?.dy ?? Math.sign(dy);
    await animateMove(targetX, targetY);
    await resolveTileEvent(targetX, targetY);
    await resolveMovementAfterLanding(dirX, dirY, true);
  }

  async function warpPlayerTo(targetX, targetY) {
    if (battleActive || isChoosingSkill || gameOver || isMoving) return;
    await animateMove(targetX, targetY);
    await resolveTileEvent(targetX, targetY);
    await resolveMovementAfterLanding(0, 0, false);
    warpSelectionActive = false;
  }

  function animateMove(nextX, nextY) {
    return new Promise((resolve) => {
      const dx = nextX - player.x;
      const dy = nextY - player.y;
      if (!dx && !dy) {
        resolve();
        return;
      }
      setPlayerFacing(dx, dy);
      const startTime = performance.now();
      isMoving = true;
      moveAnim = { player: { dx, dy }, progress: 0 };
      const tick = (now) => {
        const elapsed = now - startTime;
        const t = clamp(elapsed / MOVE_ANIM_MS, 0, 1);
        moveAnim.progress = t;
        renderMap();
        if (t < 1) {
          requestAnimationFrame(tick);
        } else {
          isMoving = false;
          moveAnim = null;
          player.x = nextX;
          player.y = nextY;
          player.steps += 1;
          resolve();
        }
      };
      requestAnimationFrame(tick);
    });
  }

  function getMapTargetFromPointer(event) {
    const rect = mapCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    if (x < 0 || y < 0 || x > rect.width || y > rect.height) return null;
    const cellSize = rect.width / viewTiles;
    if (!cellSize) return null;
    const tx = Math.min(viewTiles - 1, Math.max(0, Math.floor(x / cellSize)));
    const ty = Math.min(viewTiles - 1, Math.max(0, Math.floor(y / cellSize)));
    const camera = getCamera();
    const targetX = clamp(camera.x + tx, 0, MAP_SIZE - 1);
    const targetY = clamp(camera.y + ty, 0, MAP_SIZE - 1);
    return { targetX, targetY };
  }

  function handleMapClick(event) {
    event.preventDefault();
    if (battleActive || isChoosingSkill || gameOver || isMoving || isAutoPathMoving) return;
    const target = getMapTargetFromPointer(event);
    if (!target) return;
    const { targetX, targetY } = target;
    if (warpSelectionActive) {
      if (targetX === player.x && targetY === player.y) {
        warpSelectionActive = false;
        addLog('転移をキャンセルした');
        return;
      }
      if (!canMoveTo(targetX, targetY)) return;
      warpSelectionActive = false;
      addLog(`魔法陣で転移: (${targetX + 1}, ${targetY + 1})`);
      warpPlayerTo(targetX, targetY);
      return;
    }
    if (targetX === player.x && targetY === player.y) return;
    if (!canMoveTo(targetX, targetY)) return;
    movePlayerByAStar(targetX, targetY);
  }

  function getCritCap(attacker) {
    let cap = 0.3;
    if (attacker?.skills?.critCap) cap += NO_SUB_CRIT_CAP_BONUS;
    if (attacker?.synergyPerks?.critStatCapBreak) cap = 0.9;
    return clamp(cap, 0.05, 0.9);
  }

  function getCritChance(attacker, defender, bonusCrit = 0) {
    let chance = 0.02 * (attacker?.luc || 0) + bonusCrit;
    if (attacker?.skills?.critRate) chance += 0.1;
    if (attacker?.skills?.dotCrit && hasDotStatus(defender)) chance += NO_SUB_DOT_CRIT_BONUS;
    if (attacker?.synergyPerks?.critStatCapBreak) chance += 0.05;
    return clamp(chance, 0, getCritCap(attacker));
  }

  function getDamageReductionFromSkills(defender) {
    let reduction = 0;
    if (defender?.skills?.damageCut) reduction += NO_SUB_DAMAGE_CUT_RATE;
    return clamp(reduction, 0, 0.8);
  }

  function getChainTriggerRate(unitState, comboIndex = 0) {
    let chance = BASE_ACTION_CHAIN_RATE;
    if (unitState?.skills?.chainChance) chance += NO_SUB_CHAIN_CHANCE_BONUS;
    if (unitState?.awakenedTags?.multi) chance += comboIndex * 0.06;
    return clamp(chance, 0, 0.75);
  }

  function rollActionHits(unitState, baseHits = 1) {
    let hits = Math.max(1, baseHits);
    let comboIndex = Math.max(0, hits - 1);
    while (hits < MAX_HITS_PER_ACTION) {
      if (Math.random() >= getChainTriggerRate(unitState, comboIndex)) break;
      hits += 1;
      comboIndex += 1;
    }
    return Math.min(MAX_HITS_PER_ACTION, hits);
  }

  function applyStatAwakenTurnGrowth(unitState) {
    if (!unitState?.awakenedTags?.stat) return false;
    const current = unitState.statAwakenGainTurns || 0;
    if (current >= AWAKEN_STAT_TURN_GAIN_CAP) return false;
    const turns = current + 1;
    unitState.statAwakenGainTurns = turns;
    unitState.atk += 1;
    unitState.spd += 1;
    unitState.luc += 1;
    return true;
  }

  function calcDamage(attacker, defender, opts = {}) {
    const power = opts.power || 1;
    const ignoreDef = opts.ignoreDef || false;
    const bonusCrit = opts.critBonus || 0;
    const baseAtk = attacker.atk || 0;
    const def = ignoreDef ? 0 : (defender.def || 0);
    const base = Math.max(1, Math.floor((baseAtk * baseAtk) / Math.max(1, baseAtk + def)));
    const variance = Math.floor(Math.random() * 3);
    const critChance = getCritChance(attacker, defender, bonusCrit);
    const critCap = getCritCap(attacker);
    const canCrit = opts.canCrit !== false;
    let isCrit = canCrit && (opts.forceCrit || Math.random() < critChance);
    if (canCrit && !isCrit && opts.extraCritRoll) {
      const extraChance = clamp(critChance + (opts.extraCritBonus || 0.12), 0, critCap);
      isCrit = Math.random() < extraChance;
    }
    let critMultiplier = 1;
    if (isCrit) {
      critMultiplier = 1.5;
      if (attacker.skills?.critDamage) critMultiplier += 0.3;
      if (attacker.synergyPerks?.lucidCrit) {
        critMultiplier += Math.min(0.9, (attacker.luc || 0) * 0.03);
      }
    }
    let raw = (base + variance) * power * critMultiplier;
    const comboIndex = opts.comboIndex || 0;
    if (attacker.skills?.comboPower && comboIndex > 0) {
      raw *= 1 + Math.min(NO_SUB_COMBO_POWER_CAP, comboIndex * NO_SUB_COMBO_POWER_STEP);
    }
    if (attacker.skills?.dotRend && hasDotStatus(defender)) {
      raw *= NO_SUB_DOT_REND_MULT;
    }
    if (attacker.awakenedTags?.stat) {
      const tileBonus = Math.min(AWAKEN_STAT_DAMAGE_CAP, (attacker.statTilesCollected || 0) * AWAKEN_STAT_DAMAGE_PER_TILE);
      raw *= 1 + tileBonus;
    }
    if (attacker.synergyPerks?.dotMultiSpread && comboIndex > 0 && hasDotStatus(defender)) {
      raw *= 1.08;
    }
    const levelGap = (attacker.level || 1) - (defender.level || 1);
    const levelMult = clamp(1 + levelGap * 0.03, 0.6, 1.6);
    raw *= levelMult;
    const reduction = clamp((opts.damageReduction || 0) + getDamageReductionFromSkills(defender), 0, 0.8);
    const reduced = raw * (1 - reduction);
    return { damage: Math.max(1, Math.floor(reduced)), isCrit, critMultiplier, critChance };
  }

  function getEvasionChance(attacker, defender) {
    const spdRate = Math.min(15, Math.floor((defender.spd || 0) / 5));
    const lucRate = Math.min(15, Math.floor((defender.luc || 0) / 5));
    const base = clamp(spdRate + lucRate, 0, 30);
    return base;
  }

  function checkEvasion(attacker, defender) {
    const chance = getEvasionChance(attacker, defender);
    return Math.random() * 100 < chance;
  }

  function getUnitAction(unitState, opts = {}) {
    const isPlayer = !!opts.isPlayer;
    if (isPlayer) {
      const mp = unitState?.mp || 0;
      let action = null;
      if (unitState?.skills?.tripleStrike && mp >= TRIPLE_STRIKE_MP_COST && Math.random() < 0.1) {
        action = { type: 'skill', label: '3連撃', power: 1, hits: 3, mpCost: TRIPLE_STRIKE_MP_COST };
      } else if (mp >= PLAYER_ACTIVE_SKILL.mpCost && Math.random() < PLAYER_ACTIVE_SKILL_CHANCE) {
        action = { ...PLAYER_ACTIVE_SKILL };
      } else {
        action = { type: 'attack', label: 'こうげき', power: 1, hits: 1, mpGain: PLAYER_ATTACK_MP_GAIN };
      }
      const finalHits = rollActionHits(unitState, action.hits || 1);
      action.hits = finalHits;
      if (finalHits > 1 && action.label === 'こうげき') {
        action.label = `${finalHits}連撃`;
      }
      return action;
    }
    if (unitState?.skills?.tripleStrike && Math.random() < 0.1) {
      return { type: 'attack', label: '3連撃', power: 1, hits: rollActionHits(unitState, 3) };
    }
    return { type: 'attack', label: 'こうげき', power: 1, hits: rollActionHits(unitState, 1) };
  }

  function getEffectiveSpeed(state) {
    return state.spd || 0;
  }

  function pickNextActor(playerState, enemyState) {
    if (playerState.gauge < 100 && enemyState.gauge < 100) {
      const pSpeed = getEffectiveSpeed(playerState);
      const eSpeed = getEffectiveSpeed(enemyState);
      const pTime = pSpeed > 0 ? (100 - playerState.gauge) / pSpeed : Infinity;
      const eTime = eSpeed > 0 ? (100 - enemyState.gauge) / eSpeed : Infinity;
      const time = Math.min(pTime, eTime);
      if (Number.isFinite(time)) {
        playerState.gauge += pSpeed * time;
        enemyState.gauge += eSpeed * time;
      }
    }
    const pReady = playerState.gauge >= 100;
    const eReady = enemyState.gauge >= 100;
    if (pReady && eReady) {
      if (playerState.gauge === enemyState.gauge) return 'player';
      return playerState.gauge > enemyState.gauge ? 'player' : 'enemy';
    }
    return pReady ? 'player' : 'enemy';
  }

  function updateBattleBars(playerState, enemyState) {
    playerHpFill.style.width = `${Math.max(0, (playerState.hp / playerState.maxHp) * 100)}%`;
    enemyHpFill.style.width = `${Math.max(0, (enemyState.hp / enemyState.maxHp) * 100)}%`;
    playerHpText.textContent = `${playerState.hp} / ${playerState.maxHp}`;
    enemyHpText.textContent = `${enemyState.hp} / ${enemyState.maxHp}`;
    const playerMaxMp = playerState.maxMp ?? playerState.mp ?? 0;
    const enemyMaxMp = enemyState.maxMp ?? enemyState.mp ?? 0;
    const playerMpRate = playerMaxMp ? (playerState.mp / playerMaxMp) * 100 : 0;
    const enemyMpRate = enemyMaxMp ? (enemyState.mp / enemyMaxMp) * 100 : 0;
    playerMpFill.style.width = `${Math.max(0, playerMpRate)}%`;
    enemyMpFill.style.width = `${Math.max(0, enemyMpRate)}%`;
    playerMpText.textContent = playerMaxMp ? `${playerState.mp} / ${playerMaxMp}` : '--';
    enemyMpText.textContent = enemyMaxMp ? `${enemyState.mp} / ${enemyMaxMp}` : '--';
    const playerShield = playerState.shield || 0;
    const enemyShield = enemyState.shield || 0;
    const playerShieldRate = playerState.maxHp ? (playerShield / playerState.maxHp) * 100 : 0;
    const enemyShieldRate = enemyState.maxHp ? (enemyShield / enemyState.maxHp) * 100 : 0;
    playerShieldFill.style.width = `${Math.max(0, playerShieldRate)}%`;
    enemyShieldFill.style.width = `${Math.max(0, enemyShieldRate)}%`;
    playerShieldText.textContent = playerShield > 0 ? `+${playerShield}` : '0';
    enemyShieldText.textContent = enemyShield > 0 ? `+${enemyShield}` : '0';
  }

  let battleLogQueue = [];
  let battleLogBusy = false;
  let battleLogTimer = null;
  let battleLogDelayProvider = () => BATTLE_LOG_REVEAL_MS;
  let battleSkipActive = false;
  let skillChoiceResolver = null;
  let activeChoiceContext = null;
  let pendingSynergyQueue = [];

  function setBattleLogDelayProvider(fn) {
    battleLogDelayProvider = typeof fn === 'function' ? fn : () => BATTLE_LOG_REVEAL_MS;
  }

  function resetBattleLogQueue() {
    battleLogQueue = [];
    battleLogBusy = false;
    if (battleLogTimer) {
      clearTimeout(battleLogTimer);
      battleLogTimer = null;
    }
    setBattleLogDelayProvider();
  }

  function processBattleLogQueue() {
    if (!battleLogQueue.length) {
      battleLogBusy = false;
      return;
    }
    battleLogBusy = true;
    const { text, role } = battleLogQueue.shift();
    const p = document.createElement('p');
    p.textContent = text;
    if (role === 'player') p.classList.add('is-player');
    if (role === 'enemy') p.classList.add('is-enemy');
    battleLog.appendChild(p);
    while (battleLog.children.length > 6) {
      battleLog.removeChild(battleLog.firstChild);
    }
    if (battleLogQueue.length) {
      const nextDelay = battleLogDelayProvider?.();
      const delay = Number.isFinite(nextDelay) ? Math.max(0, nextDelay) : BATTLE_LOG_REVEAL_MS;
      battleLogTimer = setTimeout(processBattleLogQueue, delay);
    } else {
      battleLogBusy = false;
    }
  }

  function appendBattleLog(text, role = null) {
    if (!text) return;
    battleLogQueue.push({ text, role });
    if (!battleLogBusy) processBattleLogQueue();
  }

  function getLearnedSkillCount() {
    return Object.entries(player.skills || {}).reduce((count, [skillId, learned]) => {
      if (!learned) return count;
      if (MAP_ONLY_SKILL_IDS.has(skillId)) return count;
      return count + 1;
    }, 0);
  }

  function canLearnMoreSkills() {
    return getLearnedSkillCount() < MAX_SKILL_COUNT;
  }

  function setChoiceOverlayText(title, subtitle) {
    if (skillChoiceTitleEl) skillChoiceTitleEl.textContent = title || DEFAULT_CHOICE_TITLE;
    if (skillChoiceSubEl) skillChoiceSubEl.textContent = subtitle || DEFAULT_CHOICE_SUBTITLE;
  }

  function getTagGuideText() {
    ensurePlayerProgressState();
    return TAG_IDS.map((tag) => {
      const count = player.tagCounts?.[tag] || 0;
      return player.awakenedTags?.[tag]
        ? `${formatTagLabel(tag)}:覚醒`
        : `${formatTagLabel(tag)}:${count}/${AWAKEN_THRESHOLD}`;
    }).join(' / ');
  }

  function pickWeightedOne(list, weightFn = () => 1) {
    if (!Array.isArray(list) || !list.length) return null;
    const weights = list.map((item) => Math.max(0, Number(weightFn(item)) || 0));
    const total = weights.reduce((sum, value) => sum + value, 0);
    if (total <= 0) {
      return list[Math.floor(rand() * list.length)] || null;
    }
    let roll = rand() * total;
    for (let i = 0; i < list.length; i++) {
      roll -= weights[i];
      if (roll <= 0) return list[i];
    }
    return list[list.length - 1] || null;
  }

  function pickWeightedMany(list, count, weightFn = () => 1) {
    const pool = Array.isArray(list) ? [...list] : [];
    const picked = [];
    while (pool.length && picked.length < count) {
      const next = pickWeightedOne(pool, weightFn);
      if (!next) break;
      picked.push(next);
      const index = pool.findIndex(entry => entry.id === next.id);
      if (index >= 0) pool.splice(index, 1);
    }
    return picked;
  }

  function getDominantTagForTreasure(availableSkills) {
    const tagPool = TAG_IDS.filter(tag => availableSkills.some(skill => getSkillAllTags(skill).includes(tag)));
    if (!tagPool.length) return TAG_IDS[0];
    let bestTag = tagPool[0];
    let bestScore = -Infinity;
    tagPool.forEach((tag) => {
      const count = player.tagCounts?.[tag] || 0;
      const awakenPenalty = player.awakenedTags?.[tag] ? 0.35 : 0;
      const score = count - awakenPenalty + rand() * 0.01;
      if (score > bestScore) {
        bestScore = score;
        bestTag = tag;
      }
    });
    return bestTag;
  }

  function getEscapeTags(focusTag) {
    const tags = [];
    SYNERGY_DEFS.forEach((def) => {
      if (player.synergyTaken?.[def.id]) return;
      if (!def.requires.includes(focusTag)) return;
      const others = def.requires.filter(tag => tag !== focusTag);
      others.forEach((tag) => {
        if (!tags.includes(tag)) tags.push(tag);
      });
    });
    if (!tags.length) {
      TAG_IDS.forEach((tag) => {
        if (tag === focusTag) return;
        if (!player.awakenedTags?.[tag]) tags.push(tag);
      });
    }
    if (!tags.length) {
      TAG_IDS.forEach((tag) => {
        if (tag !== focusTag) tags.push(tag);
      });
    }
    tags.sort((a, b) => (player.tagCounts?.[a] || 0) - (player.tagCounts?.[b] || 0));
    return tags;
  }

  function updateSkillRerollState() {
    if (!skillRerollBtn) return;
    const allowReroll = Boolean(activeChoiceContext?.allowReroll);
    skillRerollBtn.hidden = !allowReroll;
    if (!allowReroll) {
      skillRerollBtn.disabled = true;
      return;
    }
    const canPay = (player.coins || 0) >= SKILL_REROLL_COST;
    skillRerollBtn.innerHTML = `リロール (<img class="btn-coin" src="../character-dots/tyarin.png" alt="">${SKILL_REROLL_COST})`;
    skillRerollBtn.disabled = !isChoosingSkill || !canPay;
  }

  function renderSkillChoiceOptions(choices, onPick) {
    if (!skillChoiceList) return;
    skillChoiceList.innerHTML = '';
    choices.forEach((choice) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'choice-card';
      const icon = document.createElement('div');
      icon.className = 'choice-icon';
      const spritePath = choice.iconTileKey
        ? tileSpritePaths[choice.iconTileKey]
        : SKILL_SPRITE_PATHS[choice.id];
      if (spritePath) icon.style.setProperty('--icon-image', `url(${spritePath})`);
      const title = document.createElement('strong');
      title.textContent = choice.name;
      const desc = document.createElement('span');
      desc.textContent = `${choice.desc || ''}`;
      btn.append(icon, title, desc);
      if (choice.choiceType === 'event') {
        if (choice.meta) {
          const meta = document.createElement('small');
          meta.textContent = choice.meta;
          btn.appendChild(meta);
        }
      } else {
        const tagMeta = document.createElement('small');
        tagMeta.textContent = formatSkillTags(choice);
        const gainMeta = document.createElement('small');
        gainMeta.textContent = `取得時: ${formatSkillTagGainPreview(choice)}`;
        btn.append(tagMeta, gainMeta);
      }
      btn.addEventListener('click', () => {
        if (typeof onPick === 'function') onPick(choice);
        closeSkillChoice(choice);
      });
      skillChoiceList.appendChild(btn);
    });
  }

  function buildTreasureSkillChoices() {
    ensurePlayerProgressState();
    if (!canLearnMoreSkills()) return [];
    const available = SKILL_DEFS.filter(skill => !skill.mapOnly && !player.skills[skill.id]);
    if (!available.length) return [];
    if (available.length <= 3) {
      const quick = [...available];
      shuffleList(quick);
      return quick;
    }

    const focusTag = getDominantTagForTreasure(available);
    const escapeTags = getEscapeTags(focusTag);
    const selected = [];
    const pickUnique = (skill) => {
      if (!skill) return false;
      if (selected.some(entry => entry.id === skill.id)) return false;
      selected.push(skill);
      return true;
    };
    const remaining = () => available.filter(skill => !selected.some(entry => entry.id === skill.id));

    const focusPenalty = player.awakenedTags?.[focusTag] ? 0.7 : 1;
    const focusPool = available.filter(skill => getSkillAllTags(skill).includes(focusTag));
    pickWeightedMany(focusPool, 2, () => focusPenalty).forEach(pickUnique);

    while (selected.length < 2) {
      const fill = pickWeightedOne(remaining(), (skill) => getSkillAllTags(skill).includes(focusTag) ? 2 * focusPenalty : 1);
      if (!fill) break;
      pickUnique(fill);
    }

    let escapePool = remaining().filter((skill) => {
      const tags = getSkillAllTags(skill);
      return !tags.includes(focusTag) && tags.some(tag => escapeTags.includes(tag));
    });
    if (!escapePool.length) {
      escapePool = remaining().filter(skill => !getSkillAllTags(skill).includes(focusTag));
    }
    const escapePick = pickWeightedOne(escapePool, (skill) => {
      const tags = getSkillAllTags(skill);
      let weight = 1;
      tags.forEach((tag) => {
        if (escapeTags.includes(tag)) weight += 2;
        if (player.awakenedTags?.[tag]) weight *= 0.85;
      });
      return weight;
    });
    pickUnique(escapePick);

    while (selected.length < 3) {
      const fill = pickWeightedOne(remaining(), (skill) => {
        const tags = getSkillAllTags(skill);
        let weight = 1;
        if (tags.includes(focusTag)) weight += 1.2 * focusPenalty;
        if (tags.some(tag => escapeTags.includes(tag))) weight += 0.9;
        return weight;
      });
      if (!fill) break;
      pickUnique(fill);
    }

    shuffleList(selected);
    return selected.slice(0, 3);
  }

  function closeSkillChoice(selected = null) {
    if (skillChoiceOverlay) {
      skillChoiceOverlay.classList.remove('is-open');
      skillChoiceOverlay.setAttribute('aria-hidden', 'true');
    }
    if (skillChoiceList) skillChoiceList.innerHTML = '';
    isChoosingSkill = false;
    activeChoiceContext = null;
    setChoiceOverlayText(DEFAULT_CHOICE_TITLE, DEFAULT_CHOICE_SUBTITLE);
    updateSkillRerollState();
    const resolve = skillChoiceResolver;
    skillChoiceResolver = null;
    if (resolve) resolve(selected);
  }

  function openSkillChoice(options, config = {}) {
    if (!skillChoiceOverlay || !skillChoiceList) {
      return Promise.resolve(null);
    }
    return new Promise((resolve) => {
      skillChoiceResolver = resolve;
      skillChoiceList.innerHTML = '';
      const context = {
        title: config.title || DEFAULT_CHOICE_TITLE,
        subtitle: config.subtitle || DEFAULT_CHOICE_SUBTITLE,
        allowReroll: !!config.allowReroll,
        showTagGuide: config.showTagGuide !== false,
        buildOptions: typeof config.buildOptions === 'function' ? config.buildOptions : () => options || [],
        onPick: typeof config.onPick === 'function' ? config.onPick : (skill) => grantSkillById(skill.id),
        emptyLog: config.emptyLog || '習得できるスキルがない'
      };
      activeChoiceContext = context;
      const subtitle = context.showTagGuide ? `${context.subtitle} / ${getTagGuideText()}` : context.subtitle;
      setChoiceOverlayText(context.title, subtitle);
      const choices = options || context.buildOptions() || [];
      if (!choices.length) {
        addLog(context.emptyLog);
        closeSkillChoice(null);
        return;
      }
      renderSkillChoiceOptions(choices, context.onPick);
      isChoosingSkill = true;
      skillChoiceOverlay.classList.add('is-open');
      skillChoiceOverlay.setAttribute('aria-hidden', 'false');
      updateSkillRerollState();
    });
  }

  function flashActor(el) {
    el.classList.remove('is-hit');
    void el.offsetWidth;
    el.classList.add('is-hit');
  }

  const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  const smoothStep = (t) => t * t * (3 - 2 * t);

  function getBattleProgress(playerState, enemyState) {
    const playerRate = playerState.maxHp ? playerState.hp / playerState.maxHp : 0;
    const enemyRate = enemyState.maxHp ? enemyState.hp / enemyState.maxHp : 0;
    return clamp(1 - Math.min(playerRate, enemyRate), 0, 1);
  }

  function createBattlePacer(playerState, enemyState) {
    const startTime = performance.now();
    let lastProgress = 0;
    const getDelay = (slowMs, fastMs, extraSlow = false) => {
      if (battleSkipActive) return 0;
      const elapsed = performance.now() - startTime;
      const startPhase = clamp((elapsed - BATTLE_SLOW_START_MS) / BATTLE_SPEED_RAMP_MS, 0, 1);
      const rawProgress = getBattleProgress(playerState, enemyState);
      const progress = Math.max(lastProgress, rawProgress);
      lastProgress = progress;
      const startEase = smoothStep(startPhase);
      const endPhase = clamp((progress - BATTLE_END_SLOW_START) / BATTLE_END_SLOW_RANGE, 0, 1);
      const endEase = 1 - smoothStep(endPhase);
      const speedFactor = startEase * endEase;
      let delay = slowMs + (fastMs - slowMs) * speedFactor;
      if (extraSlow) delay *= BATTLE_SLOW_BOOST;
      return clamp(delay, BATTLE_PACE_MIN_DELAY, BATTLE_PACE_MAX_DELAY);
    };
    return {
      waitHit: (extraSlow = false) => sleep(getDelay(BATTLE_SLOW_HIT_DELAY, BATTLE_FAST_HIT_DELAY, extraSlow)),
      waitTurn: (extraSlow = false) => sleep(getDelay(BATTLE_SLOW_TURN_DELAY, BATTLE_FAST_TURN_DELAY, extraSlow)),
      getLogDelay: () => getDelay(BATTLE_SLOW_TURN_DELAY, BATTLE_FAST_TURN_DELAY, false)
    };
  }

  async function runBattle(enemyTemplate, options = {}) {
    const isBoss = options.isBoss || false;
    const allowDefeat = options.allowDefeat !== false;
    const actor = options.actor || player;
    const actorLabel = options.actorLabel || '魔王様';
    const maxActions = Number.isFinite(options.maxActions) ? options.maxActions : Infinity;

    battleActive = true;
    battleSkipActive = false;
    if (battleSkipBtn) {
      battleSkipBtn.disabled = false;
      battleSkipBtn.textContent = 'スキップ';
    }
    battleOverlay.classList.add('is-open');
    if (isBoss) {
      battleTitle.textContent = '勇者との決戦';
    } else {
      battleTitle.textContent = '敵との遭遇';
    }
    resetBattleLogQueue();
    battleLog.innerHTML = '';

    let enemyState = null;
    if (isBoss) {
      enemyState = {
        id: enemyTemplate.id,
        name: enemyTemplate.name,
        color: enemyTemplate.color,
        level: 1,
        maxHp: BOSS_HP_PER_LEVEL,
        hp: BOSS_HP_PER_LEVEL,
        guard: 0,
        guardTurns: 0,
        gauge: 0,
        poisonStacks: 0,
        poisonSteps: 0,
        fireStacks: 0,
        bossLevelUp: false,
        maxMp: HERO_BOSS.stats.mp
      };
      syncBossStats(enemyState);
    } else {
      const scaledStats = resolveEnemyStats(enemyTemplate);
      enemyState = {
        id: enemyTemplate.id,
        ...scaledStats,
        maxHp: scaledStats.hp,
        name: enemyTemplate.name,
        color: enemyTemplate.color,
        mp: scaledStats.mp,
        maxMp: scaledStats.mp,
        level: getEnemyLevel(enemyTemplate),
        guard: 0,
        guardTurns: 0,
        gauge: 0,
        poisonStacks: 0,
        poisonSteps: 0,
        fireStacks: 0
      };
      if (enemyTemplate.currentHp != null) {
        enemyState.hp = clamp(enemyTemplate.currentHp, 0, enemyState.maxHp);
      }
    }
    const playerState = {
      hp: actor.hp,
      maxHp: actor.maxHp,
      atk: actor.atk,
      spd: actor.spd,
      def: actor.def,
      luc: actor.luc,
      mp: actor.mp,
      maxMp: actor.maxMp,
      level: actor.level || 1,
      gauge: 0,
      skills: { ...(actor.skills || {}) },
      shield: actor.shield || 0,
      tagCounts: { ...(actor.tagCounts || createTagCounter()) },
      awakenedTags: { ...(actor.awakenedTags || {}) },
      synergyPerks: { ...(actor.synergyPerks || {}) },
      statTilesCollected: actor.statTilesCollected || 0,
      statAwakenGainTurns: 0
    };
    if (isBoss) {
      updateBossBattleLabel(enemyState);
    } else {
      const enemyLevel = getEnemyLevel(enemyTemplate);
      if (enemyLevel) {
        battleSub.textContent = `Lv ${enemyLevel} / 現在 ${player.level}`;
      } else {
        battleSub.textContent = '戦闘開始';
      }
    }

    if (playerNameEl) playerNameEl.textContent = actorLabel;
    if (playerIcon) playerIcon.textContent = actorLabel.slice(0, 1);
    enemyNameEl.textContent = enemyState.name;
    enemyIcon.textContent = enemyState.name.slice(0, 1);
    enemyIcon.style.background = enemyTemplate.color;

    updateBattleBars(playerState, enemyState);
    const battlePacer = createBattlePacer(playerState, enemyState);
    setBattleLogDelayProvider(() => battlePacer.getLogDelay());

    let actionCount = 0;
    let safety = 0;
    const safetyLimit = isBoss ? 20000 : 600;
    while (playerState.hp > 0 && enemyState.hp > 0 && safety < safetyLimit) {
      const actorTurn = pickNextActor(playerState, enemyState);
      actionCount += 1;
      appendBattleLog(`行動 ${actionCount}`);
      if (actorTurn === 'player') {
        playerState.gauge = Math.max(0, playerState.gauge - 100);
        if (applyStatAwakenTurnGrowth(playerState)) {
          appendBattleLog('成長覚醒で能力上昇', 'player');
        }
        const action = getUnitAction(playerState, { isPlayer: true });
        if (action.mpCost) playerState.mp = Math.max(0, playerState.mp - action.mpCost);
        let plannedHits = Math.min(MAX_HITS_PER_ACTION, action.hits || 1);
        let performedHits = 0;
        let extraHitsFromAwaken = 0;
        let poisonCritMultiplier = 1;
        for (let i = 0; i < plannedHits; i++) {
          performedHits += 1;
          const isFinalHit = i === plannedHits - 1;
          const critBonus = playerState.skills?.lastCrit && plannedHits > 1 && isFinalHit ? NO_SUB_LAST_CRIT_BONUS : 0;
          const forceCrit = Boolean(
            (playerState.synergyPerks?.critStatCapBreak && i === 0)
            || (playerState.awakenedTags?.crit && plannedHits > 1 && isFinalHit && hasDotStatus(enemyState))
          );
          if (checkEvasion(playerState, enemyState)) {
            appendBattleLog(`${enemyState.name}は回避した`, 'enemy');
          } else {
            const defenderState = { ...enemyState, def: enemyState.def + enemyState.guard };
            const result = calcDamage(playerState, defenderState, {
              ...action,
              comboIndex: i,
              critBonus,
              forceCrit,
              extraCritRoll: playerState.awakenedTags?.multi && i > 0
            });
            appendBattleLog(`${actorLabel}の${action.label}！ ${result.damage}ダメージ${result.isCrit ? ' (クリティカル)' : ''}`, 'player');
            const maxHpSnapshot = enemyState.maxHp;
            applyDamageToEnemy(enemyState, result.damage, isBoss);
            if (result.isCrit) poisonCritMultiplier = result.critMultiplier;
            if (result.isCrit && playerState.skills?.poisonStrike) {
              const gained = applyPoisonToEnemy(enemyState, playerState, 1);
              if (gained > 0) appendBattleLog(`${enemyState.name}に毒 +${gained}`, 'player');
            }
            if (playerState.skills?.fireStrike && result.isCrit) {
              const gained = applyFireToEnemy(enemyState, playerState, 1);
              if (gained > 0) appendBattleLog(`${enemyState.name}に炎 +${gained}`, 'player');
            }
            if (playerState.awakenedTags?.dot && hasDotStatus(enemyState) && Math.random() < AWAKEN_DOT_STACK_CHANCE) {
              if (Math.random() < 0.5) {
                const gained = applyPoisonToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に毒 +${gained} (覚醒)`, 'player');
              } else {
                const gained = applyFireToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に炎 +${gained} (覚醒)`, 'player');
              }
            }
            if (playerState.synergyPerks?.dotMultiSpread && i > 0 && Math.random() < 0.5) {
              if (Math.random() < 0.5) {
                const gained = applyPoisonToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に毒 +${gained} (連鎖侵食)`, 'player');
              } else {
                const gained = applyFireToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に炎 +${gained} (連鎖侵食)`, 'player');
              }
            }
            if (playerState.skills?.fireStrike && enemyState.fireStacks > 0) {
              let fireBase = Math.max(1, Math.floor(maxHpSnapshot * FIRE_DAMAGE_RATE * enemyState.fireStacks));
              if (playerState.skills?.dotAmp) fireBase = Math.max(1, Math.floor(fireBase * 1.4));
              if (playerState.awakenedTags?.dot) fireBase = Math.max(1, Math.floor(fireBase * 1.2));
              const fireDamage = Math.max(1, Math.floor(fireBase * (result.isCrit ? result.critMultiplier : 1)));
              applyDamageToEnemy(enemyState, fireDamage, isBoss);
              appendBattleLog(`炎 +${fireDamage}ダメージ (累計${enemyState.fireStacks})`, 'player');
            }
            if (result.isCrit && playerState.skills?.critLifesteal) {
              const heal = Math.max(1, Math.floor(result.damage * 0.1));
              const healed = applyHeal(playerState, heal, { enemyState, isBoss });
              if (healed.actual > 0) appendBattleLog(`会心回復 +${healed.actual}`, 'player');
              if (healed.shieldAdded > 0) appendBattleLog(`シールド +${healed.shieldAdded}`, 'player');
              if (healed.overflowDamage > 0) appendBattleLog(`オーバー回復 ${healed.overflowDamage}ダメージ`, 'player');
            }
            if (i > 0 && playerState.skills?.multiMp) {
              const beforeMp = playerState.mp;
              playerState.mp = clamp(playerState.mp + 1, 0, playerState.maxMp || playerState.mp);
              if (playerState.mp > beforeMp) appendBattleLog('連撃充填 MP+1', 'player');
            }
            if (result.isCrit && playerState.awakenedTags?.crit) {
              const beforeMp = playerState.mp;
              playerState.mp = clamp(playerState.mp + 1, 0, playerState.maxMp || playerState.mp);
              if (playerState.mp > beforeMp) appendBattleLog('会心覚醒 MP+1', 'player');
              if (extraHitsFromAwaken < MAX_EXTRA_HITS_PER_ACTION && plannedHits < MAX_HITS_PER_ACTION) {
                plannedHits += 1;
                extraHitsFromAwaken += 1;
                appendBattleLog('会心連鎖で追撃 +1', 'player');
              }
              if (Math.random() < 0.5) {
                const gained = applyPoisonToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に毒 +${gained} (会心覚醒)`, 'player');
              } else {
                const gained = applyFireToEnemy(enemyState, playerState, 1);
                if (gained > 0) appendBattleLog(`${enemyState.name}に炎 +${gained} (会心覚醒)`, 'player');
              }
            }
            flashActor(enemyActor);
            updateBattleBars(playerState, enemyState);
          }
          if (enemyState.hp <= 0) break;
          if (plannedHits > 1) {
            const slow = takeBossSlow(enemyState, isBoss);
            await battlePacer.waitHit(slow);
          }
        }
        if (action.mpGain) {
          const beforeMp = playerState.mp;
          playerState.mp = clamp(playerState.mp + action.mpGain, 0, playerState.maxMp || playerState.mp);
          if (playerState.mp !== beforeMp) updateBattleBars(playerState, enemyState);
        }
        if (enemyState.hp > 0 && playerState.synergyPerks?.dotMultiTick && performedHits > 1 && hasDotStatus(enemyState)) {
          const tickDamage = Math.max(1, Math.floor(((enemyState.poisonStacks || 0) + (enemyState.fireStacks || 0)) * 2));
          applyDamageToEnemy(enemyState, tickDamage, isBoss);
          appendBattleLog(`追撃燃焼 ${tickDamage}ダメージ`, 'player');
          updateBattleBars(playerState, enemyState);
          if (enemyState.hp <= 0) break;
        }
        if (enemyState.hp > 0 && enemyState.poisonStacks > 0) {
          const poisonDead = applyEnemyPoisonTick(enemyState, isBoss, playerState, poisonCritMultiplier);
          updateBattleBars(playerState, enemyState);
          if (poisonDead || enemyState.hp <= 0) break;
        }
      } else {
        enemyState.gauge = Math.max(0, enemyState.gauge - 100);
        const action = enemyTemplate.ai ? enemyTemplate.ai(enemyState) : getUnitAction(enemyState);
        if (action.type === 'guard') {
          enemyState.guard = action.guard || 2;
          enemyState.guardTurns = 2;
          appendBattleLog(`${enemyState.name}は守りを固めた`, 'enemy');
        } else {
          if (action.mpCost) enemyState.mp = Math.max(0, enemyState.mp - action.mpCost);
          const hits = Math.min(MAX_HITS_PER_ACTION, action.hits || 1);
          let poisonCritMultiplier = 1;
          for (let i = 0; i < hits; i++) {
            if (checkEvasion(enemyState, playerState)) {
              appendBattleLog(`${actorLabel}は回避した`, 'player');
            } else {
              const result = calcDamage(enemyState, playerState, { ...action, comboIndex: i });
              appendBattleLog(`${enemyState.name}の${action.label}！ ${result.damage}ダメージ${result.isCrit ? ' (クリティカル)' : ''}`, 'enemy');
              if (result.isCrit) poisonCritMultiplier = result.critMultiplier;
              const damageResult = applyDamageToPlayer(playerState, result.damage);
              if (damageResult.absorbed > 0) {
                appendBattleLog(`シールドが${damageResult.absorbed}防いだ`, 'player');
              }
              if (damageResult.taken > 0 && playerState.awakenedTags?.guard) {
                const shieldGain = Math.max(1, Math.floor(damageResult.taken * AWAKEN_GUARD_SHIELD_RATE));
                playerState.shield = (playerState.shield || 0) + shieldGain;
                appendBattleLog(`防御覚醒 シールド +${shieldGain}`, 'player');
              }
              const reflectRate = getReflectRate(playerState);
              if (damageResult.taken > 0 && reflectRate > 0) {
                const reflectDamage = Math.max(1, Math.floor(damageResult.taken * reflectRate));
                applyDamageToEnemy(enemyState, reflectDamage, isBoss);
                appendBattleLog(`反射 ${reflectDamage}ダメージ`, 'player');
                if (playerState.synergyPerks?.guardDotThorn) {
                  const gained = applyPoisonToEnemy(enemyState, playerState, 1);
                  if (gained > 0) appendBattleLog(`${enemyState.name}に毒 +${gained} (毒棘反射)`, 'player');
                }
              }
              flashActor(playerActor);
              updateBattleBars(playerState, enemyState);
              if (playerState.hp <= 0) break;
              if (enemyState.hp <= 0) break;
            }
            {
              const slow = takeBossSlow(enemyState, isBoss);
              await battlePacer.waitHit(slow);
            }
          }
          if (enemyState.hp > 0 && enemyState.poisonStacks > 0) {
            const poisonDead = applyEnemyPoisonTick(enemyState, isBoss, playerState, poisonCritMultiplier);
            updateBattleBars(playerState, enemyState);
            if (poisonDead || enemyState.hp <= 0) break;
          }
        }
        if (action.type === 'guard' && enemyState.hp > 0 && enemyState.poisonStacks > 0) {
          const poisonDead = applyEnemyPoisonTick(enemyState, isBoss, playerState, 1);
          updateBattleBars(playerState, enemyState);
          if (poisonDead || enemyState.hp <= 0) break;
        }
        if (enemyState.guardTurns > 0) {
          enemyState.guardTurns -= 1;
          if (enemyState.guardTurns <= 0) enemyState.guard = 0;
        }
      }
      safety += 1;
      if (actionCount >= maxActions) break;
      {
        const slow = takeBossSlow(enemyState, isBoss);
        await battlePacer.waitTurn(slow);
      }
    }

    battleActive = false;
    battleSkipActive = false;
    if (battleSkipBtn) {
      battleSkipBtn.disabled = true;
      battleSkipBtn.textContent = 'スキップ';
    }
    battleOverlay.classList.remove('is-open');
    if (isBoss) {
      lastBossLevel = enemyState.level || lastBossLevel;
    }

    actor.hp = playerState.hp;
    actor.mp = playerState.mp;
    actor.shield = playerState.shield;
    let winner = null;
    if (playerState.hp <= 0) winner = 'enemy';
    if (enemyState.hp <= 0) winner = 'player';

    if (!allowDefeat) {
      if (actor.hp <= 0) actor.hp = 1;
      updateStats();
      renderMap();
      return { winner, actorState: playerState, enemyState };
    }

    if (actor === player && playerState.hp <= 0) {
      endGame(false);
      return { winner };
    }

    if (!isBoss && enemyState.hp <= 0 && actor === player) {
      player.kills += 1;
      addLog(`${enemyState.name}を倒した`);
      handleEnemyDrop(enemyState);
    }
    updateStats();
    renderMap();
    return { winner, actorState: playerState, enemyState };
  }

  function computeScore(cleared) {
    return Math.max(0, player.bossDamage);
  }

  function getNickname() {
    try {
      const nick = localStorage.getItem('pixieed_nickname');
      if (nick && nick.trim()) return nick.trim().slice(0, 24);
    } catch (_) {}
    return '名無し';
  }

  const CLIENT_ID_KEY = 'pixieed_client_id';
  const SUPABASE_MAINTENANCE_KEY = 'pixieed_supabase_maintenance';
  const SCORE_QUEUE_KEY = 'maou-war_score_queue';
  const SCORE_QUEUE_LIMIT = 20;
  const SCORE_QUEUE_RETRY_MS = 60000;
  let supabaseMaintenance = Boolean(readSupabaseMaintenance());
  let scoreQueueBusy = false;
  let supabaseClient = null;
  let supabaseInitPromise = null;
  function getClientId() {
    try {
      const saved = localStorage.getItem(CLIENT_ID_KEY);
      if (saved) return saved;
      const id = crypto.randomUUID ? crypto.randomUUID() : `guest-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      localStorage.setItem(CLIENT_ID_KEY, id);
      return id;
    } catch (_) {
      return `guest-${Math.random().toString(36).slice(2, 8)}`;
    }
  }

  function readSupabaseMaintenance() {
    try {
      const raw = localStorage.getItem(SUPABASE_MAINTENANCE_KEY);
      if (!raw) return null;
      const data = JSON.parse(raw);
      if (data && data.active) return data;
    } catch (_) {
      // ignore
    }
    return null;
  }

  function isSupabaseMaintenance() {
    return supabaseMaintenance;
  }

  function setSupabaseMaintenance(active, reason = '') {
    supabaseMaintenance = active;
    try {
      if (active) {
        localStorage.setItem(SUPABASE_MAINTENANCE_KEY, JSON.stringify({ active: true, reason, ts: Date.now() }));
      } else {
        localStorage.removeItem(SUPABASE_MAINTENANCE_KEY);
      }
    } catch (_) {
      // ignore
    }
  }

  function noteSupabaseSuccess() {
    if (supabaseMaintenance) {
      setSupabaseMaintenance(false);
    }
  }

  function shouldMarkSupabaseMaintenance(error) {
    const status = Number(error?.status || error?.statusCode || 0);
    if (status >= 500) return true;
    const msg = String(error?.message || '').toLowerCase();
    return msg.includes('failed to fetch') || msg.includes('network') || msg.includes('fetch failed') || msg.includes('503') || msg.includes('502') || msg.includes('504');
  }

  function markSupabaseMaintenanceFromError(error) {
    if (shouldMarkSupabaseMaintenance(error)) {
      setSupabaseMaintenance(true, 'network');
    }
  }

  function loadScoreQueue() {
    try {
      const raw = localStorage.getItem(SCORE_QUEUE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (_) {
      return [];
    }
  }

  function saveScoreQueue(queue) {
    try {
      localStorage.setItem(SCORE_QUEUE_KEY, JSON.stringify(queue.slice(0, SCORE_QUEUE_LIMIT)));
    } catch (_) {
      // ignore
    }
  }

  function queueScorePayload(payload) {
    if (!payload) return false;
    const queue = loadScoreQueue();
    queue.push({ payload, ts: Date.now() });
    saveScoreQueue(queue);
    return true;
  }

  async function getSupabaseClient() {
    if (supabaseClient) return supabaseClient;
    if (supabaseInitPromise) return supabaseInitPromise;
    supabaseInitPromise = (async () => {
      const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2.46.1?bundle');
      supabaseClient = createClient('https://kyyiuakrqomzlikfaire.supabase.co', 'sb_publishable_gnc61sD2hZvGHhEW8bQMoA_lrL07SN4');
      return supabaseClient;
    })();
    try {
      return await supabaseInitPromise;
    } finally {
      supabaseInitPromise = null;
    }
  }

  async function sendScorePayload(supabase, payload) {
    let { error } = await supabase.from('scores').insert(payload);
    if (error && isMissingColumn(error, 'game')) {
      delete payload.game;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && isMissingColumn(error, 'result')) {
      delete payload.result;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && payload.user_id && isMissingColumn(error, 'user_id')) {
      delete payload.user_id;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && payload.client_id && isMissingColumn(error, 'client_id')) {
      delete payload.client_id;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && isMissingColumn(error, 'stat_total')) {
      delete payload.stat_total;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && isMissingColumn(error, 'hp_end')) {
      delete payload.hp_end;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && isMissingColumn(error, 'kills')) {
      delete payload.kills;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error && isMissingColumn(error, 'steps')) {
      delete payload.steps;
      const retry = await supabase.from('scores').insert(payload);
      error = retry.error;
    }
    if (error) {
      markSupabaseMaintenanceFromError(error);
      return false;
    }
    noteSupabaseSuccess();
    return true;
  }

  async function flushScoreQueue() {
    if (scoreQueueBusy) return;
    const queue = loadScoreQueue();
    if (!queue.length) return;
    scoreQueueBusy = true;
    const remaining = [];
    let posted = false;
    try {
      const supabase = await getSupabaseClient();
      for (const entry of queue) {
        const payload = entry?.payload;
        if (!payload) continue;
        const ok = await sendScorePayload(supabase, { ...payload });
        if (!ok) {
          remaining.push(entry);
          if (isSupabaseMaintenance()) break;
        } else {
          posted = true;
        }
      }
    } catch (err) {
      markSupabaseMaintenanceFromError(err);
      remaining.push(...queue);
    }
    saveScoreQueue(remaining);
    scoreQueueBusy = false;
    if (posted) {
      rankStatus.textContent = 'キューに保存したスコアを送信しました';
    }
  }

  function scheduleScoreQueueFlush() {
    window.addEventListener('online', () => {
      flushScoreQueue().catch(err => console.warn('score queue flush failed', err));
    });
    window.setInterval(() => {
      if (isSupabaseMaintenance() || loadScoreQueue().length) {
        flushScoreQueue().catch(err => console.warn('score queue flush failed', err));
      }
    }, SCORE_QUEUE_RETRY_MS);
  }

  function isMissingColumn(error, name) {
    const msg = String(error?.message || '');
    return msg.includes(`\"${name}\"`);
  }

  function parseMissingColumn(error) {
    const msg = String(error?.message || '');
    const match = msg.match(/column \"([^\"]+)\"/);
    return match ? match[1] : null;
  }

  async function getUserId(supabase) {
    try {
      const { data } = await supabase.auth.getSession();
      return data?.session?.user?.id || null;
    } catch (_) {
      return null;
    }
  }

  async function submitScore(score, cleared) {
    rankStatus.textContent = 'ダメージ送信中...';
    rankList.innerHTML = '';
    try {
      const supabase = await getSupabaseClient();
      const name = getNickname();
      const clientId = getClientId();
      const userId = await getUserId(supabase);
      const statTotal = player.atk + player.spd + player.def + player.luc + player.maxHp + player.mp;
      const payload = {
        name,
        score,
        result: cleared ? 'clear' : 'over',
        game: 'maou-war',
        stat_total: statTotal,
        hp_end: player.hp,
        kills: player.kills,
        steps: player.steps
      };
      if (clientId) payload.client_id = clientId;
      if (userId) payload.user_id = userId;
      if (isSupabaseMaintenance()) {
        queueScorePayload({ ...payload });
        rankStatus.textContent = 'メンテ中のためキューに保存しました';
        return;
      }
      await flushScoreQueue();
      const ok = await sendScorePayload(supabase, { ...payload });
      if (!ok) {
        if (isSupabaseMaintenance()) {
          queueScorePayload({ ...payload });
          rankStatus.textContent = 'メンテ中のためキューに保存しました';
        } else {
          rankStatus.textContent = 'ダメージ送信に失敗しました';
        }
        return;
      }
      rankStatus.textContent = 'ランキング更新中...';
      await loadRanking(supabase);
      rankStatus.textContent = 'ダメージ送信完了';
    } catch (err) {
      console.warn('score submit failed', err);
      markSupabaseMaintenanceFromError(err);
      if (isSupabaseMaintenance()) {
        queueScorePayload({
          name: getNickname(),
          score,
          result: cleared ? 'clear' : 'over',
          game: 'maou-war',
          stat_total: player.atk + player.spd + player.def + player.luc + player.maxHp + player.mp,
          hp_end: player.hp,
          kills: player.kills,
          steps: player.steps,
          client_id: getClientId()
        });
        rankStatus.textContent = 'メンテ中のためキューに保存しました';
      } else {
        rankStatus.textContent = 'ランキングを取得できませんでした';
      }
    }
  }

  async function fetchRankingRows(supabase, columns, filterGame) {
    const baseQuery = supabase.from('scores')
      .select(columns.join(', '))
      .order('score', { ascending: false })
      .order('created_at', { ascending: true })
      .limit(12);
    const query = filterGame ? baseQuery.eq('game', 'maou-war') : baseQuery;
    const { data, error } = await query;
    if (!error) return { data, columns, filterGame };
    const missing = parseMissingColumn(error);
    if (missing && columns.includes(missing)) {
      const nextColumns = columns.filter(col => col !== missing);
      return fetchRankingRows(supabase, nextColumns, filterGame);
    }
    if (missing === 'game' && filterGame) {
      return fetchRankingRows(supabase, columns, false);
    }
    return { data: null, error };
  }

  async function loadRanking(supabase) {
    const columns = ['name', 'score', 'created_at', 'result', 'stat_total', 'hp_end', 'kills', 'steps'];
    const { data, columns: usedColumns, error } = await fetchRankingRows(supabase, columns, true);
    if (error) {
      rankStatus.textContent = 'ランキング取得に失敗しました';
      return;
    }
    rankList.innerHTML = '';
    if (!data || !data.length) {
      rankList.innerHTML = '<li class="rank-item">まだ記録がありません。</li>';
      return;
    }
    data.forEach((row, idx) => {
      const meta = [];
      if (usedColumns.includes('result') && row.result) {
        meta.push(row.result === 'clear' ? 'CLEAR' : 'OVER');
      }
      if (usedColumns.includes('stat_total') && row.stat_total != null) {
        meta.push(`総力:${row.stat_total}`);
      }
      if (usedColumns.includes('hp_end') && row.hp_end != null) {
        meta.push(`たいりょく:${row.hp_end}`);
      }
      if (usedColumns.includes('kills') && row.kills != null) {
        meta.push(`討伐:${row.kills}`);
      }
      const li = document.createElement('li');
      li.className = 'rank-item';
      li.innerHTML = `<span>${idx + 1}. ${row.name}</span><span>${row.score}ダメージ</span>${meta.length ? `<small>${meta.join(' / ')}</small>` : ''}`;
      rankList.appendChild(li);
    });
  }

  function endGame(cleared) {
    if (gameOver) return;
    gameOver = true;
    const score = computeScore(cleared);
    const bossCoins = Math.max(0, lastBossLevel);
    if (bossCoins) addCoins(bossCoins, `勇者Lv${bossCoins}`);
    resultOverlay.classList.add('is-open');
    resultTitle.textContent = '戦い終了';
    resultSummary.textContent = `ボスダメージ: ${player.bossDamage}`;
    resultStats.innerHTML = `
      <div class="stat"><span>たいりょく</span><strong>${player.hp}/${player.maxHp}</strong></div>
      <div class="stat"><span>ぼすだめーじ</span><strong>${player.bossDamage}</strong></div>
      <div class="stat"><span>ほすう</span><strong>${player.steps}</strong></div>
      <div class="stat"><span>とうばつ</span><strong>${player.kills}</strong></div>
      <div class="stat"><span>チャリン</span><strong>${player.coins}</strong></div>
      <div class="stat"><span>こうげき/はやさ/ぼうぎょ</span><strong>${player.atk}/${player.spd}/${player.def}</strong></div>
      <div class="stat"><span>うん</span><strong>${player.luc}</strong></div>
    `;
    submitScore(score, cleared);
  }

  function resetGame() {
    player.baseStats = { ...BASE_STATS };
    player.level = 1;
    player.bossDamage = 0;
    player.itemsCollected = 0;
    player.hp = BASE_STATS.hp;
    player.maxHp = BASE_STATS.hp;
    player.mp = BASE_STATS.mp;
    player.maxMp = BASE_STATS.mp;
    player.kills = 0;
    player.steps = 0;
    player.gear.accessory = null;
    player.gearBonus = { atk: 0, spd: 0, def: 0, luc: 0 };
    player.gearInventory = [];
    player.skills = {};
    player.shield = 0;
    player.tagCounts = createTagCounter();
    player.awakenedTags = {};
    player.synergyTaken = {};
    player.synergyPerks = {};
    player.statTilesCollected = 0;
    player.activeStatMode = null;
    player.trailStatCounts = createStatCounter();
    player.shopLevels = createShopCounter();
    player.shopPurchased = createShopPurchaseState();
    player.hasKey = false;
    treasureOpenedCount = 0;
    pendingSynergyQueue = [];
    activeChoiceContext = null;
    skillChoiceResolver = null;
    player.poisonStacks = 0;
    player.poisonSteps = 0;
    selectedGearId = null;
    selectedSkillId = null;
    gameOver = false;
    battleActive = false;
    isAutoPathMoving = false;
    isChoosingSkill = false;
    isMoving = false;
    moveAnim = null;
    warpSelectionActive = false;
    playerFacing = 'down';
    lastBossLevel = 0;
    routeInsightSeen = new Set();
    resultOverlay.classList.remove('is-open');
    battleOverlay.classList.remove('is-open');
    if (skillChoiceOverlay) {
      skillChoiceOverlay.classList.remove('is-open');
      skillChoiceOverlay.setAttribute('aria-hidden', 'true');
    }
    setChoiceOverlayText(DEFAULT_CHOICE_TITLE, DEFAULT_CHOICE_SUBTITLE);
    updateSkillRerollState();
    clearRouteLogTyping();
    if (footerLog) footerLog.innerHTML = '';
    if (sheetLog) sheetLog.innerHTML = '';
    buildMap();
    updateViewToggleLabel();
    resizeCanvas();
    updateStats();
    renderMap();
    addLog('冒険を開始した');
    addLog('マップをクリックするとA*で目的地まで移動する');
    addLog('基礎能力床: 攻2 / 速2 / 体2 / 防1 / 運1 (計8)');
    addLog('能力床を踏むとモード切替。以後の移動先がその能力床に塗り替わる');
    addLog('中央右上の魔法陣を踏むと転移モードになる(現在地クリックで解除)');
    maybeLogRouteInsight();
  }

  document.getElementById('retryBtn').addEventListener('click', resetGame);

  function setSheetOpen(open) {
    if (!statusSheet) return;
    statusSheet.classList.toggle('is-open', open);
    statusSheet.setAttribute('aria-hidden', open ? 'false' : 'true');
  }
  if (openStatusBtn) openStatusBtn.addEventListener('click', () => setSheetOpen(true));
  if (closeStatusBtn) closeStatusBtn.addEventListener('click', () => setSheetOpen(false));
  if (toggleViewBtn) {
    toggleViewBtn.addEventListener('click', () => {
      if (battleActive || gameOver || isMoving) return;
      setViewMode(!fullMapView);
    });
  }
  if (statusSheet) {
    statusSheet.addEventListener('click', (event) => {
      if (event.target === statusSheet) setSheetOpen(false);
    });
  }
  const sheetTabs = Array.from(document.querySelectorAll('.sheet-tab'));
  const sheetPanels = Array.from(document.querySelectorAll('.sheet-panel'));
  const setSheetTab = (name) => {
    sheetTabs.forEach(tab => tab.classList.toggle('is-active', tab.dataset.tab === name));
    sheetPanels.forEach(panel => panel.classList.toggle('is-active', panel.dataset.panel === name));
  };
  sheetTabs.forEach(tab => {
    tab.addEventListener('click', () => setSheetTab(tab.dataset.tab));
  });
  window.addEventListener('resize', resizeCanvas);
  mapCanvas.addEventListener('pointerdown', handleMapClick, { passive: false });
  scheduleScoreQueueFlush();
  flushScoreQueue().catch(err => console.warn('score queue flush failed', err));

  buildMap();
  updateViewToggleLabel();
  resizeCanvas();
  updateStats();
  addLog('冒険を開始した');
  addLog('マップをクリックして1マス進む');
  addLog('基礎能力床: 攻2 / 速2 / 体2 / 防1 / 運1 (計8)');
  addLog('能力床を踏むとモード切替。以後の移動先がその能力床に塗り替わる');
  addLog('中央右上の魔法陣を踏むと転移モードになる(現在地クリックで解除)');
  maybeLogRouteInsight();
})();
</script>
<script>
  (() => {
    const ad = document.querySelector('.ad-footer ins.adsbygoogle');
    if (!ad) return;
    if (ad.getAttribute('data-adsbygoogle-status') === 'done') return;
    try {
      (window.adsbygoogle = window.adsbygoogle || []).push({});
    } catch (err) {
      // no-op
    }
  })();
</script>
</body>
</html>
