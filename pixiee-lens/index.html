<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>PiXiEELENS</title>
<meta content="PiXiEELENS は全画面カメラとドットモードを備えた実験ページです。" name="description"/>
<meta content="#050812" name="theme-color"/>
<meta content="website" property="og:type"/>
<meta content="PiXiEELENS" property="og:title"/>
<meta content="PiXiEELENS は全画面カメラとドットモードを備えた実験ページです。" property="og:description"/>
<meta content="https://pixieed.jp/pixiee-lens/ogp.png" property="og:image"/>
<meta content="https://pixieed.jp//pixiee-lens/" property="og:url"/>
<meta content="summary_large_image" name="twitter:card"/>
<meta content="PiXiEELENS" name="twitter:title"/>
<meta content="PiXiEELENS は全画面カメラとドットモードを備えた実験ページです。" name="twitter:description"/>
<meta content="https://pixieed.jp/pixiee-lens/ogp.png" name="twitter:image"/>
<meta content="20241102-01" name="build-version"/>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9801602250480253"></script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-SZPVXMX85G"></script>
<script>
    const GA_MEASUREMENT_ID = 'G-SZPVXMX85G';
    const GA_PAGE_PATH = '/pixiee-lens/';
    const PROJECT_SLUG = 'pixiee-lens';
    const PROJECT_NAME = 'PiXiEELENS';
    const PROJECT_TYPE = 'tool';
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', GA_MEASUREMENT_ID, {
      page_path: GA_PAGE_PATH,
      page_title: document.title
    });
    gtag('event', 'project_open', {
      project_slug: PROJECT_SLUG,
      project_type: PROJECT_TYPE,
      project_name: PROJECT_NAME
    });
    gtag('event', 'project_open_pixiee_lens');
  </script>



<style>
    :root {
      color-scheme: dark;
      --bg: radial-gradient(circle at 20% 15%, rgba(123, 207, 255, 0.18), transparent 55%), radial-gradient(circle at 80% 8%, rgba(255, 143, 246, 0.15), transparent 50%), #050812;
      --fg: #e7eeff;
      --muted: #96a6cb;
      --accent: #7bcfff;
      font-family: "Inter", "Hiragino Sans", "Noto Sans JP", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      --hud-padding: clamp(18px, 4vw, 42px);
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --ad-header-offset: 52px; /* 40pxバナー + 余白の目安 */
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }
    main {
      position: relative;
      width: 100vw;
      height: 100dvh;
      padding-top: calc(var(--ad-header-offset) + var(--safe-top));
    }
    .update-toast {
      position: fixed;
      left: 50%;
      bottom: calc(var(--hud-padding) + var(--safe-bottom));
      transform: translateX(-50%);
      width: min(92vw, 420px);
      background: rgba(8, 12, 24, 0.92);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(123, 207, 255, 0.28);
      border-radius: 18px;
      box-shadow: 0 22px 48px rgba(0, 0, 0, 0.55);
      color: var(--fg);
      padding: 16px 20px;
      z-index: 50;
      pointer-events: auto;
    }
    .update-toast__body {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .update-toast__message {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      color: var(--fg);
    }
    .update-toast__actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .update-toast__btn {
      flex: 1 1 auto;
      min-width: 120px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(123, 207, 255, 0.35);
      background: rgba(6, 10, 22, 0.8);
      color: var(--fg);
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .update-toast__btn:hover,
    .update-toast__btn:focus-visible {
      outline: none;
      border-color: rgba(123, 207, 255, 0.65);
      background: rgba(10, 18, 34, 0.95);
      transform: translateY(-1px);
    }
    .update-toast__btn--primary {
      background: linear-gradient(135deg, rgba(123, 207, 255, 0.9), rgba(143, 132, 255, 0.9));
      border: 1px solid rgba(123, 207, 255, 0.8);
      color: #050812;
      text-shadow: none;
    }
    .update-toast__btn--primary:hover,
    .update-toast__btn--primary:focus-visible {
      background: linear-gradient(135deg, rgba(143, 199, 255, 1), rgba(173, 162, 255, 1));
      border-color: rgba(143, 199, 255, 0.95);
    }
    .qr-readout {
      position: fixed;
      left: calc(var(--hud-padding) + var(--safe-left));
      bottom: calc(var(--hud-padding) + var(--safe-bottom) + 10px);
      width: min(460px, 94vw);
      background: rgba(8, 12, 24, 0.9);
      border: 1px solid rgba(123, 207, 255, 0.28);
      border-radius: 16px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.48);
      padding: 14px 16px;
      z-index: 55;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      position: fixed;
    }
    .qr-readout__header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .qr-readout__title {
      font-weight: 700;
      letter-spacing: 0.06em;
    }
    .qr-readout__state {
      margin-left: auto;
      font-size: 0.85rem;
      padding: 4px 10px;
      border-radius: 10px;
      background: rgba(123, 207, 255, 0.18);
      border: 1px solid rgba(123, 207, 255, 0.3);
      color: var(--accent);
      letter-spacing: 0.04em;
    }
    .qr-readout__close {
      margin-left: auto;
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid rgba(123, 207, 255, 0.35);
      background: rgba(6, 10, 22, 0.8);
      color: var(--fg);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.18s ease;
    }
    .qr-readout__close:hover,
    .qr-readout__close:focus-visible {
      background: rgba(123, 207, 255, 0.15);
      border-color: rgba(123, 207, 255, 0.6);
      outline: none;
      transform: translateY(-1px);
    }
    .qr-readout__close::before,
    .qr-readout__close::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 2px;
      background: currentColor;
      border-radius: 999px;
    }
    .qr-readout__close::before {
      transform: rotate(45deg);
    }
    .qr-readout__close::after {
      transform: rotate(-45deg);
    }
    .qr-readout__message {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
      font-size: 0.95rem;
    }
    .qr-readout__result {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(231, 238, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .qr-readout__label {
      margin: 0;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: rgba(231, 238, 255, 0.75);
    }
    .qr-readout__preview {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      background: rgba(12, 16, 28, 0.65);
      border: 1px solid rgba(123, 207, 255, 0.18);
      border-radius: 12px;
    }
    .qr-readout__preview canvas {
      width: 180px;
      height: 180px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #000;
      border-radius: 8px;
      border: 1px solid rgba(123, 207, 255, 0.25);
    }
    .qr-readout__text {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      word-break: break-all;
      white-space: pre-wrap;
    }
    .qr-readout__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .qr-readout__actions .option-button {
      flex: 1 1 120px;
      text-align: center;
      padding: 10px 12px;
    }
    .qr-readout--detected {
      border-color: rgba(123, 207, 255, 0.55);
      box-shadow: 0 18px 44px rgba(123, 207, 255, 0.18), 0 12px 38px rgba(0, 0, 0, 0.38);
    }
    .lens-ad-banner{
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: min(360px, 92vw);
      height: 40px;
      padding-top: calc(var(--safe-top) + 6px);
      box-sizing: border-box;
      z-index: 70;
      display:flex;
      justify-content:center;
      align-items:center;
      background: #000;
      border-bottom:1px solid rgba(255,255,255,0.08);
      pointer-events:auto;
    }
    .lens-ad-banner ins{
      display:block;
      width:320px;
      max-width:320px;
      height:40px;
      overflow:hidden;
    }
    .capture-preview__ad{
      margin: 12px 0 8px;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .capture-preview__ad ins{
      display:block;
      width: min(320px, 95vw);
      height: 50px;
      max-height: 60px;
      overflow:hidden;
    }
    @media (max-width: 520px) {
      .update-toast {
        padding: 14px 16px;
      }
      .update-toast__actions {
        flex-direction: column;
      }
      .update-toast__btn {
        width: 100%;
      }
      .qr-readout {
        left: clamp(12px, 4vw, 18px);
        right: clamp(12px, 4vw, 18px);
        width: auto;
        bottom: calc(var(--hud-padding) + var(--safe-bottom) + 6px);
      }
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #020409;
      filter: none;
      z-index: 1;
    }
    .dot-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      pointer-events: none;
      z-index: 2;
    }
    .aspect-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.25s ease;
    }
    .aspect-shade {
      flex: 0 0 auto;
      width: 100%;
      background: #000;
      pointer-events: none;
      transition: height 0.25s ease;
    }
    .aspect-middle {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      pointer-events: none;
    }
    .aspect-side-shade {
      flex: 0 0 auto;
      height: 100%;
      background: #000;
      pointer-events: none;
      transition: width 0.25s ease;
    }
    .aspect-frame {
      flex: 0 0 auto;
      width: 0;
      height: 0;
      pointer-events: none;
      transition: width 0.25s ease, height 0.25s ease;
    }
    .hud {
      position: absolute;
      inset: 0;
      text-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
      pointer-events: none;
      z-index: 5;
      width: 100%;
    }
    .hud-top {
      position: absolute;
      top: calc(var(--hud-padding) + var(--safe-top) + var(--ad-header-offset));
      left: calc(var(--hud-padding) + var(--safe-left));
      right: calc(var(--hud-padding) + var(--safe-right));
      display: flex;
      flex-direction: column;
      gap: 18px;
      pointer-events: none;
    }
    .hud-top__bar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: nowrap;
      gap: 16px;
      width: 100%;
    }
    .hud-top__actions {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      flex-wrap: wrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .hud-top__actions--right {
      margin-left: auto;
      justify-content: flex-end;
      flex: 0 0 auto;
    }
    .hud-top__panel-wrap {
      display: flex;
      justify-content: flex-end;
      pointer-events: auto;
    }
    .hud-top__panel-wrap > * {
      width: min(360px, 92vw);
    }
    .hud-top__panel-wrap--left {
      justify-content: flex-start;
    }
    .hud-top__panel-wrap--right {
      justify-content: flex-end;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    p {
      margin: 0;
      line-height: 1.6;
      font-size: clamp(0.9rem, 2vw, 1.05rem);
      color: var(--muted);
    }
    .hud-bottom {
      position: absolute;
      bottom: calc(var(--hud-padding) + var(--safe-bottom));
      left: calc(var(--hud-padding) + var(--safe-left));
      right: calc(var(--hud-padding) + var(--safe-right));
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      pointer-events: none;
    }
    .hud-bottom__actions {
      position: relative;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: clamp(12px, 4vw, 20px);
      width: 100%;
      pointer-events: none;
    }
    .hud-bottom__actions > * {
      pointer-events: auto;
    }
    .hud-bottom__actions-group {
      display: inline-flex;
      align-items: flex-end;
      gap: clamp(10px, 3vw, 16px);
      flex: 0 0 auto;
    }
    .hud-bottom__center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      gap: 12px;
      flex: 0 1 auto;
      pointer-events: auto;
      width: clamp(160px, 45vw, 220px);
    }
    .hud-bottom__capture-slot {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: clamp(60px, 18vw, 96px);
      height: clamp(60px, 18vw, 96px);
      pointer-events: auto;
      margin-bottom: 0;
    }
    body.is-landscape .hud-bottom__capture-slot {
      display: none;
    }
    .hud-landscape-capture {
      position: fixed;
      top: 50%;
      right: calc(var(--hud-padding) + var(--safe-right));
      transform: translateY(-50%);
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 6;
    }
    body.is-landscape .hud-landscape-capture {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(12px, 3vw, 18px);
    }
    .hud-landscape-capture > * {
      pointer-events: auto;
    }
    .zoom-meter {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      width: 100%;
      max-width: 220px;
      margin-inline: auto;
      pointer-events: auto;
      transition: transform 0.22s ease, opacity 0.22s ease;
      transform-origin: center top;
    }
    .zoom-meter.is-collapsed {
      opacity: 0.8;
      transform: translateY(6px) scaleY(0.74);
    }
    .zoom-meter.is-expanded {
      opacity: 1;
      transform: translateY(0) scaleY(1);
    }
    .zoom-meter__tape {
      position: relative;
      width: 100%;
      padding: 18px 12px;
      overflow: hidden;
      background: transparent;
      touch-action: none;
      cursor: ew-resize;
      user-select: none;
    }
    .zoom-meter.is-collapsed .zoom-meter__tape {
      padding: 12px 10px;
    }
    .zoom-meter__tape::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      background: rgba(231, 238, 255, 0.28);
      transform: translateY(-50%);
      pointer-events: none;
    }
    .zoom-meter__indicator {
      position: absolute;
      top: 8px;
      bottom: 8px;
      left: 50%;
      width: 2px;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(123, 207, 255, 0.55);
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 2;
    }
    .zoom-meter.is-collapsed .zoom-meter__indicator {
      top: 6px;
      bottom: 6px;
    }
    .zoom-meter.is-collapsed .zoom-meter__tape::before {
      background: rgba(231, 238, 255, 0.2);
    }
    .zoom-meter__scale {
      position: relative;
      overflow: hidden;
      width: 100%;
      pointer-events: none;
      mask-image: linear-gradient(90deg, transparent 0 4%, #000 20% 80%, transparent 96% 100%);
    }
    .zoom-meter__scale-track {
      display: inline-flex;
      align-items: center;
      gap: clamp(5px, 1.1vw, 9px);
      transform: translateX(0);
      transition: transform 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 6px 0;
      will-change: transform;
      pointer-events: none;
    }
    .zoom-meter__scale-track.is-static {
      transition: none;
    }
    .zoom-meter__scale-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 48px;
      font-size: 0.95rem;
      font-weight: 500;
      color: rgba(231, 238, 255, 0.55);
      position: relative;
      pointer-events: none;
      transition: transform 0.2s ease, color 0.2s ease;
    }
    .zoom-meter__scale-value::after {
      content: '';
      position: absolute;
      bottom: -12px;
      left: 50%;
      width: 2px;
      height: 8px;
      background: rgba(231, 238, 255, 0.28);
      transform: translateX(-50%);
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value {
      transform: scale(0.86);
      font-size: 0.85rem;
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value::after {
      height: 6px;
    }
    .zoom-meter__scale-value.is-active {
      color: var(--accent);
      font-weight: 600;
      transform: scale(1.12);
    }
    .zoom-meter__scale-value.is-active::after {
      height: 14px;
      background: var(--accent);
    }
    .zoom-meter__scale-value--major {
      font-size: 1.05rem;
      font-weight: 600;
      color: rgba(231, 238, 255, 0.85);
    }
    .zoom-meter__scale-value--major::after {
      height: 12px;
      width: 3px;
      background: rgba(231, 238, 255, 0.42);
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value--major {
      font-size: 0.94rem;
      transform: scale(0.95);
    }
    .zoom-meter__slider {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: default;
      -webkit-appearance: none;
      appearance: none;
      z-index: 3;
      pointer-events: none;
    }
    .zoom-meter__slider::-webkit-slider-thumb,
    .zoom-meter__slider::-moz-range-thumb,
    .zoom-meter__slider::-ms-thumb {
      width: 0;
      height: 0;
      appearance: none;
      -webkit-appearance: none;
      border: 0;
      background: transparent;
    }
    .zoom-meter__color {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 8px 12px 10px;
    }
    .zoom-meter__control-group {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
      width: clamp(220px, 60vw, 360px);
    }
    .zoom-meter__control-header {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      min-width: 0;
      gap: 6px;
    }
    .zoom-meter__control-title {
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
      color: rgba(231, 238, 255, 0.72);
    }
    .zoom-meter__control-value {
      font-weight: 700;
      color: var(--accent);
      font-size: 0.8rem;
      letter-spacing: 0.04em;
    }
    .zoom-meter__control-slider {
      flex: 1 1 auto;
      min-width: clamp(200px, 55vw, 420px);
      -webkit-appearance: none;
      appearance: none;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(231, 238, 255, 0.15), rgba(231, 238, 255, 0.45));
      outline: none;
      cursor: pointer;
      box-shadow: inset 0 0 12px rgba(5, 8, 18, 0.6);
    }
    .zoom-meter__control-slider--hue {
      background: linear-gradient(90deg, #ff004c, #ff7b00, #ffe600, #4ddf00, #00c2ff, #6a4dff, #ff004c);
    }
    .zoom-meter__control-slider--saturation {
      background: linear-gradient(90deg, rgba(231, 238, 255, 0.1), rgba(123, 207, 255, 0.85));
    }
    .zoom-meter__control-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid rgba(231, 238, 255, 0.85);
      background: #050812;
      box-shadow: 0 0 12px rgba(123, 207, 255, 0.65);
    }
    .zoom-meter__control-slider::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid rgba(231, 238, 255, 0.85);
      background: #050812;
      box-shadow: 0 0 12px rgba(123, 207, 255, 0.65);
    }
    .zoom-meter__control-slider:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.7);
      outline-offset: 3px;
    }
    .zoom-meter.is-color-mode .zoom-meter__tape {
      display: none;
    }
    .zoom-meter.is-color-mode .zoom-meter__color {
      display: flex;
    }
    body.is-landscape .zoom-meter {
      width: clamp(320px, 36vw, 420px);
      margin-inline: auto;
    }
    body.is-landscape .hud-bottom__center {
      flex-direction: row;
      align-items: flex-end;
      justify-content: center;
      gap: 18px;
      position: fixed;
      bottom: calc(var(--safe-bottom) + 12px);
      left: 50%;
      transform: translateX(-50%);
      width: min(520px, 88vw);
      pointer-events: none;
    }
    body.is-landscape .hud-bottom__center > * {
      pointer-events: auto;
    }
    body.is-landscape .hud-bottom__center .zoom-meter {
      width: clamp(280px, 32vw, 360px);
      margin-inline: 0;
    }
    body.is-landscape .zoom-meter__tape {
      padding: 18px 16px;
    }
    .hud-bottom__menus {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
      pointer-events: auto;
    }
    .hud-bottom__menus > * {
      width: min(420px, 92vw);
    }
    .camera-permission {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1100;
    }
    .camera-permission.is-visible {
      display: flex;
    }
    .camera-permission__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 8, 18, 0.78);
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }
    .camera-permission__panel {
      position: relative;
      width: min(440px, 92vw);
      background: rgba(9, 13, 28, 0.94);
      border: 1px solid rgba(123, 207, 255, 0.38);
      border-radius: 22px;
      padding: clamp(18px, 4vw, 28px);
      box-shadow: 0 24px 56px rgba(3, 5, 12, 0.52);
      display: flex;
      flex-direction: column;
      gap: 18px;
      pointer-events: auto;
    }
    .camera-permission__title {
      margin: 0;
      font-size: clamp(1rem, 2.6vw, 1.4rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .camera-permission__message {
      margin: 0;
      color: rgba(231, 238, 255, 0.85);
      font-size: clamp(0.92rem, 2.5vw, 1.05rem);
      line-height: 1.7;
    }
    .camera-permission__actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }
    .camera-permission__button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 11px 24px;
      border-radius: 999px;
      border: 1px solid rgba(123, 207, 255, 0.3);
      background: rgba(123, 207, 255, 0.18);
      color: #fff;
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 0.88rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .camera-permission__button:hover {
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.5);
    }
    .camera-permission__button:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.75);
      outline-offset: 3px;
    }
    .camera-permission__button--primary {
      background: rgba(123, 207, 255, 0.32);
      border-color: rgba(123, 207, 255, 0.6);
    }
    .camera-permission__button--primary:hover {
      background: rgba(123, 207, 255, 0.42);
      border-color: rgba(123, 207, 255, 0.75);
    }
    .capture-preview {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
    }
    .capture-preview.is-visible {
      display: flex;
    }
    .capture-preview__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 8, 18, 0.78);
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }
    .capture-preview__panel {
      position: relative;
      width: min(480px, 92vw);
      max-height: min(720px, 88vh);
      background: rgba(9, 13, 28, 0.92);
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 20px;
      box-shadow: 0 24px 56px rgba(3, 5, 12, 0.52);
      padding: clamp(18px, 4vw, 26px);
      display: flex;
      flex-direction: column;
      gap: 18px;
      pointer-events: auto;
      overflow-y: auto;
    }
    .capture-preview__body {
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow: hidden;
    }
    .capture-preview__close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(123, 207, 255, 0.25);
      background: rgba(123, 207, 255, 0.12);
      color: #fff;
      font-size: 0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .capture-preview__close::before {
      content: '\00D7';
      font-size: 1rem;
      line-height: 1;
    }
    .capture-preview__close:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.75);
      outline-offset: 2px;
    }
    .capture-preview__title {
      margin: 0;
      font-size: clamp(1rem, 2.6vw, 1.4rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .capture-preview__image-wrap {
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(7, 11, 26, 0.85);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(123, 207, 255, 0.18);
      padding: 12px;
      max-height: min(60vh, 420px);
    }
    .capture-preview__image-wrap img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }
    .capture-preview__info {
      margin: 0;
      color: rgba(231, 238, 255, 0.85);
      font-size: 0.92rem;
      line-height: 1.6;
    }
    .capture-preview__actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .capture-preview__button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      border-radius: 999px;
      border: 1px solid rgba(123, 207, 255, 0.3);
      background: rgba(123, 207, 255, 0.14);
      color: #fff;
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 0.88rem;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .capture-preview__button:hover {
      background: rgba(123, 207, 255, 0.24);
      border-color: rgba(123, 207, 255, 0.5);
    }
    .capture-preview__button--primary {
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.55);
    }
    .capture-preview__button--primary:hover {
      background: rgba(123, 207, 255, 0.4);
    }
    .hud-top__actions {
      pointer-events: auto;
    }
    .capture-button {
      position: relative;
      width: clamp(64px, 19vw, 96px);
      height: clamp(64px, 19vw, 96px);
      border-radius: 50%;
      border: 3px solid rgba(123, 207, 255, 0.6);
      background: rgba(5, 9, 18, 0.75);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45), inset 0 0 18px rgba(123, 207, 255, 0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease, background 0.18s ease;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    .capture-button:hover:enabled {
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.5), inset 0 0 22px rgba(123, 207, 255, 0.45);
      border-color: rgba(123, 207, 255, 0.8);
      background: rgba(12, 20, 36, 0.82);
    }
    .capture-button:active:enabled {
      transform: scale(0.96);
    }
    .capture-button:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.9);
      outline-offset: 4px;
    }
    .capture-button__icon {
      width: 64%;
      max-width: 72px;
      aspect-ratio: 1 / 1;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .capture-button__icon svg,
    .capture-button__icon img {
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      image-rendering: pixelated;
    }
    .stamp-panel {
      gap: 12px;
    }
    .stamp-panel__hint {
      margin: 0;
      font-size: 0.8rem;
      color: rgba(231, 238, 255, 0.7);
      letter-spacing: 0.04em;
      text-align: left;
    }
    .stamp-panel__grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(88px, 1fr));
      gap: 6px;
      max-height: min(360px, 48vh);
      overflow-y: auto;
      padding-right: 4px;
      overscroll-behavior: contain;
      scrollbar-width: thin;
      scrollbar-color: rgba(123, 207, 255, 0.35) transparent;
    }
    .stamp-panel__grid::-webkit-scrollbar {
      width: 6px;
    }
    .stamp-panel__grid::-webkit-scrollbar-track {
      background: transparent;
    }
    .stamp-panel__grid::-webkit-scrollbar-thumb {
      background: rgba(123, 207, 255, 0.35);
      border-radius: 999px;
    }
    .stamp-panel__empty {
      font-size: 0.8rem;
      color: rgba(231, 238, 255, 0.65);
      text-align: center;
      padding: 16px;
      border: 1px dashed rgba(123, 207, 255, 0.45);
      border-radius: 12px;
      letter-spacing: 0.06em;
    }
    .stamp-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 12px;
      background: rgba(26, 30, 38, 0.95);
      border: 1px solid rgba(86, 104, 140, 0.65);
      box-shadow: 0 10px 24px rgba(5, 8, 18, 0.45);
      color: inherit;
      aspect-ratio: 1 / 1;
      width: 100%;
      transition: transform 0.16s ease, background 0.16s ease;
    }
    .stamp-button.is-loading {
      opacity: 0.6;
      cursor: progress;
      transform: none;
    }
    .stamp-button:hover,
    .stamp-button:focus-visible {
      background: rgba(42, 48, 60, 0.95);
      transform: translateY(-1px);
      outline: none;
      box-shadow: 0 12px 28px rgba(5, 8, 18, 0.45);
    }
    .stamp-button:active {
      transform: translateY(1px) scale(0.96);
      box-shadow: 0 6px 18px rgba(5, 8, 18, 0.38);
    }
    .stamp-button__preview {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background: radial-gradient(circle at 30% 30%, rgba(72, 82, 104, 0.9), rgba(32, 36, 46, 0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: inset 0 1px 4px rgba(255, 255, 255, 0.12), inset 0 8px 18px rgba(0, 0, 0, 0.4);
    }
    .stamp-button__preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 10px 16px;
      border-radius: 14px;
      background: rgba(5, 9, 18, 0.65);
      border: 1px solid rgba(123, 207, 255, 0.28);
      letter-spacing: 0.05em;
      font-size: 0.85rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .controls--aspect,
    .controls--dot-scale,
    .controls--color {
      gap: 10px;
      align-items: center;
    }
    .controls--dot-scale {
      justify-content: center;
    }
    button {
      border: none;
      cursor: pointer;
      background: none;
      color: inherit;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    button:disabled {
      cursor: not-allowed;
    }
    .icon-button {
      width: 56px;
      height: 56px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      background: rgba(123, 207, 255, 0.2);
      border: 1px solid rgba(123, 207, 255, 0.35);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.32);
      transition: transform 0.18s ease, background 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
      position: relative;
      color: var(--fg);
    }
    .icon-button:hover:enabled {
      transform: translateY(-1px);
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.55);
    }
    .icon-button:active:enabled {
      transform: translateY(1px);
    }
    .icon-button.is-active {
      background: rgba(123, 207, 255, 0.36);
      border-color: rgba(123, 207, 255, 0.75);
    }
    .icon-button:disabled {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: none;
      color: rgba(255, 255, 255, 0.5);
    }
    .option-button {
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 12px;
      background: rgba(5, 9, 18, 0.65);
      color: inherit;
      padding: 10px 16px;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
    }
    .option-button:hover,
    .option-button:focus-visible {
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.55);
      outline: none;
    }
    .option-button.is-active {
      background: rgba(123, 207, 255, 0.4);
      border-color: rgba(123, 207, 255, 0.8);
      color: #050812;
    }
    .option-button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
    }
    .select-control {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }
    .select-control__label {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      color: rgba(231, 238, 255, 0.75);
    }
    .select-control select {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background: linear-gradient(150deg, rgba(123, 207, 255, 0.22), rgba(5, 9, 18, 0.88));
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 12px;
      padding: 12px 16px;
      font: inherit;
      color: inherit;
      letter-spacing: 0.08em;
      box-shadow: inset 0 0 18px rgba(123, 207, 255, 0.18);
      transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }
    .select-control select:hover {
      border-color: rgba(123, 207, 255, 0.55);
    }
    .select-control select:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.85);
      outline-offset: 3px;
    }
    .select-control select:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    .dot-settings-panel {
      gap: 8px;
    }
    .dot-settings-panel__row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: center;
      gap: 10px;
    }
    .dot-settings-panel__row .select-control {
      flex: 1 1 150px;
      min-width: 120px;
    }
    .dot-settings-panel__row .palette-toggle {
      flex: 0 0 auto;
      align-self: stretch;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      padding: 8px 14px;
    }
    .camera-settings-panel {
      gap: 12px;
    }
    .controls--camera {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .slider-control__label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      color: rgba(231, 238, 255, 0.75);
    }
    .slider-control__value {
      font-size: 0.8rem;
      color: var(--muted);
    }
    @media (orientation: landscape) and (max-height: 600px) {
      .menu-panel {
        padding: 8px 12px;
        max-height: min(70svh, 70vh);
      }
      .camera-settings-panel {
        gap: 10px;
      }
    }
    .slider-control input[type="range"] {
      width: 100%;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: rgba(123, 207, 255, 0.2);
      outline: none;
      box-shadow: inset 0 0 12px rgba(123, 207, 255, 0.22);
    }
    .slider-control input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      transition: transform 0.18s ease;
    }
    .slider-control input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(0.9);
    }
    .slider-control input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
    }
    .slider-control input[type="range"]::-ms-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
    }
    .slider-control input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .slider-control input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .camera-settings__reset {
      padding: 8px 16px;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
    }
    .control-icon {
      width: 26px;
      height: 26px;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
    }
    .control-icon rect,
    .control-icon path {
      fill: currentColor;
      opacity: 0.88;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .pixel-preview {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 4;
    }
    .pixel-preview > * {
      pointer-events: auto;
    }
    .pixel-canvas {
      position: relative;
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      border-radius: 12px;
      background: transparent;
      z-index: 1;
    }
    .pixel-canvas--tint {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      background: transparent;
      pointer-events: none;
      image-rendering: pixelated;
      z-index: 2;
      mix-blend-mode: multiply;
      filter: none;
    }
    .pixel-canvas--colorized {
      filter: saturate(0) brightness(1.05);
    }
    .pixel-canvas-wrap {
      position: absolute;
      display: inline-block;
      margin: 0;
      pointer-events: auto;
      left: 24px;
      top: 24px;
      touch-action: none;
      cursor: move;
    }
    .pixel-canvas-wrap::after {
      content: '';
      position: absolute;
      inset: -6px;
      border: 2px dashed rgba(123, 207, 255, 0.6);
      border-radius: 10px;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
    }
    .menu-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      flex-direction: column;
      gap: 8px;
      margin: 0;
      padding: 10px 14px;
      border-radius: 14px;
      background: rgba(5, 9, 18, 0.9);
      border: 1px solid rgba(123, 207, 255, 0.32);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.45);
      max-height: min(78svh, 78vh);
      width: min(480px, 92vw);
      overflow-y: auto;
      z-index: 20;
    }
    .menu-panel.is-open {
      display: flex;
    }
    .menu-panel > .controls {
      flex-wrap: wrap;
      gap: 10px;
    }
    .menu-panel > .controls .option-button {
      flex: 1 1 auto;
    }
    .palette-toggle {
      align-self: flex-start;
    }
    .palette-display {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px 14px;
      border: 1px solid rgba(123, 207, 255, 0.28);
      border-radius: 12px;
      background: rgba(5, 9, 18, 0.6);
    }
    .palette-display.is-visible {
      display: flex;
    }
    .palette-display__label {
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      color: var(--muted);
      text-align: center;
    }
    .palette-display__swatches {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }
    .palette-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      cursor: pointer;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
      outline: none;
      color: inherit;
      font: inherit;
      line-height: 0;
    }
    .palette-swatch:hover {
      border-color: rgba(123, 207, 255, 0.45);
      box-shadow: 0 0 0 2px rgba(123, 207, 255, 0.12);
      transform: translateY(-1px);
    }
    .palette-swatch:focus-visible {
      border-color: rgba(123, 207, 255, 0.65);
      box-shadow: 0 0 0 3px rgba(123, 207, 255, 0.28);
    }
    .palette-swatch--active {
      border-color: rgba(123, 207, 255, 0.75);
      box-shadow: 0 0 0 3px rgba(123, 207, 255, 0.32);
    }
    .palette-swatch__chip {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid rgba(0, 0, 0, 0.45);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      flex-shrink: 0;
    }
    .palette-editor {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.12);
    }
    .palette-editor[hidden] {
      display: none !important;
    }
    .palette-editor__header {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .palette-editor__preview {
      width: 36px;
      height: 36px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      background: transparent;
      flex-shrink: 0;
    }
    .palette-editor__slider {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .palette-editor__label {
      font-size: 0.8rem;
      letter-spacing: 0.06em;
      color: rgba(231, 238, 255, 0.78);
    }
    .palette-editor__slider input[type="range"] {
      flex: 1 1 auto;
      accent-color: rgba(123, 207, 255, 0.75);
    }
    .palette-editor__value {
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: rgba(231, 238, 255, 0.85);
    }
    .palette-editor__reset {
      align-self: flex-end;
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 10px;
      background: rgba(5, 9, 18, 0.6);
      color: inherit;
      font: inherit;
      padding: 6px 12px;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease;
    }
    .palette-editor__reset:hover,
    .palette-editor__reset:focus-visible {
      border-color: rgba(123, 207, 255, 0.65);
      background: rgba(123, 207, 255, 0.18);
      outline: none;
    }
    .pixel-canvas-wrap.is-active::after {
      opacity: 1;
    }
    .pixel-canvas-wrap:not(.is-active) .pixel-handle {
      display: none;
    }
    .pixel-move-handle {
      position: absolute;
      top: -10px;
      left: calc(50% - 11px);
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid rgba(0, 0, 0, 0.65);
      background: rgba(123, 207, 255, 0.9);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
      padding: 0;
      display: block;
      pointer-events: auto;
      cursor: grab;
      touch-action: none;
      transition: transform 0.15s ease, background 0.2s ease, border-color 0.2s ease;
      transform-origin: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .pixel-canvas-wrap:not(.is-active) .pixel-move-handle {
      display: none;
    }
    .pixel-move-handle:hover {
      background: rgba(123, 207, 255, 1);
      border-color: rgba(123, 207, 255, 0.8);
    }
    .pixel-move-handle:active {
      cursor: grabbing;
      transform: scale(0.96);
    }
    .pixel-handle {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid rgba(0, 0, 0, 0.65);
      background: rgba(123, 207, 255, 0.9);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
      cursor: nwse-resize;
      padding: 0;
      transition: none;
    }
    .pixel-handle:hover,
    .pixel-handle:active {
      transform: none;
    }
    .pixel-handle--nw {
      top: -10px;
      left: -10px;
      cursor: nwse-resize;
    }
    .pixel-handle--ne {
      top: -10px;
      right: -10px;
      cursor: nesw-resize;
    }
    .pixel-handle--se {
      bottom: -10px;
      right: -10px;
      cursor: nwse-resize;
    }
    .pixel-handle--sw {
      bottom: -10px;
      left: -10px;
      cursor: nesw-resize;
    }
    @media (max-width: 640px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .hud-top__bar {
        flex-wrap: nowrap;
        align-items: flex-start;
        text-align: left;
        gap: 12px;
      }
      .hud-top__actions {
        justify-content: flex-start;
        flex-wrap: wrap;
      }
      .hud-top__actions--right {
        margin-left: auto;
        justify-content: flex-end;
        flex: 0 0 auto;
      }
      .hud-top__panel-wrap {
        justify-content: flex-start;
        width: 100%;
      }
      .hud-top__panel-wrap > * {
        width: 100%;
      }
      .hud-bottom__actions {
        gap: clamp(10px, 5vw, 16px);
      }
      .hud-bottom__actions-group {
        gap: clamp(8px, 4vw, 14px);
      }
      .hud-bottom__capture-slot {
        min-width: clamp(56px, 24vw, 84px);
        height: clamp(56px, 24vw, 84px);
      }
      .hud-bottom__center {
        width: clamp(160px, 60vw, 220px);
        margin-inline: auto;
      }
      .zoom-meter {
        width: 100%;
        max-width: 220px;
        gap: 12px;
      }
      .zoom-meter__tape {
        padding: 20px 14px;
      }
      .zoom-meter__scale-track {
        gap: clamp(14px, 8vw, 24px);
      }
      .zoom-meter__scale-value {
        min-width: 42px;
      }
      .hud-bottom__menus > * {
        width: 100%;
      }
      .pixel-canvas-wrap {
        left: clamp(16px, 4vw, 24px);
        top: clamp(16px, 4vw, 24px);
      }
    }
  </style>
<link href="../character-dots/mao1.png" rel="icon" type="image/png"/>  <style id="ads-safe">
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .adsbygoogle,
    ins.adsbygoogle {
      display: block !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box;
      overflow: hidden;
    }
    .adsbygoogle iframe,
    ins.adsbygoogle iframe {
      display: block;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
  </style>
  <style id="interaction-guard">
    * {
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    input,
    textarea,
    [contenteditable] {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  <script id="interaction-guard-js">
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    document.addEventListener('dragstart', (event) => {
      event.preventDefault();
    });
  </script>
  <script id="ads-lazy">
    (function() {
      if (window.pixieedObserveAds) return;
      const pending = [];
      const hasObserverSupport = 'IntersectionObserver' in window;
      let observer = null;
      const isLoaded = (ins) => (
        ins.dataset.adsLazyLoaded === '1' ||
        ins.getAttribute('data-adsbygoogle-status') === 'done' ||
        ins.getAttribute('data-ad-status') === 'filled'
      );
      const loadAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyLoaded = '1';
        try {
          (window.adsbygoogle = window.adsbygoogle || []).push({});
        } catch (err) {
          ins.dataset.adsLazyLoaded = '';
        }
      };
      const observeAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (ins.dataset.adsLazyObserved === '1') return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyObserved = '1';
        if (!observer) {
          if (!hasObserverSupport) {
            loadAd(ins);
          } else {
            pending.push(ins);
          }
          return;
        }
        observer.observe(ins);
      };
      const observeAds = (root) => {
        const scope = root && root.querySelectorAll ? root : document;
        scope.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
      };
      window.pixieedObserveAds = observeAds;
      const setupObserver = () => {
        if (hasObserverSupport) {
          observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting || entry.intersectionRatio > 0) {
                const target = entry.target;
                if (observer) observer.unobserve(target);
                loadAd(target);
              }
            });
          }, { rootMargin: '200px 0px', threshold: 0.01 });
        }
        const queued = pending.splice(0);
        queued.forEach((ins) => {
          if (observer) {
            observer.observe(ins);
          } else {
            loadAd(ins);
          }
        });
        observeAds(document);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
      const mo = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (!(node instanceof HTMLElement)) return;
            if (node.matches && node.matches('ins.adsbygoogle')) {
              observeAd(node);
              return;
            }
            if (node.querySelectorAll) {
              node.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
            }
          });
        });
      });
      const startObserver = () => {
        if (!document.body) return;
        mo.observe(document.body, { childList: true, subtree: true });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startObserver);
      } else {
        startObserver();
      }
    })();
  </script>
</head>
<body>
<div class="lens-ad-banner">
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-9801602250480253"
       data-ad-slot="2141591954"></ins>
</div>
<main>
<video autoplay="" id="cameraFeed" muted="" playsinline=""></video>
<canvas class="dot-canvas" hidden="" id="dotCanvas"></canvas>
<div class="aspect-overlay" hidden="" id="aspectOverlay">
<div aria-hidden="true" class="aspect-shade" id="aspectShadeTop"></div>
<div aria-hidden="true" class="aspect-middle" id="aspectCenter">
<div class="aspect-side-shade" id="aspectShadeLeft"></div>
<div class="aspect-frame" id="aspectFrame"></div>
<div class="aspect-side-shade" id="aspectShadeRight"></div>
</div>
<div aria-hidden="true" class="aspect-shade" id="aspectShadeBottom"></div>
</div>
<div class="hud">
<div class="hud-top">
<div class="hud-top__bar">
<div aria-label="ドット絵コントロール" class="hud-top__actions" role="group">
<button aria-label="ドット絵を読み込む" class="icon-button" id="pixelArtBtn" type="button">
<svg aria-hidden="true" class="control-icon" shape-rendering="crispEdges" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<rect fill="#FFFFFF" height="1" width="14" x="1" y="0"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="0" y="1"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="14" y="1"></rect>
<rect fill="#FFFFFF" height="21" width="1" x="0" y="2"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="15" y="2"></rect>
<rect fill="#FFFFFF" height="1" width="7" x="16" y="3"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="22" y="4"></rect>
<rect fill="#FFFFFF" height="18" width="1" x="23" y="5"></rect>
<rect fill="#FFFFFF" height="1" width="22" x="1" y="9"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="1" y="10"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="22" y="10"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="1" y="22"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="22" y="22"></rect>
<rect fill="#FFFFFF" height="1" width="20" x="2" y="23"></rect>
</svg>
<span class="icon-button__label visually-hidden">ドット絵を読み込む</span>
</button>
<button aria-controls="stampPanel" aria-expanded="false" aria-label="スタンプを開く" class="icon-button" id="stampBtn" type="button">
<img alt="" aria-hidden="true" class="control-icon" draggable="false" src="./icon-stamp.svg"/>
<span class="icon-button__label visually-hidden">スタンプを開く</span>
</button>
<button aria-label="ドット絵を閉じる" class="icon-button icon-button--ghost" id="clearPixelBtn" type="button">
<svg aria-hidden="true" class="control-icon" shape-rendering="crispEdges" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<rect fill="#FFFFFF" height="6" width="2" x="2" y="0"></rect>
<rect fill="#FFFFFF" height="6" width="2" x="20" y="0"></rect>
<rect fill="#FFFFFF" height="4" width="1" x="1" y="1"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="4" y="1"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="19" y="1"></rect>
<rect fill="#FFFFFF" height="4" width="1" x="22" y="1"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="0" y="2"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="5" y="2"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="18" y="2"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="23" y="2"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="6" y="3"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="17" y="3"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="7" y="4"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="16" y="4"></rect>
<rect fill="#FFFFFF" height="14" width="1" x="8" y="5"></rect>
<rect fill="#FFFFFF" height="14" width="1" x="15" y="5"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="3" y="6"></rect>
<rect fill="#FFFFFF" height="12" width="1" x="9" y="6"></rect>
<rect fill="#FFFFFF" height="12" width="1" x="14" y="6"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="20" y="6"></rect>
<rect fill="#FFFFFF" height="10" width="1" x="10" y="7"></rect>
<rect fill="#FFFFFF" height="10" width="1" x="13" y="7"></rect>
<rect fill="#FFFFFF" height="8" width="2" x="11" y="8"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="7" y="13"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="16" y="13"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="6" y="14"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="17" y="14"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="5" y="15"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="18" y="15"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="4" y="16"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="19" y="16"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="3" y="17"></rect>
<rect fill="#FFFFFF" height="7" width="1" x="20" y="17"></rect>
<rect fill="#FFFFFF" height="6" width="1" x="2" y="18"></rect>
<rect fill="#FFFFFF" height="6" width="1" x="21" y="18"></rect>
<rect fill="#FFFFFF" height="4" width="1" x="1" y="19"></rect>
<rect fill="#FFFFFF" height="4" width="1" x="22" y="19"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="0" y="20"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="23" y="20"></rect>
</svg>
<span class="icon-button__label visually-hidden">ドット絵を閉じる</span>
</button>
</div>
<div aria-label="カメラ操作" class="hud-top__actions hud-top__actions--right" role="group">
<button aria-label="再接続" class="icon-button" data-mode="resume" id="cameraActionBtn" type="button">
<svg aria-hidden="true" class="control-icon" id="cameraActionIcon" shape-rendering="crispEdges" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<rect fill="#FFFFFF" height="1" width="6" x="17" y="0"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="16" y="1"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="22" y="1"></rect>
<rect fill="#FFFFFF" height="5" width="1" x="16" y="2"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="21" y="2"></rect>
<rect fill="#FFFFFF" height="5" width="1" x="23" y="2"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="20" y="3"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="19" y="4"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="18" y="5"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="17" y="6"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="22" y="6"></rect>
<rect fill="#FFFFFF" height="1" width="8" x="8" y="7"></rect>
<rect fill="#FFFFFF" height="1" width="4" x="18" y="7"></rect>
<rect fill="#FFFFFF" height="2" width="3" x="3" y="8"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="7" y="8"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="15" y="8"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="1" y="9"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="6" y="9"></rect>
<rect fill="#FFFFFF" height="1" width="4" x="10" y="9"></rect>
<rect fill="#FFFFFF" height="1" width="7" x="16" y="9"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="0" y="10"></rect>
<rect fill="#FFFFFF" height="1" width="2" x="22" y="10"></rect>
<rect fill="#FFFFFF" height="12" width="1" x="0" y="11"></rect>
<rect fill="#FFFFFF" height="12" width="1" x="23" y="11"></rect>
<rect fill="#FFFFFF" height="1" width="6" x="9" y="12"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="8" y="13"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="15" y="13"></rect>
<rect fill="#FFFFFF" height="6" width="1" x="7" y="14"></rect>
<rect fill="#FFFFFF" height="6" width="1" x="16" y="14"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="8" y="20"></rect>
<rect fill="#FFFFFF" height="1" width="1" x="15" y="20"></rect>
<rect fill="#FFFFFF" height="1" width="6" x="9" y="21"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="1" y="22"></rect>
<rect fill="#FFFFFF" height="2" width="1" x="22" y="22"></rect>
<rect fill="#FFFFFF" height="1" width="20" x="2" y="23"></rect>
</svg>
<span class="icon-button__label visually-hidden">再接続</span>
</button>
<button aria-controls="cameraSettingsPanel" aria-expanded="false" aria-label="カメラ設定" class="icon-button" id="cameraSettingsBtn" type="button">
<img alt="" aria-hidden="true" class="control-icon" src="./icon-setting.svg"/>
<span class="icon-button__label visually-hidden">カメラ設定</span>
</button>
</div>
</div>
<div class="hud-top__panel-wrap hud-top__panel-wrap--left">
<div class="menu-panel stamp-panel" hidden="" id="stampPanel">
<p class="stamp-panel__hint">スタンプを選択すると画面に追加されます。</p>
<div aria-label="スタンプ一覧" class="stamp-panel__grid" id="stampList" role="group"></div>
<p class="stamp-panel__empty" hidden="" id="stampEmptyMessage">スタンプがまだ登録されていません。</p>
</div>
</div>
<div class="hud-top__panel-wrap hud-top__panel-wrap--right">
<div class="menu-panel camera-settings-panel" hidden="" id="cameraSettingsPanel">
<div aria-label="カメラ基本設定" class="controls controls--camera" role="group">
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">明るさ</span>
<span class="slider-control__value" data-setting-value="brightness">0</span>
</span>
<input data-setting="brightness" id="cameraSettingBrightness" max="100" min="-100" step="1" type="range" value="0"/>
</label>
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">露光</span>
<span class="slider-control__value" data-setting-value="exposure">0</span>
</span>
<input data-setting="exposure" id="cameraSettingExposure" max="100" min="-100" step="1" type="range" value="0"/>
</label>
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">彩度</span>
<span class="slider-control__value" data-setting-value="saturation">0</span>
</span>
<input data-setting="saturation" id="cameraSettingSaturation" max="100" min="-100" step="1" type="range" value="0"/>
</label>
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">シャドウ</span>
<span class="slider-control__value" data-setting-value="shadows">0</span>
</span>
<input data-setting="shadows" id="cameraSettingShadows" max="100" min="-100" step="1" type="range" value="0"/>
</label>
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">コントラスト</span>
<span class="slider-control__value" data-setting-value="contrast">0</span>
</span>
<input data-setting="contrast" id="cameraSettingContrast" max="100" min="-100" step="1" type="range" value="0"/>
</label>
<label class="slider-control">
<span class="slider-control__label-row">
<span class="slider-control__label">ホワイトバランス</span>
<span class="slider-control__value" data-setting-value="whiteBalance">0</span>
</span>
<input data-setting="whiteBalance" id="cameraSettingWhiteBalance" max="100" min="-100" step="1" type="range" value="0"/>
</label>
</div>
<button class="option-button camera-settings__reset" id="cameraSettingsResetBtn" type="button">設定をリセット</button>
</div>
</div>
</div>
<div class="hud-bottom">
<div class="hud-bottom__menus">
<div class="menu-panel" hidden="" id="aspectMenu">
<div aria-label="アスペクト比" class="controls controls--aspect" role="group">
<button aria-pressed="true" class="option-button is-active" data-aspect="1:1" type="button">1:1</button>
</div>
</div>
<div class="menu-panel dot-settings-panel" hidden="" id="dotSettingsPanel">
<div class="dot-settings-panel__row">
<label class="select-control" for="dotScaleSelect">
<span class="select-control__label">ドット拡大率</span>
<select id="dotScaleSelect" name="dotScale">
<option value="1">x1</option>
<option value="2">x2</option>
<option value="3">x3</option>
<option value="4">x4</option>
<option value="5">x5</option>
</select>
</label>
<label class="select-control" for="colorDepthSelect">
<span class="select-control__label">色数</span>
<select id="colorDepthSelect" name="colorDepth">
<option value="full">８BIT（カラー）</option>
<option value="gray">８BIT（グレー）</option>
<option selected="" value="4">2BIT</option>
<option value="2">1BIT</option>
</select>
</label>
<button aria-label="パレットを表示" aria-pressed="false" class="option-button palette-toggle" id="paletteToggleBtn" type="button">パレット</button>
</div>
<div aria-hidden="true" class="palette-display" id="paletteDisplay"></div>
</div>
</div>
<div aria-label="操作" class="hud-bottom__actions" role="group">
<div class="hud-bottom__actions-group hud-bottom__actions-group--left">
<button aria-label="ドット設定を開く" aria-pressed="true" class="icon-button" id="dotModeBtn" type="button">
<img alt="" aria-hidden="true" class="control-icon" draggable="false" src="./icon-dotmode.svg"/>
<span class="icon-button__label visually-hidden">ドット設定</span>
</button>
</div>
<div class="hud-bottom__center">
<div class="zoom-meter is-collapsed" hidden="" id="zoomControl">
<div class="zoom-meter__tape">
<div aria-hidden="true" class="zoom-meter__indicator"></div>
<div aria-hidden="true" class="zoom-meter__scale">
<div class="zoom-meter__scale-track"></div>
</div>
<input aria-label="ズーム倍率" class="zoom-meter__slider" data-setting="zoom" id="cameraZoomSlider" max="100" min="0" step="1" type="range" value="0"/>
</div>
<div class="zoom-meter__color" hidden="" id="colorControl">
<div class="zoom-meter__control-group">
<div class="zoom-meter__control-header">
<span aria-hidden="true" class="zoom-meter__control-title">Hue</span>
<span class="zoom-meter__control-value" id="hueValueDisplay">0°</span>
</div>
<input aria-label="色相" class="zoom-meter__control-slider zoom-meter__control-slider--hue" id="hueSlider" max="360" min="0" step="1" type="range" value="0"/>
</div>
<div class="zoom-meter__control-group">
<div class="zoom-meter__control-header">
<span aria-hidden="true" class="zoom-meter__control-title">Saturation</span>
<span class="zoom-meter__control-value" id="saturationValueDisplay">220%</span>
</div>
<input aria-label="彩度" class="zoom-meter__control-slider zoom-meter__control-slider--saturation" id="saturationSlider" max="300" min="0" step="1" type="range" value="220"/>
</div>
</div>
</div>
<div class="hud-bottom__capture-slot">
<button aria-label="撮影" class="capture-button" id="captureBtn" type="button">
<img alt="" aria-hidden="true" class="capture-button__icon" draggable="false" src="./icon-capture.svg"/>
</button>
</div>
</div>
<div class="hud-bottom__actions-group hud-bottom__actions-group--right">
<button aria-controls="aspectMenu" aria-expanded="false" aria-label="キャンバスサイズを選択" class="icon-button" id="aspectMenuBtn" type="button">
<img alt="" aria-hidden="true" class="control-icon" src="./icon-aspect.svg"/>
<span class="icon-button__label visually-hidden">キャンバスサイズ</span>
</button>
</div>
</div>
<div aria-hidden="true" class="hud-landscape-capture"></div>
</div>
<div class="pixel-preview" hidden="" id="pixelPreview"></div>
<div aria-live="polite" class="qr-readout" hidden="" id="qrReadout" role="status">
<div class="qr-readout__header">
<span class="qr-readout__title" id="qrReadoutTitle">QRスキャン</span>
<span class="qr-readout__state" id="qrReadoutState">停止中</span>
<button aria-label="閉じる" class="qr-readout__close" id="qrCloseBtn" type="button"></button>
</div>
<p class="qr-readout__message" id="qrReadoutMessage">QR / PiXiEEDコードのスキャンを開始します。</p>
<div class="qr-readout__result" hidden="" id="qrReadoutResult">
<p class="qr-readout__label">検出された内容</p>
<div class="qr-readout__preview" hidden="" id="qrPreviewWrap">
<canvas aria-hidden="true" id="qrPreviewCanvas"></canvas>
</div>
<div class="qr-readout__text" id="qrReadoutText"></div>
<div class="qr-readout__actions">
<button class="option-button" disabled="" id="qrCopyBtn" type="button">コピー</button>
<button class="option-button" disabled="" id="qrOpenBtn" type="button">リンクを開く</button>
</div>
</div>
</div>
</div></main>
<div aria-hidden="true" class="camera-permission" hidden="" id="cameraStartOverlay">
<div class="camera-permission__backdrop" id="cameraStartBackdrop"></div>
<div aria-describedby="cameraStartMessage" aria-labelledby="cameraStartHeading" aria-modal="true" class="camera-permission__panel" role="dialog">
<h2 class="camera-permission__title" id="cameraStartHeading">カメラを起動</h2>
<p class="camera-permission__message" id="cameraStartMessage">ホーム画面から利用する場合は、下のボタンをタップしてカメラを起動してください。</p>
<div class="camera-permission__actions">
<button class="camera-permission__button camera-permission__button--primary" id="cameraStartButton" type="button">カメラを起動</button>
</div>
</div>
</div>
<div aria-hidden="true" class="capture-preview" hidden="" id="capturePreviewOverlay">
<div class="capture-preview__backdrop" id="capturePreviewBackdrop"></div>
<div aria-labelledby="capturePreviewHeading" aria-modal="true" class="capture-preview__panel" role="dialog">
<button aria-label="閉じる" class="capture-preview__close" id="capturePreviewCloseBtn" type="button"></button>
<div class="capture-preview__body">
      <h2 class="capture-preview__title" id="capturePreviewHeading">撮影結果</h2>
      <div class="capture-preview__image-wrap">
        <img alt="撮影した画像のプレビュー" id="capturePreviewImage" loading="lazy"/>
      </div>
      <p class="capture-preview__info" id="capturePreviewInfo">画像を長押しして保存してください。</p>
      <div class="capture-preview__ad">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-9801602250480253"
             data-ad-slot="2141591954"></ins>
      </div>
      <div class="capture-preview__actions">
        <button class="capture-preview__button" hidden="" id="capturePreviewEditBtn" type="button">PiXiEEDrawで編集</button>
        <button class="capture-preview__button capture-preview__button--primary" hidden="" id="capturePreviewShareBtn" type="button">共有する</button>
        <button class="capture-preview__button" id="capturePreviewCloseActionBtn" type="button">閉じる</button>
      </div>
</div>
</div>
</div>
<input accept="image/png, image/gif, image/webp, image/bmp" hidden="" id="pixelArtInput" multiple="" type="file"/>
<script>
  if (window.pixieedObserveAds) {
    window.pixieedObserveAds();
  }
</script>
<script>
    const video = document.getElementById('cameraFeed');
    const cameraActionBtn = document.getElementById('cameraActionBtn');
    const cameraActionIcon = document.getElementById('cameraActionIcon');
    const cameraSettingsBtn = document.getElementById('cameraSettingsBtn');
    const cameraSettingsPanel = document.getElementById('cameraSettingsPanel');
    const cameraSettingsResetBtn = document.getElementById('cameraSettingsResetBtn');
    const stampBtn = document.getElementById('stampBtn');
    const stampPanel = document.getElementById('stampPanel');
    const stampList = document.getElementById('stampList');
    const stampEmptyMessage = document.getElementById('stampEmptyMessage');
    const pixelArtBtn = document.getElementById('pixelArtBtn');
    const clearPixelBtn = document.getElementById('clearPixelBtn');
    const dotModeBtn = document.getElementById('dotModeBtn');
    const captureBtn = document.getElementById('captureBtn');
    const aspectMenuBtn = document.getElementById('aspectMenuBtn');
    const pixelArtInput = document.getElementById('pixelArtInput');
    const pixelPreview = document.getElementById('pixelPreview');
    const qrReadout = document.getElementById('qrReadout');
    const qrReadoutTitle = document.getElementById('qrReadoutTitle');
    const qrReadoutState = document.getElementById('qrReadoutState');
    const qrReadoutMessage = document.getElementById('qrReadoutMessage');
    const qrReadoutResult = document.getElementById('qrReadoutResult');
    const qrReadoutText = document.getElementById('qrReadoutText');
    const qrPreviewWrap = document.getElementById('qrPreviewWrap');
    const qrPreviewCanvas = document.getElementById('qrPreviewCanvas');
    const qrCloseBtn = document.getElementById('qrCloseBtn');
    const qrCopyBtn = document.getElementById('qrCopyBtn');
    const qrOpenBtn = document.getElementById('qrOpenBtn');
    const landscapeCaptureSlot = document.querySelector('.hud-landscape-capture');
    const captureButtonOriginalParent = captureBtn ? captureBtn.parentElement : null;
    const cameraStartOverlay = document.getElementById('cameraStartOverlay');
    const cameraStartMessage = document.getElementById('cameraStartMessage');
    const cameraStartButton = document.getElementById('cameraStartButton');
    const cameraStartActions = cameraStartOverlay ? cameraStartOverlay.querySelector('.camera-permission__actions') : null;
    const cameraStartBackdrop = document.getElementById('cameraStartBackdrop');
    const cameraStartButtonLabel = cameraStartButton ? (cameraStartButton.textContent || '').trim() || 'カメラを起動' : 'カメラを起動';
    const capturePreviewOverlay = document.getElementById('capturePreviewOverlay');
    const capturePreviewImage = document.getElementById('capturePreviewImage');
    const capturePreviewInfo = document.getElementById('capturePreviewInfo');
    const capturePreviewCloseBtn = document.getElementById('capturePreviewCloseBtn');
    const capturePreviewCloseActionBtn = document.getElementById('capturePreviewCloseActionBtn');
    const capturePreviewShareBtn = document.getElementById('capturePreviewShareBtn');
    const capturePreviewEditBtn = document.getElementById('capturePreviewEditBtn');
    const capturePreviewBackdrop = document.getElementById('capturePreviewBackdrop');
    const cameraSettingSliders = cameraSettingsPanel ? Array.from(cameraSettingsPanel.querySelectorAll('input[data-setting]')) : [];
    const cameraSettingValueEls = new Map();
    if (cameraSettingsPanel) {
      Array.from(cameraSettingsPanel.querySelectorAll('[data-setting-value]')).forEach((element) => {
        const key = element.dataset.settingValue;
        if (key) {
          cameraSettingValueEls.set(key, element);
        }
      });
    }
    const zoomControl = document.getElementById('zoomControl');
    const zoomSlider = document.getElementById('cameraZoomSlider');
    const zoomMeterTape = zoomControl ? zoomControl.querySelector('.zoom-meter__tape') : null;
    const zoomScaleWrapper = zoomControl ? zoomControl.querySelector('.zoom-meter__scale') : null;
    const zoomScaleTrack = zoomScaleWrapper ? zoomScaleWrapper.querySelector('.zoom-meter__scale-track') : null;
    const colorControl = document.getElementById('colorControl');
    const hueSlider = document.getElementById('hueSlider');
    const hueValueDisplay = document.getElementById('hueValueDisplay');
    const saturationSlider = document.getElementById('saturationSlider');
    const saturationValueDisplay = document.getElementById('saturationValueDisplay');
    const ZOOM_MARK_STEP = 0.5;
    const ZOOM_FALLBACK_MIN = 1;
    const ZOOM_FALLBACK_MAX = 8;
    const ZOOM_MAJOR_EPSILON = 1e-3;
    const CAMERA_READY_TIMEOUT_MS = 5000;
    let zoomScaleItems = [];
    let zoomScaleMarks = [];
    let zoomScaleTranslate = 0;
    let zoomMeterLastAppliedIndex = -1;
    const zoomMeterDrag = {
      active: false,
      pointerId: null,
      startClientX: 0,
      startTranslate: 0,
      samples: []
    };
    const zoomMeterInertia = {
      active: false,
      frameId: 0,
      velocity: 0,
      lastTimestamp: 0
    };
    let zoomMeterCollapseTimeout = null;
    if (zoomSlider) {
      zoomSlider.addEventListener('focus', () => {
        setZoomMeterExpanded(true);
        if (zoomMeterCollapseTimeout) {
          clearTimeout(zoomMeterCollapseTimeout);
          zoomMeterCollapseTimeout = null;
        }
      });
      zoomSlider.addEventListener('blur', () => {
        scheduleZoomMeterCollapse(700);
      });
      zoomSlider.addEventListener('keydown', (event) => {
        if (event.key === 'Tab') {
          setZoomMeterExpanded(false);
        }
      });
      zoomSlider.addEventListener('change', () => {
        scheduleZoomMeterCollapse(600);
      });
    }
    if (hueSlider) {
      hueSlider.addEventListener('input', (event) => {
        event.stopPropagation();
        handleHueSliderInput(hueSlider.value);
      });
      hueSlider.addEventListener('change', (event) => {
        event.stopPropagation();
        handleHueSliderInput(hueSlider.value);
      });
      ['pointerdown', 'click'].forEach((type) => {
        hueSlider.addEventListener(type, (event) => event.stopPropagation());
      });
    }
    if (saturationSlider) {
      saturationSlider.addEventListener('input', (event) => {
        event.stopPropagation();
        handleSaturationSliderInput(saturationSlider.value);
      });
      saturationSlider.addEventListener('change', (event) => {
        event.stopPropagation();
        handleSaturationSliderInput(saturationSlider.value);
      });
      ['pointerdown', 'click'].forEach((type) => {
        saturationSlider.addEventListener(type, (event) => event.stopPropagation());
      });
    }
    if (zoomMeterTape) {
      zoomMeterTape.addEventListener('pointerdown', handleZoomMeterPointerDown);
    }
    if (video) {
      video.setAttribute('playsinline', '');
      video.setAttribute('autoplay', '');
      video.muted = true;
      video.playsInline = true;
    }

    if (cameraStartButton) {
      const triggerCameraStart = (event) => {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (iosStandaloneUnsupported) {
          if (typeof window !== 'undefined' && window.location) {
            const targetUrl = 'https://pixieed.jp/pixiee-lens/';
            try {
              window.location.href = targetUrl;
            } catch (error) {
              console.warn('Failed to redirect to Safari', error);
            }
          }
          return;
        }
        cameraStartLocked = false;
        handleCameraStartRequest();
      };
      cameraStartButton.addEventListener('click', triggerCameraStart);
      cameraStartButton.addEventListener('touchend', triggerCameraStart, { passive: false });
    }
    if (cameraStartBackdrop) {
      cameraStartBackdrop.addEventListener('click', (event) => {
        event.preventDefault();
      });
    }
    if (cameraStartOverlay) {
      cameraStartOverlay.addEventListener('click', (event) => {
        if (event.target === cameraStartOverlay) {
          event.preventDefault();
        }
      });
    }
    if (capturePreviewCloseBtn) {
      capturePreviewCloseBtn.addEventListener('click', () => {
        closeCapturePreview();
      });
    }
    if (capturePreviewCloseActionBtn) {
      capturePreviewCloseActionBtn.addEventListener('click', () => {
        closeCapturePreview();
      });
    }
    if (capturePreviewBackdrop) {
      capturePreviewBackdrop.addEventListener('click', () => {
        closeCapturePreview();
      });
    }
    if (capturePreviewOverlay) {
      capturePreviewOverlay.addEventListener('click', (event) => {
        if (event.target === capturePreviewOverlay) {
          closeCapturePreview();
        }
      });
    }
    if (capturePreviewShareBtn) {
      capturePreviewShareBtn.addEventListener('click', async () => {
        if (!capturePreviewSharePayload || !capturePreviewSharePayload.file || typeof navigator.share !== 'function') {
          return;
        }
        try {
          await navigator.share({
            files: [capturePreviewSharePayload.file],
            title: 'PiXiEELENS',
            text: '撮影した画像'
          });
          setStatus('共有しました');
          closeCapturePreview();
        } catch (error) {
          if (!error || error.name !== 'AbortError') {
            console.warn('Share failed', error);
            setStatus('共有できませんでした');
          }
        }
      });
    }
    if (capturePreviewEditBtn) {
      capturePreviewEditBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openCaptureInDraw();
      });
    }
    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && capturePreviewOverlay && !capturePreviewOverlay.hidden) {
        closeCapturePreview();
      }
    });
    const dotCanvas = document.getElementById('dotCanvas');
    const dotCanvasCtx = dotCanvas ? dotCanvas.getContext('2d', { willReadFrequently: true }) : null;
    const smoothingCanvas = dotCanvas ? document.createElement('canvas') : null;
    const smoothingCtx = smoothingCanvas ? smoothingCanvas.getContext('2d', { willReadFrequently: true }) : null;
    const aspectOverlay = document.getElementById('aspectOverlay');
    const aspectFrame = document.getElementById('aspectFrame');
    const aspectCenter = document.getElementById('aspectCenter');
    const aspectShadeTop = document.getElementById('aspectShadeTop');
    const aspectShadeBottom = document.getElementById('aspectShadeBottom');
    const aspectShadeLeft = document.getElementById('aspectShadeLeft');
    const aspectShadeRight = document.getElementById('aspectShadeRight');
    const aspectMenu = document.getElementById('aspectMenu');
    const hudTopBar = document.querySelector('.hud-top__bar');
    const aspectButtons = Array.from(document.querySelectorAll('.option-button[data-aspect]'));
    const dotSettingsPanel = document.getElementById('dotSettingsPanel');
    const paletteToggleBtn = document.getElementById('paletteToggleBtn');
    const paletteDisplay = document.getElementById('paletteDisplay');
    const dotScaleSelect = document.getElementById('dotScaleSelect');
    const colorDepthSelect = document.getElementById('colorDepthSelect');

    if (paletteDisplay) {
      ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
        paletteDisplay.addEventListener(type, (event) => event.stopPropagation());
      });
    }
    if (stampPanel) {
      ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
        stampPanel.addEventListener(type, (event) => event.stopPropagation());
      });
    }

    function preventBrowserZoom(event) {
      if (event.ctrlKey || event.metaKey) {
        event.preventDefault();
      }
    }

    window.addEventListener('wheel', preventBrowserZoom, { passive: false });
    window.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && ['=', '+', '-', '_', '0', 'Add', 'Subtract'].includes(event.key)) {
        event.preventDefault();
      }
    }, { passive: false });
    window.addEventListener('gesturestart', (event) => {
      event.preventDefault();
    });

    if (!dotCanvasCtx) {
      if (dotModeBtn) {
        dotModeBtn.disabled = true;
        dotModeBtn.setAttribute('aria-disabled', 'true');
        dotModeBtn.title = 'ドット設定はこのブラウザで利用できません';
      }
      setSelectEnabled(dotScaleSelect, false);
      setSelectEnabled(colorDepthSelect, false);
      if (paletteToggleBtn) {
        paletteToggleBtn.disabled = true;
        paletteToggleBtn.setAttribute('aria-disabled', 'true');
      }
    } else {
      setSelectEnabled(dotScaleSelect, true);
      setSelectEnabled(colorDepthSelect, true);
      if (dotModeBtn) {
        dotModeBtn.disabled = false;
        dotModeBtn.removeAttribute('aria-disabled');
        dotModeBtn.removeAttribute('title');
      }
      if (paletteToggleBtn) {
        paletteToggleBtn.disabled = false;
        paletteToggleBtn.removeAttribute('aria-disabled');
      }
    }

    const CAMERA_SETTING_CONFIG = Object.freeze({
      brightness: { min: -100, max: 100, step: 1, default: 0 },
      exposure: { min: -100, max: 100, step: 1, default: 0 },
      saturation: { min: -100, max: 100, step: 1, default: 0 },
      shadows: { min: -100, max: 100, step: 1, default: 0 },
      contrast: { min: -100, max: 100, step: 1, default: 0 },
      whiteBalance: { min: -100, max: 100, step: 1, default: 0 },
      zoom: { min: 0, max: 100, step: 1, default: 0 }
    });
    const CAMERA_SETTING_KEYS = Object.freeze(Object.keys(CAMERA_SETTING_CONFIG));
    const CAMERA_SETTING_DEFAULTS = Object.freeze(
      CAMERA_SETTING_KEYS.reduce((accumulator, key) => {
        const config = CAMERA_SETTING_CONFIG[key] || {};
        const defaultValue = Number(config.default);
        accumulator[key] = Number.isFinite(defaultValue) ? defaultValue : 0;
        return accumulator;
      }, {})
    );
    const CAMERA_BASE_SATURATION = 1;
    const CAMERA_TRACK_CAPABILITY_MAP = {
      brightness: 'brightness',
      exposure: 'exposureCompensation',
      saturation: 'saturation',
      contrast: 'contrast',
      whiteBalance: 'colorTemperature',
      zoom: 'zoom'
    };
    const STAMP_LIBRARY = Object.freeze([
      { id: 'st-glass', label: 'グラス', src: './stamps/st-glass.png' },
      { id: 'st-megane', label: 'めがね', src: './stamps/st-megane.png' },
      { id: 'st-mao1', label: 'まおいつフェイス 1', src: './stamps/st-mao1.png' },
      { id: 'st-mao2', label: 'まおいつフェイス 2', src: './stamps/st-mao2.png' },
      { id: 'wst-kira', label: 'キラキラ（カラー）', src: './stamps/wst-kira.png', hueAdjustable: true },
      { id: 'wst-star', label: '星（カラー）', src: './stamps/wst-star.png', hueAdjustable: true },
      { id: 'wst-dot', label: 'ドット（カラー）', src: './stamps/wst-dot.png', hueAdjustable: true },
      { id: 'wst-heart', label: 'ハート（カラー）', src: './stamps/wst-heart.png', hueAdjustable: true },
      { id: 'wst-supe', label: 'スペード（カラー）', src: './stamps/wst-supe.png', hueAdjustable: true },
      { id: 'wst-sizuku', label: 'しずく（カラー）', src: './stamps/wst-sizuku.png', hueAdjustable: true },
      { id: 'wst-tira', label: 'ティアラ（カラー）', src: './stamps/wst-tira.png', hueAdjustable: true },
      { id: 'wst-kurabu', label: 'クラブ（カラー）', src: './stamps/wst-kurabu.png', hueAdjustable: true }
    ]);
    const QR_SCAN_BASE_SIZE = 640;
    const QR_SCAN_MIN_SIZE = 320;
    const QR_SCAN_DEFAULT_INTERVAL_MS = 260;
    const PIXCODE_TABLE = 'pixfind_codes';
    const SUPABASE_URL = 'https://kyyiuakrqomzlikfaire.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_gnc61sD2hZvGHhEW8bQMoA_lrL07SN4';
    const PIX_ART_SIZE = 32;
    const PIX_COLOR_LEVELS = 32;
    const PIX_FINDER_SIZE = 7;
    const PIX_FINDER_GAP = 3;
    const PIX_FRAME_OFFSET = PIX_FINDER_SIZE + PIX_FINDER_GAP;
    const PIX_FRAME_SIZE = PIX_ART_SIZE + PIX_FRAME_OFFSET * 2;
    const PIX_QUIET_ZONE = 4;
    const PIX_FINDER_CENTER_OFFSET = 3;
    const PIX_AXIS_CELLS = PIX_FRAME_SIZE - 1 - PIX_FINDER_CENTER_OFFSET * 2;
    const PIX_TIMING_ROW = PIX_FINDER_SIZE + 1;
    const PIX_TIMING_COL = PIX_FINDER_SIZE + 1;
    const PIX_TIMING_START = PIX_FINDER_SIZE + 1;
    const PIX_TIMING_END = PIX_FRAME_SIZE - PIX_FINDER_SIZE - 2;
    const PIX_FORMAT_ROW = PIX_FINDER_SIZE + 2;
    const PIX_FORMAT_COL = PIX_FINDER_SIZE + 2;
    const PIX_FORMAT_START = PIX_FRAME_OFFSET;
    const PIX_FORMAT_END = PIX_FRAME_OFFSET + PIX_ART_SIZE - 1;
    const PIX_FORMAT_PATTERN = '10100111001011011001011100101101';
    const PIX_FORMAT_BITS = Array.from({ length: PIX_ART_SIZE }, (_, i) => PIX_FORMAT_PATTERN[i % PIX_FORMAT_PATTERN.length] === '1');
    const PIX_RGB_PATCH_SIZE = 3;
    const PIX_RGB_PATCH_GAP = 2;
    const PIX_RGB_PATCH_MARGIN = 1;
    const PIX_RGB_PATCH_COUNT = 3;
    const PIX_RGB_PATCH_TOTAL_HEIGHT = (PIX_RGB_PATCH_SIZE * PIX_RGB_PATCH_COUNT) + (PIX_RGB_PATCH_GAP * (PIX_RGB_PATCH_COUNT - 1));
    const PIX_RGB_PATCH_X = PIX_RGB_PATCH_MARGIN;
    const PIX_RGB_PATCH_Y = Math.floor(PIX_FRAME_SIZE / 2) - Math.floor(PIX_RGB_PATCH_TOTAL_HEIGHT / 2);
    const PIX_ALIGN_SIZE = 2;
    const PIX_ALIGN_START = PIX_FRAME_OFFSET + PIX_ART_SIZE;
    const PIX_ALIGN_CENTER_OFFSET = (PIX_ALIGN_SIZE - 1) / 2;
    const PIX_ALIGN_POINTS = [
      { x: PIX_ALIGN_START, y: PIX_ALIGN_START }
    ];
    const PIX_ALIGN_CENTERS = PIX_ALIGN_POINTS.map((pt) => ({
      x: pt.x + PIX_ALIGN_CENTER_OFFSET,
      y: pt.y + PIX_ALIGN_CENTER_OFFSET
    }));
    const COLOR_SIMPLIFY_MAX_COLORS = 24;
    const COLOR_SIMPLIFY_BUCKET = 18;
    const AUTO_ADJUST_SAMPLE_SIZE = Object.freeze({ width: 180, height: 120 });
    const autoAdjustCanvas = document.createElement('canvas');
    autoAdjustCanvas.width = AUTO_ADJUST_SAMPLE_SIZE.width;
    autoAdjustCanvas.height = AUTO_ADJUST_SAMPLE_SIZE.height;
    const autoAdjustCtx = autoAdjustCanvas.getContext
      ? autoAdjustCanvas.getContext('2d', { willReadFrequently: true })
      : null;

    const state = {
      stream: null,
      useFrontCamera: false,
      restarting: false,
      aspectMode: '1:1',
      dotMode: true,
      dotScale: 1,
      colorDepth: '4',
      cameraSettings: { ...CAMERA_SETTING_DEFAULTS }
    };

    const overlays = [];
    let activeOverlay = null;
    const HUE_CONTROL_RANGE = Object.freeze({ min: 0, max: 360, step: 1 });
    const SATURATION_CONTROL_RANGE = Object.freeze({ min: 0, max: 300, step: 1 });
    const COLOR_CONTROL_DEFAULTS = Object.freeze({
      hue: 0,
      saturation: 220
    });
    let zoomControlMode = 'zoom';
    let colorControlOverlayId = null;

    const interactionState = {
      dragOverlay: null,
      resizeOverlay: null,
      listenersAttached: false
    };

    const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const displayModeStandalone = (() => {
      if (window.matchMedia) {
        try {
          return window.matchMedia('(display-mode: standalone)').matches;
        } catch (error) {
          return false;
        }
      }
      return false;
    })();
    const isStandaloneApp = Boolean(window.navigator && window.navigator.standalone) || displayModeStandalone;
    const iosStandaloneUnsupported = isIOSDevice && isStandaloneApp;
    const requiresCameraUserGesture = !iosStandaloneUnsupported && isIOSDevice && isStandaloneApp;
    let cameraStartLocked = requiresCameraUserGesture || iosStandaloneUnsupported;

    let cameraZoomCapability = null;
    let cameraZoomCapabilityKnown = false;
    let cameraStatusMessage = '';
    let dotScalePanelOpen = false;
    const dotState = {
      frameHandle: null,
      width: 0,
      height: 0,
      layout: {
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0,
        mode: 'contain'
      }
    };
    let capturePreviewObjectUrl = null;
    let capturePreviewSharePayload = null;
    let capturePreviewEditPayload = null;
    let capturePreviewLastFocus = null;
    let cameraStartOverlayLastFocus = null;
    let cameraStartButtonBusy = false;
    let gestureStartRegistered = false;
    let gestureStartHandler = null;

    let cameraPermissionDenied = false;
    let cameraReady = false;
    let captureInProgress = false;
    let qrScanEnabled = true;
    let qrSupportAvailable = null;
    let qrSupportWarningShown = false;
    let qrDetector = null;
    let qrScanLoopHandle = null;
    let qrLastValue = '';
    let qrOpenTarget = '';
    const qrScanCanvas = document.createElement('canvas');
    const qrScanCtx = qrScanCanvas.getContext ? qrScanCanvas.getContext('2d', { willReadFrequently: true }) : null;
    let pixLastHash = '';
    let pixLastDetectedAt = 0;
    const pixLookupCache = new Map();
    const pixLookupPromises = new Map();

    const menus = {
      aspect: { button: aspectMenuBtn, panel: aspectMenu },
      stamps: { button: stampBtn, panel: stampPanel },
      cameraSettings: { button: cameraSettingsBtn, panel: cameraSettingsPanel }
    };
    let openMenuKey = null;

    let currentCameraFilterString = '';
    let cameraConstraintsFrameScheduled = false;
    let cameraConstraintErrorLogged = false;

    function getCameraSettingConfig(key) {
      return CAMERA_SETTING_CONFIG[key] || null;
    }

    function getCameraSettingRange(key) {
      const config = getCameraSettingConfig(key);
      const min = config && Number.isFinite(config.min) ? Number(config.min) : -100;
      const max = config && Number.isFinite(config.max) ? Number(config.max) : 100;
      if (max < min) {
        return { min: max, max: min };
      }
      return { min, max };
    }

    function clampCameraSettingValue(value, key) {
      const config = getCameraSettingConfig(key);
      const { min, max } = getCameraSettingRange(key);
      const step = config && Number.isFinite(config.step) && config.step > 0 ? Number(config.step) : null;
      let numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        const fallback = config && Number.isFinite(config.default) ? Number(config.default) : 0;
        numeric = fallback;
      }
      if (numeric < min) {
        numeric = min;
      } else if (numeric > max) {
        numeric = max;
      }
      if (step) {
        numeric = min + Math.round((numeric - min) / step) * step;
        if (numeric < min) {
          numeric = min;
        } else if (numeric > max) {
          numeric = max;
        }
      }
      return Number(Number.isFinite(numeric) ? numeric : min);
    }

    function getCameraSettingRatio(value, key) {
      const { min, max } = getCameraSettingRange(key);
      const clamped = clampCameraSettingValue(value, key);
      if (max <= min) {
        return 0;
      }
      const ratio = (clamped - min) / (max - min);
      return Math.min(1, Math.max(0, Number.isFinite(ratio) ? ratio : 0));
    }

    function getSliderValueFromRatio(ratio, key) {
      const { min, max } = getCameraSettingRange(key);
      const normalized = Math.min(1, Math.max(0, Number.isFinite(ratio) ? ratio : 0));
      return clampCameraSettingValue(min + (max - min) * normalized, key);
    }

    function getZoomDisplayValue(value) {
      const ratio = getCameraSettingRatio(value, 'zoom');
      if (cameraZoomCapability) {
        if (Array.isArray(cameraZoomCapability)) {
          if (!cameraZoomCapability.length) {
            return null;
          }
          const index = Math.min(
            cameraZoomCapability.length - 1,
            Math.max(0, Math.round(ratio * (cameraZoomCapability.length - 1)))
          );
          const option = Number(cameraZoomCapability[index]);
          return Number.isFinite(option) ? option : null;
        }
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          let mapped = min + (max - min) * ratio;
          const step = Number(cameraZoomCapability.step);
          if (Number.isFinite(step) && step > 0) {
            mapped = min + Math.round((mapped - min) / step) * step;
          }
          if (mapped < min) {
            mapped = min;
          } else if (mapped > max) {
            mapped = max;
          }
          return mapped;
        }
      }
      const fallbackMin = 1;
      const fallbackMax = 4;
      return fallbackMin + (fallbackMax - fallbackMin) * ratio;
    }

    function formatZoomDisplay(value) {
      const zoomValue = getZoomDisplayValue(value);
      if (!Number.isFinite(zoomValue)) {
        return `${clampCameraSettingValue(value, 'zoom')}%`;
      }
      const formatted = zoomValue.toFixed(2).replace(/\.?0+$/, '');
      return `${formatted}x`;
    }

    function formatZoomScaleLabel(value) {
      if (!Number.isFinite(value)) {
        return '';
      }
      const decimals = value < 10 ? 2 : 1;
      let formatted = value.toFixed(decimals);
      formatted = formatted.replace(/(\.\d*?)0+$/, '$1');
      formatted = formatted.replace(/\.$/, '.0');
      if (!formatted.includes('.')) {
        formatted = `${formatted}.0`;
      }
      return formatted;
    }

    function setZoomMeterExpanded(expanded) {
      if (!zoomControl || zoomControlMode === 'color') {
        return;
      }
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
        zoomMeterCollapseTimeout = null;
      }
      if (expanded) {
        zoomControl.classList.add('is-expanded');
        zoomControl.classList.remove('is-collapsed');
      } else {
        zoomControl.classList.add('is-collapsed');
        zoomControl.classList.remove('is-expanded');
      }
    }

    function scheduleZoomMeterCollapse(delay = 400) {
      if (!zoomControl || zoomControl.hidden || zoomControlMode === 'color') {
        return;
      }
      if (zoomMeterInertia.active) {
        return;
      }
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
      }
      zoomMeterCollapseTimeout = window.setTimeout(() => {
        zoomMeterCollapseTimeout = null;
        setZoomMeterExpanded(false);
      }, Math.max(0, delay));
    }

    function formatCameraSettingValue(value, key) {
      const clamped = clampCameraSettingValue(value, key);
      if (key === 'zoom') {
        if (!cameraZoomCapabilityKnown) {
          return '---';
        }
        if (!cameraZoomCapability) {
          return '未対応';
        }
        return formatZoomDisplay(clamped);
      }
      return clamped > 0 ? `+${clamped}` : `${clamped}`;
    }

    function updateCameraSettingDisplay(key) {
      if (!state.cameraSettings || !Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
        return;
      }
      const element = cameraSettingValueEls.get(key);
      if (element) {
        const value = state.cameraSettings[key] ?? 0;
        element.textContent = formatCameraSettingValue(value, key);
      }
    }

    function syncCameraSettingInputs() {
      cameraSettingSliders.forEach((slider) => {
        const key = slider.dataset.setting;
        if (!key) {
          return;
        }
        const value = state.cameraSettings[key] ?? 0;
        slider.value = String(value);
        slider.setAttribute('aria-valuenow', String(value));
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(value, key));
        if (key === 'zoom') {
          refreshZoomMeterVisuals(value);
        }
      });
    }

    function clampFilterFactor(value, min = 0.2, max = 3) {
      if (!Number.isFinite(value)) {
        return 1;
      }
      return Math.min(max, Math.max(min, value));
    }

    function computeCameraFilterComponents(settings = state.cameraSettings) {
      if (!settings) {
        return [
          'brightness(1.000)',
          'contrast(1.000)',
          `saturate(${CAMERA_BASE_SATURATION.toFixed(3)})`
        ];
      }
      const brightnessValue = clampCameraSettingValue(settings.brightness ?? 0, 'brightness') / 100;
      const exposureValue = clampCameraSettingValue(settings.exposure ?? 0, 'exposure') / 100;
      const saturationValue = clampCameraSettingValue(settings.saturation ?? 0, 'saturation') / 100;
      const shadowValue = clampCameraSettingValue(settings.shadows ?? 0, 'shadows') / 100;
      const contrastValue = clampCameraSettingValue(settings.contrast ?? 0, 'contrast') / 100;
      const whiteBalanceValue = clampCameraSettingValue(settings.whiteBalance ?? 0, 'whiteBalance') / 100;

      const brightnessFactor = clampFilterFactor(1 + brightnessValue * 0.6, 0.2, 3);
      const exposureFactor = clampFilterFactor(1 + exposureValue * 0.9, 0.2, 3);
      const saturationFactor = clampFilterFactor(1 + saturationValue, 0.1, 3);
      const shadowContrastFactor = clampFilterFactor(1 + shadowValue * 0.6, 0.2, 3);
      const userContrastFactor = clampFilterFactor(1 + contrastValue, 0.2, 4);
      const combinedContrast = clampFilterFactor(userContrastFactor * shadowContrastFactor, 0.2, 4);

      const combinedBrightness = clampFilterFactor(brightnessFactor * exposureFactor, 0.2, 3);
      const combinedSaturation = clampFilterFactor(CAMERA_BASE_SATURATION * saturationFactor, 0.05, 4);

      const components = [
        `brightness(${combinedBrightness.toFixed(3)})`,
        `contrast(${combinedContrast.toFixed(3)})`,
        `saturate(${combinedSaturation.toFixed(3)})`
      ];

      if (state.colorDepth === 'gray') {
        components.push('grayscale(1)');
      }

      const whiteBalanceFilters = computeWhiteBalanceFilters(whiteBalanceValue);
      if (whiteBalanceFilters.length) {
        components.push(...whiteBalanceFilters);
      }

      return components;
    }

    function computeWhiteBalanceFilters(value) {
      if (!Number.isFinite(value) || Math.abs(value) < 0.001) {
        return [];
      }
      const filters = [];
      const clamped = Math.max(-1, Math.min(1, value));
      const warm = clamped > 0;
      const intensity = Math.abs(clamped);
      const hueRotate = warm ? intensity * 12 : -intensity * 12;
      filters.push(`hue-rotate(${hueRotate.toFixed(3)}deg)`);
      const saturateFactor = clampFilterFactor(1 + intensity * 0.25 * (warm ? 1 : -0.5), 0.4, 2.5);
      filters.push(`saturate(${saturateFactor.toFixed(3)})`);
      if (warm) {
        const sepia = Math.min(0.35, intensity * 0.45);
        if (sepia > 0.001) {
          filters.push(`sepia(${sepia.toFixed(3)})`);
        }
        const brighten = clampFilterFactor(1 + intensity * 0.08, 0.5, 1.5);
        filters.push(`brightness(${brighten.toFixed(3)})`);
      } else {
        const coolBrightness = clampFilterFactor(1 + intensity * -0.08, 0.5, 1.5);
        filters.push(`brightness(${coolBrightness.toFixed(3)})`);
      }
      return filters;
    }

    function sampleFrameForAutoAdjust(focusPoint = null) {
      if (!video || video.readyState < 2 || !autoAdjustCtx || !autoAdjustCanvas) {
        return null;
      }
      const viewportWidth = Math.max(
        1,
        Math.round(window.innerWidth || video.videoWidth || AUTO_ADJUST_SAMPLE_SIZE.width)
      );
      const viewportHeight = Math.max(
        1,
        Math.round(window.innerHeight || video.videoHeight || AUTO_ADJUST_SAMPLE_SIZE.height)
      );
      const sourceRect = getVideoCoverSourceRect(viewportWidth, viewportHeight);
      if (!sourceRect) {
        return null;
      }
      let crop = {
        sx: sourceRect.sx,
        sy: sourceRect.sy,
        sw: sourceRect.sw,
        sh: sourceRect.sh
      };
      if (focusPoint && Number.isFinite(focusPoint.x) && Number.isFinite(focusPoint.y)) {
        const fx = Math.min(Math.max(focusPoint.x, 0), 1);
        const fy = Math.min(Math.max(focusPoint.y, 0), 1);
        const focusSourceX = sourceRect.sx + sourceRect.sw * fx;
        const focusSourceY = sourceRect.sy + sourceRect.sh * fy;
        const cropWidth = Math.max(48, Math.min(sourceRect.sw, sourceRect.sw * 0.32));
        const cropHeight = Math.max(48, Math.min(sourceRect.sh, sourceRect.sh * 0.32));
        const halfW = cropWidth / 2;
        const halfH = cropHeight / 2;
        const sx = Math.max(sourceRect.sx, Math.min(focusSourceX - halfW, sourceRect.sx + sourceRect.sw - cropWidth));
        const sy = Math.max(sourceRect.sy, Math.min(focusSourceY - halfH, sourceRect.sy + sourceRect.sh - cropHeight));
        crop = { sx, sy, sw: cropWidth, sh: cropHeight };
      }
      const targetWidth = AUTO_ADJUST_SAMPLE_SIZE.width;
      const targetHeight = AUTO_ADJUST_SAMPLE_SIZE.height;
      autoAdjustCanvas.width = targetWidth;
      autoAdjustCanvas.height = targetHeight;
      autoAdjustCtx.save();
      autoAdjustCtx.filter = 'none';
      autoAdjustCtx.drawImage(
        video,
        crop.sx,
        crop.sy,
        crop.sw,
        crop.sh,
        0,
        0,
        targetWidth,
        targetHeight
      );
      autoAdjustCtx.restore();
      let imageData;
      try {
        imageData = autoAdjustCtx.getImageData(0, 0, targetWidth, targetHeight);
      } catch (error) {
        console.warn('Failed to sample frame for auto adjust', error);
        return null;
      }
      if (!imageData || !imageData.data) {
        return null;
      }
      const { data } = imageData;
      const totalPixels = targetWidth * targetHeight;
      if (!totalPixels) {
        return null;
      }
      let sumL = 0;
      let sumL2 = 0;
      let sumR = 0;
      let sumG = 0;
      let sumB = 0;
      let darkPixels = 0;
      let brightPixels = 0;
      let chromaDistance = 0;
      for (let index = 0; index < data.length; index += 4) {
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        sumL += luminance;
        sumL2 += luminance * luminance;
        sumR += r;
        sumG += g;
        sumB += b;
        if (luminance < 64) {
          darkPixels += 1;
        } else if (luminance > 200) {
          brightPixels += 1;
        }
        chromaDistance += Math.abs(r - luminance) + Math.abs(g - luminance) + Math.abs(b - luminance);
      }
      const avgL = sumL / totalPixels;
      const variance = Math.max(0, sumL2 / totalPixels - avgL * avgL);
      const stdL = Math.sqrt(variance) / 255;
      const saturationMetric = chromaDistance / (totalPixels * 3 * 255);
      return {
        avgL,
        stdL,
        avgR: sumR / totalPixels,
        avgG: sumG / totalPixels,
        avgB: sumB / totalPixels,
        darkRatio: darkPixels / totalPixels,
        brightRatio: brightPixels / totalPixels,
        saturationMetric
      };
    }

    function buildAutoAdjustedSettings(metrics) {
      if (!metrics) {
        return null;
      }
      const targetLuma = 132;
      const desiredFactor = Math.min(2.4, Math.max(0.55, targetLuma / Math.max(metrics.avgL || 1, 1)));
      const primaryFactor = Math.sqrt(desiredFactor);
      const secondaryFactor = desiredFactor / Math.max(primaryFactor, 0.0001);
      const brightnessValue = clampCameraSettingValue(
        Math.round(((primaryFactor - 1) / 0.6) * 100),
        'brightness'
      );
      const exposureValue = clampCameraSettingValue(
        Math.round(((secondaryFactor - 1) / 0.9) * 100),
        'exposure'
      );
      const targetStd = 0.22;
      const desiredContrastFactor = Math.min(
        1.6,
        Math.max(0.55, targetStd / Math.max(metrics.stdL || 0.001, 0.001))
      );
      const contrastValue = clampCameraSettingValue(
        Math.round((desiredContrastFactor - 1) * 100),
        'contrast'
      );
      const baseSaturation = Math.max(0.05, Math.min(0.7, metrics.saturationMetric));
      const targetSaturation = 0.18;
      const desiredSaturationFactor = Math.min(
        1.45,
        Math.max(0.6, targetSaturation / baseSaturation)
      );
      const saturationValue = clampCameraSettingValue(
        Math.round((desiredSaturationFactor - 1) * 100),
        'saturation'
      );
      const tempBias = (metrics.avgB - metrics.avgR) / Math.max(metrics.avgR + metrics.avgG + metrics.avgB, 1);
      const whiteBalanceValue = clampCameraSettingValue(
        Math.round(tempBias * 140),
        'whiteBalance'
      );
      const shadowTarget = 0.42;
      const shadowDelta = shadowTarget - metrics.darkRatio;
      const shadowsValue = clampCameraSettingValue(
        Math.round(shadowDelta * 120),
        'shadows'
      );
      return {
        brightness: brightnessValue,
        exposure: exposureValue,
        contrast: contrastValue,
        saturation: saturationValue,
        whiteBalance: whiteBalanceValue,
        shadows: shadowsValue
      };
    }

    function updateCameraFilters() {
      const components = computeCameraFilterComponents();
      currentCameraFilterString = components.join(' ');
      if (video) {
        video.style.filter = currentCameraFilterString;
      }
    }

    function scheduleCameraSettingsConstraintUpdate() {
      if (cameraConstraintsFrameScheduled) {
        return;
      }
      cameraConstraintsFrameScheduled = true;
      requestAnimationFrame(() => {
        cameraConstraintsFrameScheduled = false;
        void applyCameraSettingsToTrack();
      });
    }

    function applyCameraSettings() {
      updateCameraFilters();
      scheduleCameraSettingsConstraintUpdate();
    }

    function setCameraSettingValue(key, rawValue, { syncInput = false } = {}) {
      if (!state.cameraSettings || !Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
        return;
      }
      const value = clampCameraSettingValue(Number(rawValue), key);
      if (state.cameraSettings[key] === value) {
        updateCameraSettingDisplay(key);
        if (syncInput) {
          syncCameraSettingInputs();
        }
        return;
      }
      state.cameraSettings[key] = value;
      updateCameraSettingDisplay(key);
      if (key === 'zoom') {
        refreshZoomMeterVisuals(value);
      }
      if (syncInput) {
        syncCameraSettingInputs();
      }
      applyCameraSettings();
    }

    function applyCameraSettingsBatch(updates, { syncInput = true } = {}) {
      if (!updates || typeof updates !== 'object' || !state.cameraSettings) {
        return;
      }
      let changed = false;
      CAMERA_SETTING_KEYS.forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(updates, key)) {
          return;
        }
        const clamped = clampCameraSettingValue(updates[key], key);
        if (state.cameraSettings[key] !== clamped) {
          state.cameraSettings[key] = clamped;
          changed = true;
        }
        updateCameraSettingDisplay(key);
        if (key === 'zoom') {
          refreshZoomMeterVisuals(clamped);
        }
      });
      if (syncInput) {
        syncCameraSettingInputs();
      }
      if (changed) {
        applyCameraSettings();
      }
    }

    function resetCameraSettings() {
      CAMERA_SETTING_KEYS.forEach((key) => {
        const defaultValue = CAMERA_SETTING_DEFAULTS[key] ?? 0;
        state.cameraSettings[key] = clampCameraSettingValue(defaultValue, key);
        updateCameraSettingDisplay(key);
      });
      syncCameraSettingInputs();
      updateZoomSliderAvailability();
      applyCameraSettings();
    }

    function initializeCameraSettingsUI() {
      CAMERA_SETTING_KEYS.forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
          state.cameraSettings[key] = clampCameraSettingValue(CAMERA_SETTING_DEFAULTS[key] ?? 0, key);
        }
        updateCameraSettingDisplay(key);
      });
      syncCameraSettingInputs();
      updateCameraFilters();
      updateZoomSliderAvailability();
    }

    function getActiveVideoTrack() {
      if (!state.stream || typeof state.stream.getVideoTracks !== 'function') {
        return null;
      }
      const tracks = state.stream.getVideoTracks();
      if (!tracks || !tracks.length) {
        return null;
      }
      return tracks[0] || null;
    }

    function mapSliderValueToCapability(value, capability, key) {
      if (capability == null) {
        return null;
      }
      const ratio = getCameraSettingRatio(value, key);
      if (Array.isArray(capability)) {
        if (!capability.length) {
          return null;
        }
        if (capability.length === 1) {
          const single = Number(capability[0]);
          return Number.isFinite(single) ? single : capability[0];
        }
        const index = Math.min(capability.length - 1, Math.max(0, Math.round(ratio * (capability.length - 1))));
        const candidate = capability[index];
        const numericCandidate = Number(candidate);
        return Number.isFinite(numericCandidate) ? numericCandidate : candidate;
      }
      const min = Number(capability.min);
      const max = Number(capability.max);
      if (!Number.isFinite(min) || !Number.isFinite(max)) {
        return null;
      }
      if (min === max) {
        return min;
      }
      const step = Number(capability.step);
      let mapped = min + (max - min) * ratio;
      if (Number.isFinite(step) && step > 0) {
        mapped = min + Math.round((mapped - min) / step) * step;
      }
      if (mapped > max) {
        mapped = max;
      } else if (mapped < min) {
        mapped = min;
      }
      return mapped;
    }

    function mapCapabilityValueToSlider(value, capability, key) {
      if (capability == null) {
        return clampCameraSettingValue(value, key);
      }
      const numericValue = Number(value);
      if (!Number.isFinite(numericValue)) {
        return clampCameraSettingValue(value, key);
      }
      if (Array.isArray(capability)) {
        if (!capability.length) {
          return clampCameraSettingValue(value, key);
        }
        const finiteValues = capability
          .map((entry) => Number(entry))
          .filter((entry) => Number.isFinite(entry))
          .sort((a, b) => a - b);
        if (!finiteValues.length) {
          return clampCameraSettingValue(value, key);
        }
        const min = finiteValues[0];
        const max = finiteValues[finiteValues.length - 1];
        if (max <= min) {
          return clampCameraSettingValue(value, key);
        }
        let closest = finiteValues[0];
        let minDiff = Math.abs(numericValue - closest);
        for (let index = 1; index < finiteValues.length; index += 1) {
          const candidate = finiteValues[index];
          const diff = Math.abs(candidate - numericValue);
          if (diff < minDiff) {
            minDiff = diff;
            closest = candidate;
          }
        }
        const ratio = (closest - min) / (max - min);
        return getSliderValueFromRatio(ratio, key);
      }
      const min = Number(capability.min);
      const max = Number(capability.max);
      if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
        return clampCameraSettingValue(value, key);
      }
      const ratio = (numericValue - min) / (max - min);
      return getSliderValueFromRatio(ratio, key);
    }

    function syncZoomStateFromTrack(track) {
      if (!track || typeof track.getSettings !== 'function') {
        return;
      }
      if (!cameraZoomCapability) {
        return;
      }
      let settings;
      try {
        settings = track.getSettings();
      } catch (error) {
        return;
      }
      if (!settings || !Number.isFinite(settings.zoom)) {
        return;
      }
      const sliderValue = mapCapabilityValueToSlider(settings.zoom, cameraZoomCapability, 'zoom');
      if (!Number.isFinite(sliderValue)) {
        return;
      }
      const clamped = clampCameraSettingValue(sliderValue, 'zoom');
      if (state.cameraSettings.zoom === clamped) {
        return;
      }
      state.cameraSettings.zoom = clamped;
      syncCameraSettingInputs();
      updateZoomSliderAvailability();
    }

    function refreshZoomMeterVisuals(value = state.cameraSettings.zoom ?? 0) {
      if (!zoomControl || zoomControl.hidden) {
        return;
      }
      if (zoomControlMode === 'color') {
        return;
      }
      if (zoomMeterDrag.active) {
        updateZoomScaleActiveFromLayout({ commit: false });
        return;
      }
      updateZoomScaleDisplay(value);
    }

    function roundZoomValue(value, precision = 2) {
      if (!Number.isFinite(value)) {
        return 0;
      }
      const factor = 10 ** precision;
      return Math.round(value * factor) / factor;
    }

    function isMajorZoomValue(value) {
      if (!Number.isFinite(value)) {
        return false;
      }
      return Math.abs(value - Math.round(value)) < ZOOM_MAJOR_EPSILON;
    }

    function generateZoomMarks(min, max, step = ZOOM_MARK_STEP) {
      let effectiveMin = Number.isFinite(min) ? Math.max(min, ZOOM_FALLBACK_MIN) : ZOOM_FALLBACK_MIN;
      let effectiveMax = Number.isFinite(max) ? Math.max(effectiveMin, max) : ZOOM_FALLBACK_MAX;
      effectiveMin = roundZoomValue(effectiveMin);
      effectiveMax = roundZoomValue(effectiveMax);
      const adjustedStep = Number.isFinite(step) && step > 0 ? step : ZOOM_MARK_STEP;
      const marks = new Set();
      const epsilon = 1e-6;
      let current = effectiveMin;
      while (current <= effectiveMax + epsilon) {
        marks.add(roundZoomValue(current));
        current += adjustedStep;
      }
      if (!marks.size) {
        marks.add(ZOOM_FALLBACK_MIN);
        marks.add(ZOOM_FALLBACK_MAX);
      }
      return Array.from(marks).sort((a, b) => a - b);
    }

    function computeZoomScaleMarks() {
      if (Array.isArray(cameraZoomCapability) && cameraZoomCapability.length) {
        const unique = Array.from(
          new Set(
            cameraZoomCapability
              .map((entry) => Number(entry))
              .filter((entry) => Number.isFinite(entry))
          )
        ).sort((a, b) => a - b);
        if (unique.length >= 2) {
          const min = unique[0];
          const max = unique[unique.length - 1];
          return generateZoomMarks(min, max);
        }
      }
      if (cameraZoomCapability && typeof cameraZoomCapability === 'object') {
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          return generateZoomMarks(min, max);
        }
      }
      return generateZoomMarks(ZOOM_FALLBACK_MIN, ZOOM_FALLBACK_MAX);
    }

    function updateZoomScaleOptions() {
      if (zoomControlMode === 'color') {
        zoomScaleMarks = [];
        zoomScaleItems = [];
        return;
      }
      if (!zoomScaleTrack) {
        zoomScaleMarks = [];
        zoomScaleItems = [];
        return;
      }
      const nextMarks = computeZoomScaleMarks();
      const hasChanged =
        nextMarks.length !== zoomScaleMarks.length ||
        nextMarks.some((mark, index) => Math.abs((zoomScaleMarks[index] ?? Number.NaN) - mark) > 0.0001);
      zoomScaleMarks = nextMarks;
      if (!hasChanged && zoomScaleItems.length === zoomScaleMarks.length && zoomScaleItems.length > 0) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0);
        return;
      }
      zoomScaleTrack.textContent = '';
      setZoomScaleTranslate(0, { animate: false });
      zoomMeterLastAppliedIndex = -1;
      if (!zoomScaleMarks.length) {
        zoomScaleItems = [];
        return;
      }
      zoomScaleMarks.forEach((mark) => {
        const label = document.createElement('span');
        label.className = 'zoom-meter__scale-value';
        label.dataset.zoomValue = String(mark);
        label.textContent = formatZoomScaleLabel(mark);
        if (isMajorZoomValue(mark)) {
          label.classList.add('zoom-meter__scale-value--major');
        }
        zoomScaleTrack.appendChild(label);
      });
      zoomScaleItems = Array.from(zoomScaleTrack.children);
      updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0, { animate: false });
    }

    function updateZoomScaleDisplay(value = state.cameraSettings.zoom ?? 0, { animate = true } = {}) {
      if (zoomControlMode === 'color') {
        return;
      }
      if (!zoomScaleWrapper || !zoomScaleTrack || !zoomScaleMarks.length) {
        return;
      }
      if (zoomMeterDrag.active) {
        return;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length) {
        return;
      }
      const targetZoom = Number(getZoomDisplayValue(value));
      if (!Number.isFinite(targetZoom)) {
        return;
      }
      let bestIndex = 0;
      let minDiff = Number.POSITIVE_INFINITY;
      zoomScaleMarks.forEach((mark, index) => {
        const diff = Math.abs(Number(mark) - targetZoom);
        if (diff < minDiff) {
          minDiff = diff;
          bestIndex = index;
        }
      });
      alignZoomScaleToIndex(bestIndex, { animate });
      updateZoomScaleActiveFromLayout({ commit: false });
      zoomMeterLastAppliedIndex = bestIndex;
    }

    function setZoomScaleTranslate(translate, { animate = true } = {}) {
      if (!zoomScaleTrack) {
        zoomScaleTranslate = translate;
        return zoomScaleTranslate;
      }
      if (!animate) {
        zoomScaleTrack.classList.add('is-static');
      } else {
        zoomScaleTrack.classList.remove('is-static');
      }
      zoomScaleTranslate = translate;
      zoomScaleTrack.style.transform = `translateX(${translate}px)`;
      if (!animate) {
        requestAnimationFrame(() => {
          zoomScaleTrack.classList.remove('is-static');
        });
      }
      return zoomScaleTranslate;
    }

    function clampZoomScaleTranslate({ animate = false } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack || !zoomScaleItems.length) {
        return zoomScaleTranslate;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      const firstRect = zoomScaleItems[0].getBoundingClientRect();
      const lastRect = zoomScaleItems[zoomScaleItems.length - 1].getBoundingClientRect();
      let adjustedTranslate = zoomScaleTranslate;
      const firstCenter = firstRect.left + firstRect.width / 2;
      const lastCenter = lastRect.left + lastRect.width / 2;
      if (firstCenter > centerX) {
        adjustedTranslate += centerX - firstCenter;
      }
      if (lastCenter < centerX) {
        adjustedTranslate += centerX - lastCenter;
      }
      if (adjustedTranslate !== zoomScaleTranslate) {
        return setZoomScaleTranslate(adjustedTranslate, { animate });
      }
      return zoomScaleTranslate;
    }

    function alignZoomScaleToIndex(index, { animate = true } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        return false;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      const targetItem = zoomScaleItems[index];
      if (!targetItem) {
        return false;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      const itemRect = targetItem.getBoundingClientRect();
      const itemCenterX = itemRect.left + itemRect.width / 2;
      const adjustment = centerX - itemCenterX;
      if (!Number.isFinite(adjustment)) {
        return false;
      }
      setZoomScaleTranslate(zoomScaleTranslate + adjustment, { animate });
      updateZoomScaleActiveFromLayout({ commit: false });
      return true;
    }

    function updateZoomScaleActiveFromLayout({ commit = false, animate = false } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        return null;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length || !zoomScaleMarks.length) {
        return null;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      let bestIndex = 0;
      let minDistance = Number.POSITIVE_INFINITY;
      zoomScaleItems.forEach((item, index) => {
        const baseValue = Number(item.dataset.zoomValue);
        if (Number.isFinite(baseValue)) {
          item.textContent = formatZoomScaleLabel(baseValue);
          item.classList.toggle('zoom-meter__scale-value--major', isMajorZoomValue(baseValue));
        }
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.left + rect.width / 2;
        const distance = Math.abs(itemCenter - centerX);
        if (distance < minDistance) {
          minDistance = distance;
          bestIndex = index;
        }
      });
      zoomScaleItems.forEach((item, index) => {
        item.classList.toggle('is-active', index === bestIndex);
      });
      const activeValue = Number(zoomScaleMarks[bestIndex]);
      if (commit && Number.isFinite(activeValue) && bestIndex !== zoomMeterLastAppliedIndex) {
        commitZoomMarkIndex(bestIndex, { animate, fromDrag: zoomMeterDrag.active });
      }
      return { index: bestIndex, value: activeValue };
    }

    function getSliderValueForZoom(markValue) {
      if (!Number.isFinite(markValue)) {
        return null;
      }
      if (cameraZoomCapability) {
        const mapped = mapCapabilityValueToSlider(markValue, cameraZoomCapability, 'zoom');
        if (Number.isFinite(mapped)) {
          return mapped;
        }
      }
      if (zoomScaleMarks.length) {
        const min = Number(zoomScaleMarks[0]);
        const max = Number(zoomScaleMarks[zoomScaleMarks.length - 1]);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          const ratio = (markValue - min) / (max - min);
          if (Number.isFinite(ratio)) {
            return getSliderValueFromRatio(ratio, 'zoom');
          }
        }
      }
      return null;
    }

    function commitZoomMarkIndex(index, { animate = false, fromDrag = false } = {}) {
      if (!Array.isArray(zoomScaleMarks) || index < 0 || index >= zoomScaleMarks.length) {
        return;
      }
      const markValue = Number(zoomScaleMarks[index]);
      if (!Number.isFinite(markValue)) {
        return;
      }
      const sliderValue = getSliderValueForZoom(markValue);
      if (!Number.isFinite(sliderValue)) {
        return;
      }
      if (zoomMeterLastAppliedIndex === index && state.cameraSettings.zoom === sliderValue) {
        return;
      }
      zoomMeterLastAppliedIndex = index;
      setCameraSettingValue('zoom', sliderValue, { syncInput: !fromDrag });
      if (!fromDrag) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? sliderValue, { animate });
      }
    }

    function getNearestMarkIndexByClientX(clientX) {
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length) {
        return -1;
      }
      let bestIndex = 0;
      let minDistance = Number.POSITIVE_INFINITY;
      zoomScaleItems.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.left + rect.width / 2;
        const distance = Math.abs(itemCenter - clientX);
        if (distance < minDistance) {
          minDistance = distance;
          bestIndex = index;
        }
      });
      return bestIndex;
    }

    function stopZoomMeterInertia({ finalize = false } = {}) {
      if (!zoomMeterInertia.active) {
        return;
      }
      zoomMeterInertia.active = false;
      if (zoomMeterInertia.frameId) {
        cancelAnimationFrame(zoomMeterInertia.frameId);
        zoomMeterInertia.frameId = 0;
      }
      zoomMeterInertia.velocity = 0;
      zoomMeterInertia.lastTimestamp = 0;
      if (finalize) {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
      }
    }

    function handleZoomMeterPointerDown(event) {
      if (!zoomControl || zoomControl.hidden || zoomControlMode === 'color') {
        return;
      }
      if (zoomMeterDrag.active) {
        return;
      }
      if (event.pointerType === 'mouse' && event.button !== 0) {
        return;
      }
      event.preventDefault();
      stopZoomMeterInertia({ finalize: false });
      setZoomMeterExpanded(true);
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
        zoomMeterCollapseTimeout = null;
      }
      zoomMeterDrag.active = true;
      zoomMeterDrag.pointerId = event.pointerId;
      if (zoomMeterTape && typeof zoomMeterTape.setPointerCapture === 'function') {
        zoomMeterTape.setPointerCapture(event.pointerId);
      }
      zoomMeterDrag.startTranslate = zoomScaleTranslate;
      zoomMeterDrag.startClientX = event.clientX;
      zoomMeterDrag.samples = [{ time: event.timeStamp, x: event.clientX }];
      updateZoomScaleActiveFromLayout({ commit: false });
      window.addEventListener('pointermove', handleZoomMeterPointerMove);
      window.addEventListener('pointerup', handleZoomMeterPointerUp);
      window.addEventListener('pointercancel', handleZoomMeterPointerUp);
    }

    function handleZoomMeterPointerMove(event) {
      if (!zoomMeterDrag.active || event.pointerId !== zoomMeterDrag.pointerId) {
        return;
      }
      event.preventDefault();
      const delta = event.clientX - zoomMeterDrag.startClientX;
      setZoomScaleTranslate(zoomMeterDrag.startTranslate + delta, { animate: false });
      clampZoomScaleTranslate({ animate: false });
      updateZoomScaleActiveFromLayout({ commit: true, animate: false });
      if (Array.isArray(zoomMeterDrag.samples)) {
        zoomMeterDrag.samples.push({ time: event.timeStamp, x: event.clientX });
        const cutoff = event.timeStamp - 120;
        zoomMeterDrag.samples = zoomMeterDrag.samples.filter((sample) => sample.time >= cutoff);
      }
    }

    function computeZoomDragVelocity(time) {
      const samples = Array.isArray(zoomMeterDrag.samples) ? zoomMeterDrag.samples : [];
      if (samples.length < 2) {
        return 0;
      }
      const first = samples[0];
      const last = samples[samples.length - 1];
      const dt = (time ?? last.time) - first.time;
      if (!Number.isFinite(dt) || dt <= 0) {
        return 0;
      }
      return (last.x - first.x) / dt; // px per ms
    }

    function finalizeZoomMeterPosition({ animate = true } = {}) {
      const state = updateZoomScaleActiveFromLayout({ commit: true, animate });
      if (state && Number.isInteger(state.index)) {
        alignZoomScaleToIndex(state.index, { animate });
      }
    }

    function startZoomMeterInertia(initialVelocity) {
      stopZoomMeterInertia();
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
        return;
      }
      zoomMeterInertia.active = true;
      zoomMeterInertia.velocity = initialVelocity;
      zoomMeterInertia.lastTimestamp = performance.now();
      const friction = 0.0015; // px per ms^2
      const minVelocity = 0.04;

      const step = (timestamp) => {
        if (!zoomMeterInertia.active) {
          return;
        }
        const dt = Math.max(1, timestamp - zoomMeterInertia.lastTimestamp);
        zoomMeterInertia.lastTimestamp = timestamp;
        const translateDelta = zoomMeterInertia.velocity * dt;
        setZoomScaleTranslate(zoomScaleTranslate + translateDelta, { animate: false });
        const beforeClamp = zoomScaleTranslate;
        const clampedTranslate = clampZoomScaleTranslate({ animate: false });
        updateZoomScaleActiveFromLayout({ commit: true, animate: false });

        const velocitySign = Math.sign(zoomMeterInertia.velocity);
        zoomMeterInertia.velocity -= velocitySign * friction * dt;
        if (Math.sign(zoomMeterInertia.velocity) !== velocitySign) {
          zoomMeterInertia.velocity = 0;
        }

        const atEdge = clampedTranslate !== beforeClamp;
        if (Math.abs(zoomMeterInertia.velocity) <= minVelocity || atEdge) {
          stopZoomMeterInertia({ finalize: true });
          return;
        }
        zoomMeterInertia.frameId = requestAnimationFrame(step);
      };

      zoomMeterInertia.frameId = requestAnimationFrame(step);
    }

    function handleZoomMeterPointerUp(event) {
      if (!zoomMeterDrag.active || event.pointerId !== zoomMeterDrag.pointerId) {
        return;
      }
      event.preventDefault();
      zoomMeterDrag.active = false;
      zoomMeterDrag.pointerId = null;
      if (zoomMeterTape && typeof zoomMeterTape.releasePointerCapture === 'function') {
        try {
          zoomMeterTape.releasePointerCapture(event.pointerId);
        } catch (error) {
          // ignore
        }
      }
      window.removeEventListener('pointermove', handleZoomMeterPointerMove);
      window.removeEventListener('pointerup', handleZoomMeterPointerUp);
      window.removeEventListener('pointercancel', handleZoomMeterPointerUp);

      const velocity = computeZoomDragVelocity(event.timeStamp);
      zoomMeterDrag.samples = [];

      if (Math.abs(velocity) > 0.18) {
        startZoomMeterInertia(velocity);
      } else {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
      }
    }

    function setZoomSliderStepFromCapability() {
      if (!zoomSlider) {
        return;
      }
      let stepValue = 1;
      if (Array.isArray(cameraZoomCapability)) {
        if (cameraZoomCapability.length > 1) {
          stepValue = 100 / (cameraZoomCapability.length - 1);
        }
      } else if (cameraZoomCapability && typeof cameraZoomCapability === 'object') {
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        const step = Number(cameraZoomCapability.step);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min && Number.isFinite(step) && step > 0) {
          const ratioStep = (step / (max - min)) * 100;
          if (Number.isFinite(ratioStep) && ratioStep > 0) {
            stepValue = ratioStep;
          }
        }
      }
      if (!Number.isFinite(stepValue) || stepValue <= 0) {
        stepValue = 1;
      }
      if (stepValue >= 1) {
        const fractional = Math.abs(stepValue - Math.round(stepValue)) > 0.0001;
        zoomSlider.step = fractional ? stepValue.toFixed(2) : String(Math.round(stepValue));
      } else {
        const clamped = Math.max(stepValue, 0.001);
        zoomSlider.step = clamped.toFixed(3);
      }
    }

    function updateZoomSliderAvailability() {
      if (!zoomSlider || !zoomControl) {
        return;
      }
      if (zoomControlMode === 'color') {
        zoomControl.hidden = false;
        zoomControl.setAttribute('aria-hidden', 'false');
        zoomSlider.disabled = true;
        zoomSlider.setAttribute('aria-disabled', 'true');
        if (colorControl) {
          colorControl.hidden = false;
        }
        syncColorControls(activeOverlay && isOverlayHueAdjustable(activeOverlay) ? activeOverlay : null);
        return;
      }
      if (colorControl) {
        colorControl.hidden = true;
      }
      const value = state.cameraSettings.zoom ?? 0;
      const formatted = formatCameraSettingValue(value, 'zoom');
      const available = cameraZoomCapabilityKnown && Boolean(cameraZoomCapability);
      zoomSlider.disabled = !available;
      if (available) {
        zoomControl.hidden = false;
        zoomControl.setAttribute('aria-hidden', 'false');
        setZoomSliderStepFromCapability();
        zoomSlider.removeAttribute('aria-disabled');
        updateZoomScaleOptions();
      } else {
        zoomControl.hidden = true;
        zoomControl.setAttribute('aria-hidden', 'true');
        zoomSlider.step = '1';
        zoomSlider.setAttribute('aria-disabled', 'true');
        stopZoomMeterInertia({ finalize: false });
        if (zoomScaleTrack) {
          zoomScaleTrack.textContent = '';
          setZoomScaleTranslate(0, { animate: false });
        }
        zoomScaleMarks = [];
        zoomScaleItems = [];
        zoomMeterLastAppliedIndex = -1;
        setZoomMeterExpanded(false);
      }
      zoomSlider.value = String(value);
      zoomSlider.setAttribute('aria-valuenow', String(value));
      zoomSlider.setAttribute('aria-valuetext', formatted);
      refreshZoomMeterVisuals(value);
    }

    async function applyCameraSettingsToTrack() {
      const track = getActiveVideoTrack();
      if (!track || typeof track.applyConstraints !== 'function' || typeof track.getCapabilities !== 'function') {
        return false;
      }
      let capabilities;
      try {
        capabilities = track.getCapabilities();
      } catch (error) {
        if (!cameraConstraintErrorLogged) {
          console.warn('カメラ設定の取得に失敗しました', error);
          cameraConstraintErrorLogged = true;
        }
        return false;
      }
      if (!capabilities) {
        return false;
      }
      const hadKnownZoomCapability = cameraZoomCapabilityKnown;
      cameraZoomCapabilityKnown = true;
      if (Object.prototype.hasOwnProperty.call(capabilities, 'zoom')) {
        cameraZoomCapability = capabilities.zoom;
      } else {
        cameraZoomCapability = null;
      }
      if (!hadKnownZoomCapability && cameraZoomCapability) {
        syncZoomStateFromTrack(track);
      }
      updateZoomSliderAvailability();
      const constraint = {};
      let hasConstraint = false;
      CAMERA_SETTING_KEYS.forEach((key) => {
        const capabilityName = CAMERA_TRACK_CAPABILITY_MAP[key];
        if (!capabilityName || !(capabilityName in capabilities)) {
          return;
        }
        const capability = capabilities[capabilityName];
        const mappedValue = mapSliderValueToCapability(state.cameraSettings[key], capability, key);
        if (mappedValue == null) {
          return;
        }
        constraint[capabilityName] = mappedValue;
        hasConstraint = true;
      });
      if (!hasConstraint) {
        return false;
      }
      try {
        await track.applyConstraints({ advanced: [constraint] });
        cameraConstraintErrorLogged = false;
        return true;
      } catch (error) {
        if (!cameraConstraintErrorLogged) {
          console.warn('カメラ設定の適用に失敗しました', error);
          cameraConstraintErrorLogged = true;
        }
        return false;
      }
    }

    function updateStampEmptyState(isEmpty) {
      if (stampList) {
        stampList.hidden = Boolean(isEmpty);
      }
      if (stampEmptyMessage) {
        stampEmptyMessage.hidden = !isEmpty;
      }
    }

    async function handleStampSelection(stamp, button) {
      if (!stamp || !stamp.src) {
        return;
      }
      const targetButton = button || null;
      if (targetButton) {
        targetButton.disabled = true;
        targetButton.classList.add('is-loading');
      }
      try {
        const result = await createOverlayFromImageSource(stamp.src, { stamp });
        if (!result) {
          throw new Error('Failed to create overlay from stamp');
        }
        closeMenu('stamps');
      } catch (error) {
        console.error('スタンプの読み込みに失敗しました', error);
        setStatus('スタンプを読み込めませんでした');
      } finally {
        if (targetButton) {
          targetButton.disabled = false;
          targetButton.classList.remove('is-loading');
        }
      }
    }

    function populateStampPanel() {
      if (!stampList) {
        return;
      }
      stampList.textContent = '';
      const stamps = Array.isArray(STAMP_LIBRARY) ? STAMP_LIBRARY : [];
      if (!stamps.length) {
        updateStampEmptyState(true);
        return;
      }
      stamps.forEach((stamp) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'stamp-button';
        button.dataset.stampId = stamp.id || '';
        button.setAttribute('aria-label', `スタンプ ${stamp.label || stamp.id || ''}`.trim());
        const preview = document.createElement('span');
        preview.className = 'stamp-button__preview';
        const image = document.createElement('img');
        image.decoding = 'async';
        image.loading = 'lazy';
        image.src = stamp.src;
        image.alt = '';
        image.draggable = false;
        image.addEventListener('error', () => {
          if (button.parentElement === stampList) {
            stampList.removeChild(button);
            updateStampEmptyState(!stampList.querySelector('.stamp-button'));
          }
        });
        preview.appendChild(image);
        button.appendChild(preview);
        if (stamp.hueAdjustable) {
          button.dataset.hueAdjustable = 'true';
        }
        ['pointerdown', 'mousedown', 'touchstart'].forEach((type) => {
          button.addEventListener(type, (event) => event.stopPropagation(), { passive: false });
        });
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          void handleStampSelection(stamp, button);
        });
        stampList.appendChild(button);
      });
      updateStampEmptyState(!stampList.querySelector('.stamp-button'));
    }

    populateStampPanel();
    initializeCameraSettingsUI();

    function setSelectEnabled(selectElement, enabled) {
      if (!selectElement) {
        return;
      }
      const desired = Boolean(enabled);
      selectElement.disabled = !desired;
      if (desired) {
        selectElement.removeAttribute('aria-disabled');
      } else {
        selectElement.setAttribute('aria-disabled', 'true');
      }
    }

    function setDotScalePanelOpen(open) {
      if (!dotSettingsPanel) {
        dotScalePanelOpen = false;
        return;
      }
      const desired = Boolean(open && state.dotMode);
      dotScalePanelOpen = desired;
      dotSettingsPanel.hidden = !desired;
      dotSettingsPanel.classList.toggle('is-open', desired);
      if (dotModeBtn) {
        dotModeBtn.setAttribute('aria-expanded', desired ? 'true' : 'false');
      }
      if (!desired && paletteDisplayEnabled) {
        setPaletteDisplayEnabled(false);
      }
      if (desired) {
        openMenuKey = 'dotScale';
      } else if (openMenuKey === 'dotScale') {
        openMenuKey = null;
      }
    }

    function setDotSettingsOpen(open) {
      const desired = Boolean(open);
      setDotScalePanelOpen(desired);
    }

    function setMenuOpen(key, open) {
      const entry = menus[key];
      if (!entry || !entry.button || !entry.panel) {
        return;
      }
      if (open) {
        entry.panel.classList.add('is-open');
        entry.panel.hidden = false;
        entry.button.setAttribute('aria-expanded', 'true');
        openMenuKey = key;
      } else {
        entry.panel.classList.remove('is-open');
        entry.panel.hidden = true;
        entry.button.setAttribute('aria-expanded', 'false');
        if (openMenuKey === key) {
          openMenuKey = null;
        }
      }
    }

    function closeAllMenus(exceptKey = null) {
      if (exceptKey !== 'dotScale') {
        setDotSettingsOpen(false);
      }
      Object.keys(menus).forEach((key) => {
        if (key !== exceptKey) {
          setMenuOpen(key, false);
        }
      });
    }

    function openMenuExclusive(key) {
      if (key === 'dotScale') {
        if (!state.dotMode) {
          return;
        }
        closeAllMenus('dotScale');
        setDotSettingsOpen(true);
        return;
      }
      closeAllMenus(key);
      setMenuOpen(key, true);
    }

    function toggleMenu(key) {
      if (key === 'dotScale') {
        if (!state.dotMode) {
          return;
        }
        const isOpen = dotScalePanelOpen && dotSettingsPanel && !dotSettingsPanel.hidden;
        if (isOpen) {
          setDotSettingsOpen(false);
        } else {
          openMenuExclusive('dotScale');
        }
        return;
      }
      const entry = menus[key];
      if (!entry || !entry.panel) {
        return;
      }
      const isOpen = entry.panel.classList.contains('is-open');
      if (isOpen) {
        setMenuOpen(key, false);
        return;
      }
      openMenuExclusive(key);
    }

    function closeMenu(key) {
      if (key === 'dotScale') {
        setDotSettingsOpen(false);
        return;
      }
      setMenuOpen(key, false);
    }

    function updateControlPlacement() {
      if (!captureBtn || !captureButtonOriginalParent) {
        return;
      }
      const isLandscape = window.innerWidth > window.innerHeight;
      if (isLandscape) {
        document.body.classList.add('is-landscape');
        if (landscapeCaptureSlot) {
          if (captureBtn.parentElement !== landscapeCaptureSlot) {
            landscapeCaptureSlot.appendChild(captureBtn);
          }
          landscapeCaptureSlot.setAttribute('aria-hidden', 'false');
        }
      } else {
        document.body.classList.remove('is-landscape');
        if (captureBtn.parentElement !== captureButtonOriginalParent) {
          captureButtonOriginalParent.appendChild(captureBtn);
        }
        if (landscapeCaptureSlot) {
          landscapeCaptureSlot.setAttribute('aria-hidden', 'true');
        }
      }
      if (zoomControl && !zoomControl.hidden) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0, { animate: false });
      }
    }

    function setStatus(message) {
      if (hudTopBar) {
        hudTopBar.dataset.status = message || '';
      }
    }

    function setIconButtonLabel(button, label) {
      if (!button) {
        return;
      }
      button.setAttribute('aria-label', label);
      const hidden = button.querySelector('.icon-button__label');
      if (hidden) {
        hidden.textContent = label;
      }
    }

    function setCameraStatus(message) {
      cameraStatusMessage = message;
      if (!activeOverlay || !activeOverlay.hasImage) {
        setStatus(message);
      }
    }

    function setQrReadoutVisibility(visible) {
      if (!qrReadout) {
        return;
      }
      const desired = Boolean(visible);
      qrReadout.hidden = !desired;
      qrReadout.setAttribute('aria-hidden', desired ? 'false' : 'true');
    }

    function normalizeQrValue(value) {
      return typeof value === 'string' ? value.trim() : '';
    }

    function truncateQrValue(value, maxLength = 120) {
      const normalized = normalizeQrValue(value);
      if (!normalized) {
        return '';
      }
      if (normalized.length <= maxLength) {
        return normalized;
      }
      return `${normalized.slice(0, maxLength)}…`;
    }

    function getOpenableUrl(value) {
      const normalized = normalizeQrValue(value);
      if (!normalized) {
        return '';
      }
      try {
        const url = new URL(normalized, window.location.href);
        if (url.protocol === 'http:' || url.protocol === 'https:') {
          return url.toString();
        }
      } catch (error) {
        return '';
      }
      return '';
    }

    function updateQrReadout(message, stateLabel, options = {}) {
      if (!qrReadout) {
        return;
      }
      const {
        resultText = null,
        openUrl = '',
        forceShow = false,
        showPreview = false,
        allowAutoOpen = true
      } = options;
      const normalizedResult = normalizeQrValue(resultText) || qrLastValue;
      const hasResult = Boolean(normalizedResult);
      const shouldShow = forceShow || hasResult || Boolean(qrLastValue);
      if (!shouldShow) {
        setQrReadoutVisibility(false);
        return;
      }
      setQrReadoutVisibility(true);
      if (qrReadoutState) {
        qrReadoutState.textContent = stateLabel || '';
      }
      if (qrReadoutMessage) {
        qrReadoutMessage.textContent = message || '';
      }
      if (qrReadoutResult) {
        qrReadoutResult.hidden = !hasResult;
      }
      if (qrReadoutText) {
        qrReadoutText.textContent = hasResult ? normalizedResult : '';
      }
      qrReadout.classList.toggle('qr-readout--detected', hasResult);
      if (qrCopyBtn) {
        qrCopyBtn.disabled = !hasResult;
      }
      const resolvedOpenUrl = hasResult
        ? (openUrl || (allowAutoOpen ? getOpenableUrl(normalizedResult) : ''))
        : '';
      qrOpenTarget = resolvedOpenUrl;
      if (qrOpenBtn) {
        qrOpenBtn.disabled = !qrOpenTarget;
      }
      if (qrPreviewWrap && qrPreviewCanvas) {
        const hasPreview =
          !qrPreviewWrap.hidden &&
          qrPreviewCanvas.width > 0 &&
          qrPreviewCanvas.height > 0;
        qrPreviewWrap.hidden = !(showPreview && hasPreview);
      }
    }

    function setQrReadoutTitle(text) {
      if (qrReadoutTitle) {
        qrReadoutTitle.textContent = text;
      }
    }

    function clampValue(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function computeLuma(r, g, b) {
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    function quantizeChannel(value) {
      const normalized = Math.max(0, Math.min(255, value));
      const level = Math.round((normalized / 255) * (PIX_COLOR_LEVELS - 1));
      return Math.max(0, Math.min(PIX_COLOR_LEVELS - 1, level));
    }

    function estimateBinaryThreshold(imageData, width, height) {
      const data = imageData.data;
      const stride = 4;
      let min = 255;
      let max = 0;
      for (let y = 0; y < height; y += stride) {
        for (let x = 0; x < width; x += stride) {
          const idx = (y * width + x) * 4;
          const lum = computeLuma(data[idx], data[idx + 1], data[idx + 2]);
          if (lum < min) {
            min = lum;
          }
          if (lum > max) {
            max = lum;
          }
        }
      }
      const threshold = (min + max) / 2;
      return { threshold, min, max };
    }

    function isCmykPrimary(r, g, b) {
      const isCyan = r < 60 && g > 200 && b > 200;
      const isMagenta = g < 60 && r > 200 && b > 200;
      const isYellow = b < 60 && r > 200 && g > 200;
      return isCyan || isMagenta || isYellow;
    }

    function getLumaAt(data, width, x, y) {
      const idx = (y * width + x) * 4;
      return computeLuma(data[idx], data[idx + 1], data[idx + 2]);
    }

    function isDarkAt(data, width, x, y, threshold) {
      const idx = (y * width + x) * 4;
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      if (isCmykPrimary(r, g, b)) {
        return true;
      }
      return computeLuma(r, g, b) < threshold;
    }

    function matchFinderPattern(runs) {
      if (!runs || runs.length !== 5) {
        return null;
      }
      const total = runs.reduce((sum, value) => sum + value, 0);
      if (total < 7) {
        return null;
      }
      const module = total / 7;
      const tolerance = module * 0.7;
      if (Math.abs(runs[0] - module) > tolerance) return null;
      if (Math.abs(runs[1] - module) > tolerance) return null;
      if (Math.abs(runs[2] - module * 3) > module * 2.2) return null;
      if (Math.abs(runs[3] - module) > tolerance) return null;
      if (Math.abs(runs[4] - module) > tolerance) return null;
      return module;
    }

    function crossCheckVertical(data, width, height, centerX, centerY, threshold, expectedModule) {
      const x = clampValue(Math.round(centerX), 0, width - 1);
      let y = clampValue(Math.round(centerY), 0, height - 1);
      const run = [0, 0, 0, 0, 0];
      while (y >= 0 && isDarkAt(data, width, x, y, threshold)) {
        run[2] += 1;
        y -= 1;
      }
      while (y >= 0 && !isDarkAt(data, width, x, y, threshold)) {
        run[1] += 1;
        y -= 1;
      }
      while (y >= 0 && isDarkAt(data, width, x, y, threshold)) {
        run[0] += 1;
        y -= 1;
      }
      y = clampValue(Math.round(centerY) + 1, 0, height - 1);
      while (y < height && isDarkAt(data, width, x, y, threshold)) {
        run[2] += 1;
        y += 1;
      }
      while (y < height && !isDarkAt(data, width, x, y, threshold)) {
        run[3] += 1;
        y += 1;
      }
      while (y < height && isDarkAt(data, width, x, y, threshold)) {
        run[4] += 1;
        y += 1;
      }
      const module = matchFinderPattern(run);
      if (!module) {
        return null;
      }
      if (expectedModule && Math.abs(module - expectedModule) / expectedModule > 0.6) {
        return null;
      }
      return module;
    }

    function findFinderCandidates(imageData, width, height, threshold) {
      const data = imageData.data;
      const stride = 2;
      const candidates = [];
      for (let y = 0; y < height; y += stride) {
        let runLengths = [];
        let runColors = [];
        let current = isDarkAt(data, width, 0, y, threshold);
        let length = 1;
        for (let x = 1; x < width; x += 1) {
          const color = isDarkAt(data, width, x, y, threshold);
          if (color === current) {
            length += 1;
            continue;
          }
          runLengths.push(length);
          runColors.push(current);
          if (runLengths.length > 5) {
            runLengths.shift();
            runColors.shift();
          }
          if (
            runLengths.length === 5 &&
            runColors[0] &&
            !runColors[1] &&
            runColors[2] &&
            !runColors[3] &&
            runColors[4]
          ) {
            const module = matchFinderPattern(runLengths);
            if (module) {
              const centerX = x - (runLengths[4] + runLengths[3] + runLengths[2] / 2);
              const centerY = y;
              const verticalModule = crossCheckVertical(data, width, height, centerX, centerY, threshold, module);
              if (verticalModule) {
                candidates.push({
                  x: centerX,
                  y: centerY,
                  module: (module + verticalModule) / 2
                });
              }
            }
          }
          current = color;
          length = 1;
        }
      }
      return candidates;
    }

    function clusterFinderCandidates(candidates) {
      const clusters = [];
      candidates.forEach((candidate) => {
        let matched = false;
        clusters.forEach((cluster) => {
          const distance = Math.hypot(cluster.x - candidate.x, cluster.y - candidate.y);
          if (distance < candidate.module * 2) {
            const count = cluster.count + 1;
            cluster.x = (cluster.x * cluster.count + candidate.x) / count;
            cluster.y = (cluster.y * cluster.count + candidate.y) / count;
            cluster.module = (cluster.module * cluster.count + candidate.module) / count;
            cluster.count = count;
            matched = true;
          }
        });
        if (!matched) {
          clusters.push({ ...candidate, count: 1 });
        }
      });
      return clusters;
    }

    function scoreTriplet(tl, tr, bl) {
      const v1x = tr.x - tl.x;
      const v1y = tr.y - tl.y;
      const v2x = bl.x - tl.x;
      const v2y = bl.y - tl.y;
      const len1 = Math.hypot(v1x, v1y);
      const len2 = Math.hypot(v2x, v2y);
      if (len1 < 8 || len2 < 8) {
        return -Infinity;
      }
      const dot = Math.abs((v1x * v2x + v1y * v2y) / (len1 * len2));
      const angleScore = 1 - clampValue(dot, 0, 1);
      const ratio = Math.min(len1, len2) / Math.max(len1, len2);
      return angleScore * 0.7 + ratio * 0.3;
    }

    function selectFinderTriplet(candidates) {
      if (!candidates || candidates.length < 3) {
        return null;
      }
      let best = null;
      let bestScore = -Infinity;
      for (let i = 0; i < candidates.length - 2; i += 1) {
        for (let j = i + 1; j < candidates.length - 1; j += 1) {
          for (let k = j + 1; k < candidates.length; k += 1) {
            const points = [candidates[i], candidates[j], candidates[k]];
            points.sort((a, b) => (a.x + a.y) - (b.x + b.y));
            const tl = points[0];
            const p1 = points[1];
            const p2 = points[2];
            let tr = p1;
            let bl = p2;
            const score1 = scoreTriplet(tl, tr, bl);
            const score2 = scoreTriplet(tl, p2, p1);
            if (score2 > score1) {
              tr = p2;
              bl = p1;
            }
            const score = Math.max(score1, score2);
            if (score > bestScore) {
              bestScore = score;
              best = { tl, tr, bl };
            }
          }
        }
      }
      return best;
    }

    function samplePixel(data, width, height, x, y, radius = 1) {
      let r = 0;
      let g = 0;
      let b = 0;
      let count = 0;
      const cx = Math.round(x);
      const cy = Math.round(y);
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const px = cx + dx;
          const py = cy + dy;
          if (px < 0 || py < 0 || px >= width || py >= height) continue;
          const idx = (py * width + px) * 4;
          r += data[idx];
          g += data[idx + 1];
          b += data[idx + 2];
          count += 1;
        }
      }
      if (!count) {
        return { r: 255, g: 255, b: 255 };
      }
      return { r: r / count, g: g / count, b: b / count };
    }

    function findAlignmentCenter(imageData, width, height, target, searchRadius, threshold) {
      const data = imageData.data;
      if (!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)) {
        return null;
      }
      const radius = clampValue(Math.round(searchRadius), 6, 36);
      const startX = Math.max(0, Math.floor(target.x - radius));
      const endX = Math.min(width - 1, Math.ceil(target.x + radius));
      const startY = Math.max(0, Math.floor(target.y - radius));
      const endY = Math.min(height - 1, Math.ceil(target.y + radius));
      let sumX = 0;
      let sumY = 0;
      let count = 0;
      for (let y = startY; y <= endY; y += 2) {
        for (let x = startX; x <= endX; x += 2) {
          if (!isDarkAt(data, width, x, y, threshold)) {
            continue;
          }
          sumX += x;
          sumY += y;
          count += 1;
        }
      }
      if (count < 6) {
        return null;
      }
      return { x: sumX / count, y: sumY / count };
    }

    // Solve homography from grid to image for perspective correction.
    function computeHomography(srcPoints, dstPoints) {
      if (!Array.isArray(srcPoints) || srcPoints.length !== 4 || !Array.isArray(dstPoints) || dstPoints.length !== 4) {
        return null;
      }
      const A = [];
      const b = [];
      for (let i = 0; i < 4; i += 1) {
        const src = srcPoints[i];
        const dst = dstPoints[i];
        if (!src || !dst) {
          return null;
        }
        const x = src.x;
        const y = src.y;
        const X = dst.x;
        const Y = dst.y;
        if (![x, y, X, Y].every((value) => Number.isFinite(value))) {
          return null;
        }
        A.push([x, y, 1, 0, 0, 0, -x * X, -y * X]);
        b.push(X);
        A.push([0, 0, 0, x, y, 1, -x * Y, -y * Y]);
        b.push(Y);
      }
      const n = 8;
      for (let col = 0; col < n; col += 1) {
        let pivotRow = col;
        let max = Math.abs(A[col][col]);
        for (let row = col + 1; row < n; row += 1) {
          const value = Math.abs(A[row][col]);
          if (value > max) {
            max = value;
            pivotRow = row;
          }
        }
        if (max < 1e-9) {
          return null;
        }
        if (pivotRow !== col) {
          const tmpRow = A[col];
          A[col] = A[pivotRow];
          A[pivotRow] = tmpRow;
          const tmpB = b[col];
          b[col] = b[pivotRow];
          b[pivotRow] = tmpB;
        }
        const pivot = A[col][col];
        for (let c = col; c < n; c += 1) {
          A[col][c] /= pivot;
        }
        b[col] /= pivot;
        for (let row = 0; row < n; row += 1) {
          if (row === col) continue;
          const factor = A[row][col];
          if (Math.abs(factor) < 1e-9) continue;
          for (let c = col; c < n; c += 1) {
            A[row][c] -= factor * A[col][c];
          }
          b[row] -= factor * b[col];
        }
      }
      const h = b;
      return [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1];
    }

    function applyHomography(matrix, x, y) {
      const denom = matrix[6] * x + matrix[7] * y + matrix[8];
      if (!Number.isFinite(denom) || Math.abs(denom) < 1e-6) {
        return null;
      }
      return {
        x: (matrix[0] * x + matrix[1] * y + matrix[2]) / denom,
        y: (matrix[3] * x + matrix[4] * y + matrix[5]) / denom
      };
    }

    function gridToImagePoint(origin, vx, vy, gx, gy) {
      return {
        x: origin.x + (gx - PIX_FINDER_CENTER_OFFSET) * vx.x + (gy - PIX_FINDER_CENTER_OFFSET) * vy.x,
        y: origin.y + (gx - PIX_FINDER_CENTER_OFFSET) * vx.y + (gy - PIX_FINDER_CENTER_OFFSET) * vy.y
      };
    }

    async function hashPixQuantized(quantized) {
      if (!crypto?.subtle?.digest) return '';
      const digest = await crypto.subtle.digest('SHA-256', quantized);
      return Array.from(new Uint8Array(digest))
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
    }

    async function detectPixieeCode(imageData, width, height) {
      const { threshold, min, max } = estimateBinaryThreshold(imageData, width, height);
      const candidates = clusterFinderCandidates(findFinderCandidates(imageData, width, height, threshold));
      const triplet = selectFinderTriplet(candidates);
      if (!triplet) {
        return null;
      }
      const tl = triplet.tl;
      const tr = triplet.tr;
      const bl = triplet.bl;
      const vx = {
        x: (tr.x - tl.x) / PIX_AXIS_CELLS,
        y: (tr.y - tl.y) / PIX_AXIS_CELLS
      };
      const vy = {
        x: (bl.x - tl.x) / PIX_AXIS_CELLS,
        y: (bl.y - tl.y) / PIX_AXIS_CELLS
      };
      const vxLen = Math.hypot(vx.x, vx.y);
      const vyLen = Math.hypot(vy.x, vy.y);
      if (vxLen < 1 || vyLen < 1) {
        return null;
      }
      const dot = (vx.x * vy.x + vx.y * vy.y) / (vxLen * vyLen);
      if (Math.abs(dot) > 0.6) {
        return null;
      }
      const avgCell = (vxLen + vyLen) / 2;
      const sampleRadius = clampValue(Math.round(avgCell * 0.35), 1, 4);
      const predictedBr = {
        x: tl.x + vx.x * PIX_AXIS_CELLS + vy.x * PIX_AXIS_CELLS,
        y: tl.y + vx.y * PIX_AXIS_CELLS + vy.y * PIX_AXIS_CELLS
      };
      const matrix = computeHomography(
        [
          { x: PIX_FINDER_CENTER_OFFSET, y: PIX_FINDER_CENTER_OFFSET },
          { x: PIX_FRAME_SIZE - 1 - PIX_FINDER_CENTER_OFFSET, y: PIX_FINDER_CENTER_OFFSET },
          { x: PIX_FINDER_CENTER_OFFSET, y: PIX_FRAME_SIZE - 1 - PIX_FINDER_CENTER_OFFSET },
          { x: PIX_FRAME_SIZE - 1 - PIX_FINDER_CENTER_OFFSET, y: PIX_FRAME_SIZE - 1 - PIX_FINDER_CENTER_OFFSET }
        ],
        [tl, tr, bl, predictedBr]
      );
      if (!matrix) {
        return null;
      }
      let alignOffset = { x: 0, y: 0 };
      const alignOffsets = [];
      PIX_ALIGN_CENTERS.forEach((center) => {
        const predictedAlign = applyHomography(matrix, center.x, center.y);
        if (!predictedAlign) {
          return;
        }
        const alignCenter = findAlignmentCenter(
          imageData,
          width,
          height,
          predictedAlign,
          avgCell * 6,
          threshold
        );
        if (alignCenter) {
          alignOffsets.push({ x: alignCenter.x - predictedAlign.x, y: alignCenter.y - predictedAlign.y });
        }
      });
      if (alignOffsets.length) {
        const sum = alignOffsets.reduce((acc, cur) => ({ x: acc.x + cur.x, y: acc.y + cur.y }), { x: 0, y: 0 });
        alignOffset = { x: sum.x / alignOffsets.length, y: sum.y / alignOffsets.length };
      }
      const mapGridPoint = (gx, gy) => {
        const pt = applyHomography(matrix, gx, gy);
        if (!pt) {
          return null;
        }
        return { x: pt.x + alignOffset.x, y: pt.y + alignOffset.y };
      };
      const sampleAt = (gx, gy) => {
        const offsets = [
          [0, 0],
          [0.25, 0],
          [-0.25, 0],
          [0, 0.25],
          [0, -0.25]
        ];
        const reds = [];
        const greens = [];
        const blues = [];
        offsets.forEach(([ox, oy]) => {
          const pt = mapGridPoint(gx + ox, gy + oy);
          if (!pt) {
            return;
          }
          const color = samplePixel(imageData.data, width, height, pt.x, pt.y, sampleRadius);
          reds.push(color.r);
          greens.push(color.g);
          blues.push(color.b);
        });
        if (!reds.length) {
          return { r: 255, g: 255, b: 255 };
        }
        const median = (values) => {
          const sorted = values.slice().sort((a, b) => a - b);
          return sorted[Math.floor(sorted.length / 2)];
        };
        return { r: median(reds), g: median(greens), b: median(blues) };
      };

      const timingSamples = () => {
        const darkLuma = [];
        const lightLuma = [];
        const darkColors = { r: [], g: [], b: [] };
        const lightColors = { r: [], g: [], b: [] };
        const pushColor = (bucket, color) => {
          bucket.r.push(color.r);
          bucket.g.push(color.g);
          bucket.b.push(color.b);
        };
        for (let x = PIX_TIMING_START; x <= PIX_TIMING_END; x += 1) {
          const color = sampleAt(x, PIX_TIMING_ROW);
          const lum = computeLuma(color.r, color.g, color.b);
          if ((x - PIX_TIMING_START) % 2 === 0) {
            darkLuma.push(lum);
            pushColor(darkColors, color);
          } else {
            lightLuma.push(lum);
            pushColor(lightColors, color);
          }
        }
        for (let y = PIX_TIMING_START; y <= PIX_TIMING_END; y += 1) {
          const color = sampleAt(PIX_TIMING_COL, y);
          const lum = computeLuma(color.r, color.g, color.b);
          if ((y - PIX_TIMING_START) % 2 === 0) {
            darkLuma.push(lum);
            pushColor(darkColors, color);
          } else {
            lightLuma.push(lum);
            pushColor(lightColors, color);
          }
        }
        if (!darkLuma.length || !lightLuma.length) {
          return null;
        }
        const avg = (values) => values.reduce((sum, v) => sum + v, 0) / values.length;
        const avgColor = (bucket) => ({
          r: avg(bucket.r),
          g: avg(bucket.g),
          b: avg(bucket.b)
        });
        return {
          darkLum: avg(darkLuma),
          lightLum: avg(lightLuma),
          darkColor: avgColor(darkColors),
          lightColor: avgColor(lightColors)
        };
      };

      const timing = timingSamples();
      const timingThreshold = timing ? (timing.darkLum + timing.lightLum) / 2 : threshold;
      const averageColors = (colors) => {
        if (!colors.length) return null;
        const sum = colors.reduce((acc, cur) => ({
          r: acc.r + cur.r,
          g: acc.g + cur.g,
          b: acc.b + cur.b
        }), { r: 0, g: 0, b: 0 });
        return {
          r: sum.r / colors.length,
          g: sum.g / colors.length,
          b: sum.b / colors.length
        };
      };
      const samplePatchAverage = (startX, startY, size) => {
        const colors = [];
        for (let y = 0; y < size; y += 1) {
          for (let x = 0; x < size; x += 1) {
            colors.push(sampleAt(startX + x, startY + y));
          }
        }
        return averageColors(colors);
      };
      const sampleAreaAverage = (startX, startY, width, height) => {
        const colors = [];
        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            colors.push(sampleAt(startX + x, startY + y));
          }
        }
        return averageColors(colors);
      };
      const samplePointsAverage = (points) => {
        const colors = points.map((point) => sampleAt(point.x, point.y));
        return averageColors(colors);
      };
      const isNearWhite = (color) => {
        if (!color) return true;
        return color.r > 230 && color.g > 230 && color.b > 230;
      };
      const sanitizeRef = (color) => (isNearWhite(color) ? null : color);
      const cyanRef = samplePatchAverage(2, 2, 3);
      const yellowRef = samplePatchAverage(PIX_FRAME_SIZE - PIX_FINDER_SIZE + 2, 2, 3);
      const magentaRef = samplePatchAverage(2, PIX_FRAME_SIZE - PIX_FINDER_SIZE + 2, 3);
      const blackRef = samplePatchAverage(PIX_ALIGN_START, PIX_ALIGN_START, PIX_ALIGN_SIZE);
      const whiteRef = samplePointsAverage([
        { x: PIX_FINDER_SIZE, y: 1 },
        { x: 1, y: PIX_FINDER_SIZE },
        { x: PIX_FINDER_SIZE, y: PIX_FINDER_SIZE }
      ]);
      const redRef = sampleAt(PIX_RGB_PATCH_X + 1, PIX_RGB_PATCH_Y + 1);
      const greenRef = sampleAt(PIX_RGB_PATCH_X + 1, PIX_RGB_PATCH_Y + 1 + (PIX_RGB_PATCH_SIZE + PIX_RGB_PATCH_GAP));
      const blueRef = sampleAt(PIX_RGB_PATCH_X + 1, PIX_RGB_PATCH_Y + 1 + (PIX_RGB_PATCH_SIZE + PIX_RGB_PATCH_GAP) * 2);
      const fallbackBlack = timing?.darkColor ? timing.darkColor : { r: 0, g: 0, b: 0 };
      const fallbackWhite = timing?.lightColor ? timing.lightColor : { r: 255, g: 255, b: 255 };
      const refBlack = blackRef || fallbackBlack;
      const refWhite = whiteRef || fallbackWhite;
      const refCyan = cyanRef || { r: 0, g: 255, b: 255 };
      const refMagenta = magentaRef || { r: 255, g: 0, b: 255 };
      const refYellow = yellowRef || { r: 255, g: 255, b: 0 };
      const refRed = sanitizeRef(redRef);
      const refGreen = sanitizeRef(greenRef);
      const refBlue = sanitizeRef(blueRef);
      const avg = (...values) => values.reduce((sum, value) => sum + value, 0) / values.length;
      const avgChannel = (colors, key, fallback) => {
        const values = colors
          .map((color) => (color ? color[key] : null))
          .filter((value) => Number.isFinite(value));
        if (!values.length) return fallback;
        return values.reduce((sum, value) => sum + value, 0) / values.length;
      };
      const channelRefs = {
        r: {
          low: avgChannel([refBlack, refCyan, refGreen, refBlue], 'r', fallbackBlack.r),
          high: avgChannel([refWhite, refMagenta, refYellow, refRed], 'r', fallbackWhite.r)
        },
        g: {
          low: avgChannel([refBlack, refMagenta, refRed, refBlue], 'g', fallbackBlack.g),
          high: avgChannel([refWhite, refCyan, refYellow, refGreen], 'g', fallbackWhite.g)
        },
        b: {
          low: avgChannel([refBlack, refYellow, refRed, refGreen], 'b', fallbackBlack.b),
          high: avgChannel([refWhite, refCyan, refMagenta, refBlue], 'b', fallbackWhite.b)
        }
      };
      const fallbackChannelRefs = {
        r: { low: fallbackBlack.r, high: fallbackWhite.r },
        g: { low: fallbackBlack.g, high: fallbackWhite.g },
        b: { low: fallbackBlack.b, high: fallbackWhite.b }
      };
      const sanitizeChannelRange = (ref, fallback) => {
        const range = ref.high - ref.low;
        if (!Number.isFinite(range) || range < 8) {
          return fallback;
        }
        return ref;
      };
      const safeChannelRefs = {
        r: sanitizeChannelRange(channelRefs.r, fallbackChannelRefs.r),
        g: sanitizeChannelRange(channelRefs.g, fallbackChannelRefs.g),
        b: sanitizeChannelRange(channelRefs.b, fallbackChannelRefs.b)
      };
      const normalizeChannel = (value, black, white) => {
        const range = white - black;
        if (!Number.isFinite(range) || range < 8) {
          return clampValue(Math.round(value), 0, 255);
        }
        return clampValue(Math.round(((value - black) * 255) / range), 0, 255);
      };
      const normalizeColor = (color) => ({
        r: normalizeChannel(color.r, safeChannelRefs.r.low, safeChannelRefs.r.high),
        g: normalizeChannel(color.g, safeChannelRefs.g.low, safeChannelRefs.g.high),
        b: normalizeChannel(color.b, safeChannelRefs.b.low, safeChannelRefs.b.high)
      });
      const checkTiming = () => {
        let matches = 0;
        let total = 0;
        for (let x = PIX_TIMING_START; x <= PIX_TIMING_END; x += 1) {
          const color = sampleAt(x, PIX_TIMING_ROW);
          const lum = computeLuma(color.r, color.g, color.b);
          const expectDark = (x - PIX_TIMING_START) % 2 === 0;
          if ((lum < timingThreshold) === expectDark) {
            matches += 1;
          }
          total += 1;
        }
        for (let y = PIX_TIMING_START; y <= PIX_TIMING_END; y += 1) {
          const color = sampleAt(PIX_TIMING_COL, y);
          const lum = computeLuma(color.r, color.g, color.b);
          const expectDark = (y - PIX_TIMING_START) % 2 === 0;
          if ((lum < timingThreshold) === expectDark) {
            matches += 1;
          }
          total += 1;
        }
        if (!total) {
          return 0;
        }
        return matches / total;
      };
      if (checkTiming() < 0.6) {
        return null;
      }

      const checkFormatBand = () => {
        let matches = 0;
        let total = 0;
        for (let x = PIX_FORMAT_START; x <= PIX_FORMAT_END; x += 1) {
          const idx = x - PIX_FORMAT_START;
          const expectDark = PIX_FORMAT_BITS[idx];
          const rowColor = sampleAt(x, PIX_FORMAT_ROW);
          const rowLum = computeLuma(rowColor.r, rowColor.g, rowColor.b);
          if ((rowLum < timingThreshold) === expectDark) {
            matches += 1;
          }
          total += 1;
          const colColor = sampleAt(PIX_FORMAT_COL, PIX_FORMAT_START + idx);
          const colLum = computeLuma(colColor.r, colColor.g, colColor.b);
          if ((colLum < timingThreshold) === expectDark) {
            matches += 1;
          }
          total += 1;
        }
        return total ? matches / total : 0;
      };

      if (checkFormatBand() < 0.6) {
        return null;
      }

      const buildQuantized = () => {
        const quantized = new Uint8Array(PIX_ART_SIZE * PIX_ART_SIZE * 3);
        let writeIndex = 0;
        for (let y = 0; y < PIX_ART_SIZE; y++) {
          for (let x = 0; x < PIX_ART_SIZE; x++) {
            const color = sampleAt(PIX_FRAME_OFFSET + x, PIX_FRAME_OFFSET + y);
            const normalized = normalizeColor(color);
            quantized[writeIndex++] = quantizeChannel(normalized.r);
            quantized[writeIndex++] = quantizeChannel(normalized.g);
            quantized[writeIndex++] = quantizeChannel(normalized.b);
          }
        }
        return quantized;
      };

      const primaryQuantized = buildQuantized();
      const hash = await hashPixQuantized(primaryQuantized);
      if (!hash) return null;

      const cornerPoints = [
        mapGridPoint(0, 0),
        mapGridPoint(PIX_FRAME_SIZE - 1, 0),
        mapGridPoint(0, PIX_FRAME_SIZE - 1),
        mapGridPoint(PIX_FRAME_SIZE - 1, PIX_FRAME_SIZE - 1)
      ].filter(Boolean);
      if (cornerPoints.length < 4) {
        return null;
      }
      const xs = cornerPoints.map((p) => p.x);
      const ys = cornerPoints.map((p) => p.y);
      const previewBox = {
        x: clampValue(Math.min(...xs), 0, width - 1),
        y: clampValue(Math.min(...ys), 0, height - 1),
        width: clampValue(Math.max(...xs) - Math.min(...xs), 1, width),
        height: clampValue(Math.max(...ys) - Math.min(...ys), 1, height)
      };
      const hashes = [hash];
      return { hash, hashes, previewBox };
    }

    async function fetchPixCodePayload(hashes) {
      const list = Array.isArray(hashes) ? hashes.filter(Boolean) : [hashes].filter(Boolean);
      if (!list.length) return null;
      const cacheHit = list.find((item) => pixLookupCache.has(item));
      if (cacheHit) {
        return { hash: cacheHit, payload: pixLookupCache.get(cacheHit) };
      }
      const cacheKey = list.join(',');
      if (pixLookupPromises.has(cacheKey)) {
        return pixLookupPromises.get(cacheKey);
      }
      const filter = list.length === 1 ? `hash=eq.${list[0]}` : `hash=in.(${list.join(',')})`;
      const promise = fetch(`${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}?${filter}&select=hash,payload_type,payload_value&limit=1`, {
        headers: {
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`
        }
      }).then(async (res) => {
        if (!res.ok) return null;
        const data = await res.json();
        const payload = Array.isArray(data) && data[0] ? data[0] : null;
        if (payload && payload.hash) {
          pixLookupCache.set(payload.hash, payload);
          return { hash: payload.hash, payload };
        }
        return null;
      }).catch(() => null).finally(() => {
        pixLookupPromises.delete(cacheKey);
      });
      pixLookupPromises.set(cacheKey, promise);
      return promise;
    }

    async function ensureQrDetector() {
      if (qrDetector) {
        qrSupportAvailable = true;
        return qrDetector;
      }
      if (qrSupportAvailable === false) {
        return null;
      }
      if (!('BarcodeDetector' in window)) {
        qrSupportAvailable = false;
        return null;
      }
      try {
        if (typeof window.BarcodeDetector.getSupportedFormats === 'function') {
          const supported = await window.BarcodeDetector.getSupportedFormats();
          if (Array.isArray(supported) && !supported.includes('qr_code')) {
            qrSupportAvailable = false;
            return null;
          }
        }
        qrDetector = new window.BarcodeDetector({ formats: ['qr_code'] });
        qrSupportAvailable = true;
        return qrDetector;
      } catch (error) {
        qrSupportAvailable = false;
        console.warn('BarcodeDetector unavailable', error);
        return null;
      }
    }

    function stopQrScanLoop() {
      if (qrScanLoopHandle) {
        clearTimeout(qrScanLoopHandle);
        qrScanLoopHandle = null;
      }
    }

    function scheduleQrScanLoop(delay = QR_SCAN_DEFAULT_INTERVAL_MS) {
      if (!qrScanEnabled) {
        stopQrScanLoop();
        return;
      }
      stopQrScanLoop();
      qrScanLoopHandle = window.setTimeout(() => {
        qrScanLoopHandle = null;
        void handleQrScanTick();
      }, Math.max(40, Number.isFinite(delay) ? delay : QR_SCAN_DEFAULT_INTERVAL_MS));
    }

    function updateQrPreviewFromDetection(boundingBox) {
      if (!qrPreviewCanvas || !qrPreviewWrap || !qrScanCtx || !qrScanCanvas) {
        return false;
      }
      const ctx = qrPreviewCanvas.getContext('2d', { willReadFrequently: true });
      if (!ctx || !boundingBox) {
        return false;
      }
      const margin = 8;
      const sx = Math.max(0, Math.floor((boundingBox.x || 0) - margin));
      const sy = Math.max(0, Math.floor((boundingBox.y || 0) - margin));
      const sw = Math.max(1, Math.min(qrScanCanvas.width - sx, Math.ceil((boundingBox.width || 0) + margin * 2)));
      const sh = Math.max(1, Math.min(qrScanCanvas.height - sy, Math.ceil((boundingBox.height || 0) + margin * 2)));
      let imageData = null;
      try {
        imageData = qrScanCtx.getImageData(sx, sy, sw, sh);
      } catch (error) {
        imageData = null;
      }
      if (!imageData) {
        return false;
      }
      qrPreviewCanvas.width = sw;
      qrPreviewCanvas.height = sh;
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, sw, sh);
      ctx.putImageData(imageData, 0, 0);
      const targetSize = Math.min(280, Math.max(140, sw * 2));
      const displayWidth = targetSize;
      const displayHeight = Math.max(80, Math.round((targetSize * sh) / sw));
      qrPreviewCanvas.style.width = `${displayWidth}px`;
      qrPreviewCanvas.style.height = `${displayHeight}px`;
      qrPreviewWrap.hidden = false;
      return true;
    }

    async function scanQrFrame() {
      if (!qrScanCanvas || !qrScanCtx || !video || video.readyState < 2) {
        return null;
      }
      const viewportWidth = Math.max(1, Math.round(window.innerWidth || video.videoWidth || QR_SCAN_BASE_SIZE));
      const viewportHeight = Math.max(1, Math.round(window.innerHeight || video.videoHeight || QR_SCAN_MIN_SIZE));
      const targetWidth = Math.max(QR_SCAN_MIN_SIZE, Math.min(QR_SCAN_BASE_SIZE, viewportWidth));
      const targetHeight = Math.max(QR_SCAN_MIN_SIZE, Math.min(QR_SCAN_BASE_SIZE, viewportHeight));
      qrScanCanvas.width = targetWidth;
      qrScanCanvas.height = targetHeight;
      qrScanCtx.imageSmoothingEnabled = false;
      const sourceRect = getVideoCoverSourceRect(targetWidth, targetHeight);
      if (!sourceRect) {
        return null;
      }
      qrScanCtx.clearRect(0, 0, targetWidth, targetHeight);
      qrScanCtx.drawImage(
        video,
        sourceRect.sx,
        sourceRect.sy,
        sourceRect.sw,
        sourceRect.sh,
        0,
        0,
        targetWidth,
        targetHeight
      );
      let imageData;
      try {
        imageData = qrScanCtx.getImageData(0, 0, targetWidth, targetHeight);
      } catch (error) {
        imageData = null;
      }
      let pixResult = null;
      if (imageData && imageData.data) {
        try {
          pixResult = await detectPixieeCode(imageData, targetWidth, targetHeight);
        } catch (error) {
          pixResult = null;
        }
      }
      if (imageData && imageData.data) {
        const { data } = imageData;
        let sum = 0;
        const total = data.length / 4;
        for (let i = 0; i < data.length; i += 4) {
          const l = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
          sum += l;
        }
        const avg = total ? sum / total : 128;
        const threshold = Math.min(240, Math.max(48, avg * 0.94));
        for (let i = 0; i < data.length; i += 4) {
          const l = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
          const v = l >= threshold ? 255 : 0;
          data[i] = v;
          data[i + 1] = v;
          data[i + 2] = v;
        }
        qrScanCtx.putImageData(imageData, 0, 0);
      }
      const detector = await ensureQrDetector();
      if (!detector) {
        return { qr: null, pix: pixResult };
      }
      const barcodes = await detector.detect(qrScanCanvas);
      if (Array.isArray(barcodes) && barcodes.length) {
        const code = barcodes.find((entry) => normalizeQrValue(entry.rawValue)) || barcodes[0];
        if (code && typeof code.rawValue === 'string') {
          const previewGenerated = updateQrPreviewFromDetection(code.boundingBox || null);
          return { qr: { value: code.rawValue.trim(), previewGenerated }, pix: pixResult };
        }
      }
      return { qr: null, pix: pixResult };
    }

    function handleQrDetection(payload) {
      const normalized = normalizeQrValue(payload && typeof payload === 'object' ? payload.value : payload);
      if (!normalized) {
        return;
      }
      const isNew = normalized !== qrLastValue;
      qrLastValue = normalized;
      setQrReadoutTitle('QRスキャン');
      const openUrl = getOpenableUrl(normalized);
      updateQrReadout('QRコードを読み取りました。', '検出', {
        resultText: normalized,
        openUrl,
        forceShow: true,
        showPreview: Boolean(payload && payload.previewGenerated)
      });
      setStatus(`QR検出: ${truncateQrValue(normalized, 64)}`);
      if (isNew && navigator.vibrate) {
        try {
          navigator.vibrate(80);
        } catch (error) {
          // ignore vibration failures
        }
      }
    }

    async function handlePixDetection(payload) {
      if (!payload || !payload.hash) {
        return false;
      }
      const now = Date.now();
      if (payload.hash === pixLastHash && now - pixLastDetectedAt < 2000) {
        return true;
      }
      pixLastHash = payload.hash;
      pixLastDetectedAt = now;
      setQrReadoutTitle('PiXiEEDコード');
      let previewGenerated = false;
      if (payload.previewBox) {
        previewGenerated = updateQrPreviewFromDetection(payload.previewBox);
      }
      updateQrReadout('PiXiEEDコードを検出しました。照会中...', '検出中', {
        resultText: payload.hash.slice(0, 16),
        forceShow: true,
        showPreview: previewGenerated,
        allowAutoOpen: false
      });
      const lookup = await fetchPixCodePayload(payload.hashes || payload.hash);
      const record = lookup && lookup.payload ? lookup.payload : null;
      if (lookup && lookup.hash) {
        pixLastHash = lookup.hash;
      }
      if (record && record.payload_value) {
        qrLastValue = record.payload_value;
        const openUrl = record.payload_type === 'url' ? record.payload_value : '';
        updateQrReadout('PiXiEEDコードを読み取りました。', '検出', {
          resultText: record.payload_value,
          openUrl,
          forceShow: true,
          showPreview: previewGenerated,
          allowAutoOpen: record.payload_type === 'url'
        });
        setStatus(`PiXiEEDコード検出: ${truncateQrValue(record.payload_value, 64)}`);
      } else {
        qrLastValue = '';
        updateQrReadout('PiXiEEDコードは未登録です。', '未登録', {
          resultText: payload.hash,
          forceShow: true,
          showPreview: previewGenerated,
          allowAutoOpen: false
        });
        setStatus('PiXiEEDコードは未登録です');
      }
      return true;
    }

    async function handleQrScanTick() {
      if (!qrScanEnabled) {
        stopQrScanLoop();
        return;
      }
      if (!qrScanCtx) {
        qrSupportAvailable = false;
        setStatus('このブラウザはQRスキャンに対応していません。最新のブラウザでお試しください。');
        stopQrScanLoop();
        return;
      }
      if (!cameraReady || !state.stream || !video || video.readyState < 2) {
        scheduleQrScanLoop(800);
        return;
      }
      try {
        const result = await scanQrFrame();
        if (qrSupportAvailable === false && !qrSupportWarningShown) {
          setStatus('QRスキャン非対応のため、PiXiEEDコードのみ検出します。');
          qrSupportWarningShown = true;
        }
        if (result && result.qr) {
          handleQrDetection(result.qr);
          scheduleQrScanLoop(700);
          return;
        }
        if (result && result.pix) {
          await handlePixDetection(result.pix);
          scheduleQrScanLoop(700);
          return;
        }
        scheduleQrScanLoop(QR_SCAN_DEFAULT_INTERVAL_MS);
      } catch (error) {
        console.warn('QR scan failed', error);
        scheduleQrScanLoop(600);
      }
    }

    function releaseCapturePreviewUrl() {
      if (capturePreviewObjectUrl) {
        URL.revokeObjectURL(capturePreviewObjectUrl);
        capturePreviewObjectUrl = null;
      }
      if (capturePreviewSharePayload && capturePreviewSharePayload.blobUrl && capturePreviewSharePayload.blobUrl !== capturePreviewObjectUrl) {
        URL.revokeObjectURL(capturePreviewSharePayload.blobUrl);
      }
    }

    function closeCapturePreview() {
      if (!capturePreviewOverlay) {
        return;
      }
      releaseCapturePreviewUrl();
      capturePreviewOverlay.hidden = true;
      capturePreviewOverlay.setAttribute('aria-hidden', 'true');
      capturePreviewOverlay.classList.remove('is-visible');
      if (capturePreviewImage) {
        capturePreviewImage.src = '';
      }
      capturePreviewSharePayload = null;
      capturePreviewEditPayload = null;
      if (capturePreviewEditBtn) {
        capturePreviewEditBtn.hidden = true;
        capturePreviewEditBtn.disabled = true;
      }
      if (capturePreviewLastFocus && document.contains(capturePreviewLastFocus)) {
        capturePreviewLastFocus.focus({ preventScroll: true });
      }
      capturePreviewLastFocus = null;
    }

    function registerGestureCameraStarter() {
      if (iosStandaloneUnsupported) {
        return;
      }
      if (gestureStartRegistered) {
        return;
      }
      if (gestureStartHandler) {
        document.removeEventListener('click', gestureStartHandler, true);
        document.removeEventListener('touchend', gestureStartHandler, true);
        gestureStartHandler = null;
      }
      gestureStartHandler = (event) => {
        gestureStartRegistered = false;
        gestureStartHandler = null;
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        if (cameraReady || cameraStartButtonBusy) {
          return;
        }
        cameraStartLocked = false;
        handleCameraStartRequest();
      };
      document.addEventListener('click', gestureStartHandler, { once: true, capture: true });
      document.addEventListener('touchend', gestureStartHandler, { once: true, capture: true, passive: false });
      gestureStartRegistered = true;
    }

    function showCameraStartOverlay(message) {
      if (!cameraStartOverlay) {
        return;
      }
      cameraStartLocked = true;
      if (cameraStartMessage) {
        cameraStartMessage.textContent = message;
      }
      if (cameraStartButton) {
        cameraStartButton.disabled = false;
        cameraStartButton.textContent = cameraStartButtonLabel;
        cameraStartButton.removeAttribute('aria-busy');
      }
      cameraStartButtonBusy = false;
      cameraStartOverlayLastFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      cameraStartOverlay.hidden = false;
      cameraStartOverlay.setAttribute('aria-hidden', 'false');
      cameraStartOverlay.classList.add('is-visible');
      setCameraStatus(message);
      if (cameraStartButton) {
        cameraStartButton.focus({ preventScroll: true });
      }
      registerGestureCameraStarter();
    }

    function showIOSStandaloneUnsupportedOverlay() {
      if (!cameraStartOverlay) {
        return;
      }
      cameraStartLocked = true;
      const message = 'iPhone のホーム画面に追加した PiXiEELENS ではカメラが利用できません。Safari でこのページを開き直してご利用ください。（共有ボタン → “Safariで開く” を実行した後にご利用ください）';
      if (cameraStartMessage) {
        cameraStartMessage.textContent = message;
      }
      cameraStartOverlay.hidden = false;
      cameraStartOverlay.setAttribute('aria-hidden', 'false');
      cameraStartOverlay.classList.add('is-visible');
      setCameraStatus(message);
      cameraStartButtonBusy = false;
      if (cameraStartButton) {
        cameraStartButton.style.display = 'none';
        cameraStartButton.disabled = true;
      }
      if (cameraStartActions) {
        cameraStartActions.style.display = 'none';
      }
      if (gestureStartHandler) {
        document.removeEventListener('click', gestureStartHandler, true);
        document.removeEventListener('touchend', gestureStartHandler, true);
        gestureStartHandler = null;
      }
      gestureStartRegistered = false;
    }

    function hideCameraStartOverlay() {
      if (!cameraStartOverlay) {
        return;
      }
      cameraStartOverlay.hidden = true;
      cameraStartOverlay.setAttribute('aria-hidden', 'true');
      cameraStartOverlay.classList.remove('is-visible');
      if (cameraStartButton) {
        cameraStartButton.disabled = false;
        cameraStartButton.textContent = cameraStartButtonLabel;
        cameraStartButton.removeAttribute('aria-busy');
      }
      cameraStartButtonBusy = false;
      if (gestureStartHandler) {
        document.removeEventListener('click', gestureStartHandler, true);
        document.removeEventListener('touchend', gestureStartHandler, true);
        gestureStartHandler = null;
      }
      gestureStartRegistered = false;
      if (cameraStartOverlayLastFocus && document.contains(cameraStartOverlayLastFocus)) {
        cameraStartOverlayLastFocus.focus({ preventScroll: true });
      }
      cameraStartOverlayLastFocus = null;
    }

    function waitForVideoReady(timeout = CAMERA_READY_TIMEOUT_MS) {
      if (!video) {
        return Promise.reject(new Error('Video element unavailable'));
      }
      if (video.readyState >= 2 && video.videoWidth && video.videoHeight) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        let settled = false;
        let timer = null;
        const cleanup = () => {
          if (settled) {
            return;
          }
          settled = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          video.removeEventListener('loadeddata', onLoaded);
          video.removeEventListener('canplay', onLoaded);
          video.removeEventListener('error', onError);
        };
        const onLoaded = () => {
          cleanup();
          resolve();
        };
        const onError = (event) => {
          cleanup();
          reject(event?.error || new Error('Camera stream error'));
        };
        timer = setTimeout(() => {
          cleanup();
          reject(new Error('CameraReadyTimeout'));
        }, timeout);
        video.addEventListener('loadeddata', onLoaded, { once: true });
        video.addEventListener('canplay', onLoaded, { once: true });
        video.addEventListener('error', onError, { once: true });
      });
    }

    async function handleCameraStartRequest() {
      if (cameraStartButtonBusy) {
        return;
      }
      cameraStartButtonBusy = true;
      if (cameraStartButton) {
        cameraStartButton.disabled = true;
        cameraStartButton.textContent = '起動中…';
        cameraStartButton.setAttribute('aria-busy', 'true');
      }
      try {
        const success = await startCamera();
        if (!success && !cameraPermissionDenied) {
          setCameraStatus('カメラを起動できませんでした。もう一度お試しください。');
        }
      } finally {
        cameraStartButtonBusy = false;
        if (cameraStartButton) {
          cameraStartButton.disabled = false;
          cameraStartButton.textContent = cameraStartButtonLabel;
          cameraStartButton.removeAttribute('aria-busy');
        }
      }
    }

    function showCapturePreview({ url, filename, width, height, sharePayload, infoMessage, drawPayload }) {
      if (!capturePreviewOverlay || !capturePreviewImage) {
        if (url) {
          window.open(url, '_blank', 'noopener');
        }
        return;
      }
      capturePreviewLastFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      releaseCapturePreviewUrl();
      if (sharePayload && sharePayload.blobUrl) {
        capturePreviewObjectUrl = sharePayload.blobUrl;
      } else if (typeof url === 'string' && url.startsWith('blob:')) {
        capturePreviewObjectUrl = url;
      }
      capturePreviewImage.src = url;
      capturePreviewImage.alt = `撮影した画像 ${width}×${height}`;
      if (!infoMessage && drawPayload) {
        infoMessage = '画像を長押しして保存するか、「PiXiEEDrawで編集」で編集できます。';
      }
      if (capturePreviewInfo) {
        capturePreviewInfo.textContent = infoMessage || '画像を長押しするか共有メニューから保存してください。';
      }
      const canShare = Boolean(sharePayload && sharePayload.file) && typeof navigator.share === 'function' && (!navigator.canShare || navigator.canShare({ files: [sharePayload.file] }));
      capturePreviewSharePayload = canShare && sharePayload
        ? { file: sharePayload.file, blobUrl: sharePayload.blobUrl }
        : null;
      if (capturePreviewShareBtn) {
        capturePreviewShareBtn.hidden = !capturePreviewSharePayload;
        capturePreviewShareBtn.disabled = !capturePreviewSharePayload;
      }
      capturePreviewEditPayload = drawPayload && typeof drawPayload.dataUrl === 'string' && drawPayload.dataUrl
        ? { ...drawPayload }
        : null;
      if (capturePreviewEditBtn) {
        const available = Boolean(capturePreviewEditPayload);
        capturePreviewEditBtn.hidden = !available;
        capturePreviewEditBtn.disabled = !available;
      }
      capturePreviewOverlay.hidden = false;
      capturePreviewOverlay.setAttribute('aria-hidden', 'false');
      capturePreviewOverlay.classList.add('is-visible');
      if (capturePreviewCloseBtn) {
        capturePreviewCloseBtn.focus({ preventScroll: true });
      }
    }

    const CAMERA_ICON_SWITCH_CONTENT = [
      '<rect x="5" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="13" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="4" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="14" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="4" y="2" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="15" y="2" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="19" y="2" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="8" y="3" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="5" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="9" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="18" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="6" y="5" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="5" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="13" y="5" width="5" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="7" width="8" height="1" fill="#FFFFFF"></rect>',
      '<rect x="3" y="8" width="3" height="2" fill="#FFFFFF"></rect>',
      '<rect x="7" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="6" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="9" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="9" width="7" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="23" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="9" y="12" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="7" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="16" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="8" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="9" y="21" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>'
    ].join('');

    const CAMERA_ICON_RESUME_CONTENT = [
      '<rect x="17" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="2" width="1" height="5" fill="#FFFFFF"></rect>',
      '<rect x="21" y="2" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="23" y="2" width="1" height="5" fill="#FFFFFF"></rect>',
      '<rect x="20" y="3" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="19" y="4" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="5" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="17" y="6" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="6" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="8" y="7" width="8" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="7" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="3" y="8" width="3" height="2" fill="#FFFFFF"></rect>',
      '<rect x="7" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="6" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="9" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="9" width="7" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="23" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="9" y="12" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="7" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="16" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="8" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="9" y="21" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>'
    ].join('');

    let cameraActionMode = 'resume';

    function setCameraActionIcon(mode) {
      if (!cameraActionIcon) {
        return;
      }
      cameraActionIcon.innerHTML = mode === 'switch' ? CAMERA_ICON_SWITCH_CONTENT : CAMERA_ICON_RESUME_CONTENT;
    }

    function updateCameraActionState() {
      if (!cameraActionBtn) {
        return;
      }
      const allowSwitch = cameraReady && !cameraPermissionDenied;
      cameraActionMode = allowSwitch ? 'switch' : 'resume';

      cameraActionBtn.dataset.mode = cameraActionMode;
      cameraActionBtn.disabled = state.restarting;
      setCameraActionIcon(cameraActionMode);

      if (cameraActionMode === 'switch') {
        const label = state.useFrontCamera ? '背面カメラに切替' : 'フロントカメラに切替';
        setIconButtonLabel(cameraActionBtn, label);
      } else {
        const label = cameraStartLocked ? 'カメラを起動' : '再接続';
        setIconButtonLabel(cameraActionBtn, label);
      }
    }

    updateCameraActionState();

    function refreshOverlayStatus() {
      if (activeOverlay && activeOverlay.hasImage) {
        const overlayIndex = overlays.indexOf(activeOverlay);
        const prefix = overlays.length > 1 ? `ドット絵 ${overlayIndex + 1}/${overlays.length}` : 'ドット絵';
        let detail = ` / x${activeOverlay.scale}`;
        if (isOverlayHueAdjustable(activeOverlay)) {
          detail += ` / 色相 ${formatHueValue(activeOverlay.hue ?? COLOR_CONTROL_DEFAULTS.hue)}`;
          detail += ` / 彩度 ${formatSaturationValue(activeOverlay.saturation ?? COLOR_CONTROL_DEFAULTS.saturation)}`;
        }
        setStatus(`${prefix}: ${activeOverlay.baseWidth}×${activeOverlay.baseHeight}px${detail}`);
      } else if (state.dotMode && dotState.width && dotState.height) {
        const dotCount = dotState.width * dotState.height;
        let depthLabel;
        if (state.colorDepth === 'full') {
          depthLabel = '８BIT（カラー）';
        } else if (state.colorDepth === 'gray') {
          depthLabel = '８BIT（グレー）';
        } else if (state.colorDepth === '4') {
          depthLabel = '2BIT';
        } else if (state.colorDepth === '2') {
          depthLabel = '1BIT';
        } else {
          depthLabel = `${state.colorDepth}色`;
        }
        setStatus(`ドットモード: ${dotState.width}×${dotState.height}px (${dotCount.toLocaleString()} ドット) / x${state.dotScale} / ${depthLabel}`);
      } else if (cameraStatusMessage) {
        setStatus(cameraStatusMessage);
      }
    }

    const ASPECT_RATIOS = {
      '1:1': { width: 1, height: 1 }
    };

    const COLOR_DEPTHS = ['full', 'gray', '4', '2'];
    const BLACK_COLOR = { r: 0, g: 0, b: 0 };
    const WHITE_COLOR = { r: 255, g: 255, b: 255 };
    const GRAY_TINT_DEFAULT_COLOR = { r: 192, g: 192, b: 192 };
    const GRAY_TINT_MIN_SATURATION = 0.22;
    const GRAY_TINT_MIN_LIGHTNESS = 0.04;
    const GRAY_TINT_MAX_LIGHTNESS = 0.9;
    const GRAY_TINT_EDIT_SATURATION = 0.35;
    const GRAY_TINT_EDIT_LIGHTNESS = 0.65;
    const FIXED_FOUR_COLOR_PALETTE = [
      { r: 224, g: 248, b: 208 }, // lightest green
      { r: 168, g: 192, b: 112 }, // light green
      { r: 88, g: 120, b: 48 },   // dark green
      { r: 32, g: 56, b: 16 }     // darkest green
    ];
    const FIXED_TWO_COLOR_PALETTE = [
      { r: 0, g: 0, b: 0 },
      { r: 255, g: 255, b: 255 }
    ];
    const DRAW_IMPORT_STORAGE_KEY = 'pixiee-lens:pending-draw-import';
    const DRAW_IMPORT_STORAGE_VERSION = 1;
    const DRAW_IMPORT_EXPIRY_MS = 1000 * 60 * 5;
    const FOUR_COLOR_DARK_THRESHOLD = 96;

    function updateAspectLayout() {
      if (!aspectOverlay || !aspectCenter || !aspectFrame || !aspectShadeTop || !aspectShadeBottom || !aspectShadeLeft || !aspectShadeRight) {
        return;
      }
      const metrics = getViewportMetrics();
      const viewportWidth = metrics.width;
      const viewportHeight = metrics.height;
      const ratioEntry = ASPECT_RATIOS[state.aspectMode];
      const ratio = typeof ratioEntry === 'function' ? ratioEntry() : ratioEntry;
      if (!ratio) {
        aspectOverlay.hidden = true;
        aspectFrame.style.width = '';
        aspectFrame.style.height = '';
        if (aspectCenter) {
          aspectCenter.style.height = '';
        }
        if (aspectShadeTop) {
          aspectShadeTop.style.height = '0px';
        }
        if (aspectShadeBottom) {
          aspectShadeBottom.style.height = '0px';
        }
        if (aspectShadeLeft) {
          aspectShadeLeft.style.width = '0px';
        }
        if (aspectShadeRight) {
          aspectShadeRight.style.width = '0px';
        }
        updateDotCanvasLayout();
        return;
      }
      aspectOverlay.hidden = false;
      const ratioWidth = Math.max(1, ratio.width);
      const ratioHeight = Math.max(1, ratio.height);
      const scaleBase = Math.min(
        viewportWidth / ratioWidth,
        viewportHeight / ratioHeight
      );
      const scale = Number.isFinite(scaleBase) && scaleBase > 0 ? scaleBase : 1;
      const targetWidth = Math.max(1, Math.round(ratioWidth * scale));
      const targetHeight = Math.max(1, Math.round(ratioHeight * scale));
      const shadeHeight = Math.max(0, (viewportHeight - targetHeight) / 2);
      const shadeWidth = Math.max(0, (viewportWidth - targetWidth) / 2);

      aspectCenter.style.height = `${Math.round(targetHeight)}px`;
      aspectFrame.style.width = `${Math.round(targetWidth)}px`;
      aspectFrame.style.height = `${Math.round(targetHeight)}px`;
      aspectShadeTop.style.height = `${Math.floor(shadeHeight)}px`;
      aspectShadeBottom.style.height = `${Math.ceil(shadeHeight)}px`;
      aspectShadeLeft.style.width = `${Math.floor(shadeWidth)}px`;
      aspectShadeRight.style.width = `${Math.ceil(shadeWidth)}px`;
      updateDotCanvasLayout(targetWidth, targetHeight, shadeWidth, shadeHeight);
    }

    function setAspectMode(mode) {
      if (!Object.prototype.hasOwnProperty.call(ASPECT_RATIOS, mode)) {
        mode = '1:1';
      }
      state.aspectMode = mode;
      aspectButtons.forEach((button) => {
        const isActive = button.dataset.aspect === mode;
      button.classList.toggle('is-active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
    updateAspectLayout();
    closeMenu('aspect');
    if (state.dotMode) {
      ensureDotResolution();
    }
  }

    function getDotResolution() {
      const scaleMap = {
        1: 256,
        2: 128,
        3: 64,
        4: 32,
        5: 16
      };
      const basePixels = scaleMap[state.dotScale] || 64;
      const minPixels = 16;
      return {
        width: Math.max(minPixels, basePixels),
        height: Math.max(minPixels, basePixels)
      };
    }

    function getContainLayout() {
      const metrics = getViewportMetrics();
      const viewportWidth = metrics.width;
      const viewportHeight = metrics.height;
      const sourceWidth = video.videoWidth || viewportWidth;
      const sourceHeight = video.videoHeight || viewportHeight;
      if (!sourceWidth || !sourceHeight) {
        return {
          width: viewportWidth,
          height: viewportHeight,
          offsetX: metrics.offsetLeft,
          offsetY: metrics.offsetTop
        };
      }
      const scale = Math.min(
        viewportWidth / sourceWidth,
        viewportHeight / sourceHeight
      );
      const width = Math.max(1, Math.round(sourceWidth * scale));
      const height = Math.max(1, Math.round(sourceHeight * scale));
      const offsetX = metrics.offsetLeft + Math.round((viewportWidth - width) / 2);
      const offsetY = metrics.offsetTop + Math.round((viewportHeight - height) / 2);
      return { width, height, offsetX, offsetY };
    }

    function getViewportMetrics() {
      const viewportWidth = Math.max(1, Math.round(window.innerWidth || 0));
      const viewportHeight = Math.max(1, Math.round(window.innerHeight || 0));
      if (window.visualViewport) {
        const vv = window.visualViewport;
        return {
          width: Math.max(1, Math.round(vv.width)),
          height: Math.max(1, Math.round(vv.height)),
          offsetLeft: Math.round(vv.offsetLeft || 0),
          offsetTop: Math.round(vv.offsetTop || 0),
          pageWidth: viewportWidth,
          pageHeight: viewportHeight
        };
      }
      return {
        width: viewportWidth,
        height: viewportHeight,
        offsetLeft: 0,
        offsetTop: 0,
        pageWidth: viewportWidth,
        pageHeight: viewportHeight
      };
    }

    function updateDotCanvasLayout(targetWidth, targetHeight, shadeWidth, shadeHeight) {
      if (!dotCanvas) {
        return;
      }
      const metrics = getViewportMetrics();
      let width;
      let height;
      let offsetX;
      let offsetY;

      if (Number.isFinite(targetWidth) && Number.isFinite(targetHeight) && Number.isFinite(shadeWidth) && Number.isFinite(shadeHeight)) {
        width = Math.max(1, Math.round(targetWidth));
        height = Math.max(1, Math.round(targetHeight));
        offsetX = Math.round(shadeWidth) + metrics.offsetLeft;
        offsetY = Math.round(shadeHeight) + metrics.offsetTop;
      } else {
        const contain = getContainLayout();
        width = contain.width;
        height = contain.height;
        offsetX = contain.offsetX;
        offsetY = contain.offsetY;
      }

      dotCanvas.style.width = `${width}px`;
      dotCanvas.style.height = `${height}px`;
      dotCanvas.style.left = `${offsetX}px`;
      dotCanvas.style.top = `${offsetY}px`;
      dotCanvas.style.right = '';
      dotCanvas.style.bottom = '';
      dotState.layout = { width, height, offsetX, offsetY, mode: 'contain' };
      resnapAllOverlaysToDotGrid();
    }

    function applyDotCanvasLayoutFromState() {
      if (!dotCanvas) {
        return;
      }
      const { width, height, offsetX, offsetY } = dotState.layout || {};
      if (!width || !height) {
        const contain = getContainLayout();
        dotCanvas.style.width = `${contain.width}px`;
        dotCanvas.style.height = `${contain.height}px`;
        dotCanvas.style.left = `${contain.offsetX}px`;
        dotCanvas.style.top = `${contain.offsetY}px`;
        dotCanvas.style.right = '';
        dotCanvas.style.bottom = '';
        return;
      }
      dotCanvas.style.width = `${width}px`;
      dotCanvas.style.height = `${height}px`;
      dotCanvas.style.left = `${offsetX}px`;
      dotCanvas.style.top = `${offsetY}px`;
      dotCanvas.style.right = '';
      dotCanvas.style.bottom = '';
    }

    function ensureDotResolution() {
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      const resolution = getDotResolution();
      if (!resolution.width || !resolution.height) {
        return;
      }
      if (resolution.width !== dotState.width || resolution.height !== dotState.height) {
        dotState.width = resolution.width;
        dotState.height = resolution.height;
        dotCanvas.width = resolution.width;
        dotCanvas.height = resolution.height;
      }
      if (state.dotMode) {
        refreshOverlayStatus();
        resnapAllOverlaysToDotGrid();
      }
    }

    function getDotSourceRect() {
      if (!dotCanvas || !dotCanvasCtx) {
        return null;
      }
      const videoWidth = video.videoWidth || 0;
      const videoHeight = video.videoHeight || 0;
      if (!videoWidth || !videoHeight) {
        return null;
      }
      const targetRatio = dotCanvas.width && dotCanvas.height
        ? dotCanvas.width / dotCanvas.height
        : videoWidth / videoHeight;
      if (!Number.isFinite(targetRatio) || targetRatio <= 0) {
        return { sx: 0, sy: 0, sw: videoWidth, sh: videoHeight };
      }
      const videoRatio = videoWidth / videoHeight;
      if (Math.abs(videoRatio - targetRatio) < 0.0001) {
        return { sx: 0, sy: 0, sw: videoWidth, sh: videoHeight };
      }
      if (videoRatio > targetRatio) {
        const targetWidth = videoHeight * targetRatio;
        const sx = Math.round((videoWidth - targetWidth) / 2);
        const sw = Math.round(targetWidth);
        return { sx, sy: 0, sw, sh: videoHeight };
      }
      const targetHeight = videoWidth / targetRatio;
      const sy = Math.round((videoHeight - targetHeight) / 2);
      const sh = Math.round(targetHeight);
      return { sx: 0, sy, sw: videoWidth, sh };
    }

    const COLOR_BIN_SIZE = 16;
    const COLOR_BIN_INTERVAL = 256 / COLOR_BIN_SIZE;
    const PRE_AVERAGE_RADIUS = 0;
    const SATURATION_BOOST = 1.22;
    const CONTRAST_STRENGTH = 1.35;
    const SHADOW_LIFT_THRESHOLD = 82;
    const SHADOW_LIFT_AMOUNT = 10;
    const PALETTE_HOLD_MS = 5000;
    const DOT_SMOOTHING_BLUR = 0.45;

    const paletteState = {
      depth: null,
      desired: 0,
      colors: [],
      originalColors: [],
      cache: new Map(),
      lastUpdated: 0,
      userEdited: false
    };
    let paletteDisplayKey = '';
    let paletteDisplayEnabled = false;
    const paletteEditState = {
      activeIndex: null,
      baseS: 0,
      baseL: 0,
      elements: {
        container: null,
        slider: null,
        value: null,
        preview: null,
        reset: null
      }
    };

    function applyNewPaletteColors(colors) {
      const next = Array.isArray(colors) ? colors.map((color) => ({ ...color })) : [];
      paletteState.colors = next;
      paletteState.originalColors = next.map((color) => ({ ...color }));
      paletteState.cache = new Map();
      paletteState.userEdited = false;
    }

    function getColorBinIndex(value) {
      return Math.max(0, Math.min(COLOR_BIN_SIZE - 1, Math.floor(value / COLOR_BIN_INTERVAL)));
    }

    function binIndexToColorValue(index) {
      const step = 255 / (COLOR_BIN_SIZE - 1);
      return Math.max(0, Math.min(255, Math.round(index * step)));
    }

    function resetPaletteDisplay() {
      if (!paletteDisplay) {
        return;
      }
      paletteDisplay.innerHTML = '';
      paletteDisplay.classList.remove('is-visible');
      paletteDisplay.setAttribute('aria-hidden', 'true');
      paletteDisplayKey = '';
      paletteEditState.activeIndex = null;
      paletteEditState.elements = {
        container: null,
        slider: null,
        value: null,
        preview: null,
        reset: null
      };
    }

    function updatePaletteDisplay(force = false) {
      if (!paletteDisplay) {
        return;
      }
      if (!state.dotMode || state.colorDepth === 'full' || !paletteDisplayEnabled) {
        if (force || paletteDisplayKey) {
          resetPaletteDisplay();
        }
        return;
      }
      const colors = paletteState.colors || [];
      if (!colors.length) {
        if (force || !paletteDisplayKey) {
          paletteDisplay.innerHTML = '<span class="palette-display__label">パレットを計算中…</span>';
          paletteDisplay.classList.add('is-visible');
          paletteDisplay.setAttribute('aria-hidden', 'false');
          paletteDisplayKey = '';
        }
        return;
      }
      const key = colors.map((color) => `${color.r},${color.g},${color.b}`).join('|');
      if (!force && key === paletteDisplayKey) {
        return;
      }
      paletteDisplayKey = key;
      const swatchesHtml = colors.map((color, index) => {
        const rgb = `rgb(${color.r}, ${color.g}, ${color.b})`;
        return `
          <button type="button" class="palette-swatch" data-palette-index="${index}" aria-label="パレット色 ${index + 1}" aria-pressed="false">
            <span class="palette-swatch__chip" style="background:${rgb}"></span>
          </button>
        `;
      }).join('');
      paletteDisplay.innerHTML = `
        <div class="palette-display__swatches" role="list">${swatchesHtml}</div>
        <div class="palette-editor" hidden>
          <div class="palette-editor__header">
            <div class="palette-editor__preview" aria-hidden="true"></div>
            <div class="palette-editor__value" aria-live="polite">0°</div>
          </div>
          <label class="palette-editor__slider">
            <span class="palette-editor__label">色相</span>
            <input type="range" min="0" max="360" step="1" value="0" aria-label="色相を調整">
          </label>
          <button type="button" class="palette-editor__reset">リセット</button>
        </div>
      `;
      paletteDisplay.classList.add('is-visible');
      paletteDisplay.setAttribute('aria-hidden', 'false');
      setupPaletteDisplayInteractions();
    }

    function setPaletteDisplayEnabled(enabled) {
      const canEnable = Boolean(enabled)
        && state.dotMode
        && state.colorDepth !== 'full';
      paletteDisplayEnabled = canEnable;
      if (paletteToggleBtn) {
        paletteToggleBtn.classList.toggle('is-active', canEnable);
        paletteToggleBtn.setAttribute('aria-pressed', canEnable ? 'true' : 'false');
      }
      if (canEnable) {
        updatePaletteDisplay(true);
      } else {
        resetPaletteDisplay();
      }
    }

    function updateActivePaletteSwatch(index) {
      if (!paletteDisplay) {
        return;
      }
      const buttons = paletteDisplay.querySelectorAll('.palette-swatch');
      buttons.forEach((button) => {
        const targetIndex = Number(button.dataset.paletteIndex);
        const isActive = targetIndex === index;
        button.classList.toggle('palette-swatch--active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function setupPaletteDisplayInteractions() {
      if (!paletteDisplay) {
        return;
      }
      const swatches = Array.from(paletteDisplay.querySelectorAll('.palette-swatch'));
      const editor = paletteDisplay.querySelector('.palette-editor');
      const slider = editor ? editor.querySelector('input[type="range"]') : null;
      const valueLabel = editor ? editor.querySelector('.palette-editor__value') : null;
      const preview = editor ? editor.querySelector('.palette-editor__preview') : null;
      const resetButton = editor ? editor.querySelector('.palette-editor__reset') : null;

      paletteEditState.elements = {
        container: editor,
        slider,
        value: valueLabel,
        preview,
        reset: resetButton
      };
      paletteEditState.activeIndex = null;
      if (editor) {
        editor.hidden = true;
      }
      updateActivePaletteSwatch(-1);

      const stopEvent = (event) => event.stopPropagation();
      swatches.forEach((button) => {
        ['pointerdown', 'mousedown', 'touchstart'].forEach((type) => {
          button.addEventListener(type, stopEvent);
        });
        button.addEventListener('click', (event) => {
          stopEvent(event);
          const index = Number(button.dataset.paletteIndex);
          if (Number.isFinite(index)) {
            handlePaletteSwatchSelect(index);
          }
        });
      });

      if (slider) {
        ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
          slider.addEventListener(type, stopEvent);
        });
        slider.addEventListener('input', handlePaletteHueInput);
      }

      if (resetButton) {
        ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
          resetButton.addEventListener(type, stopEvent);
        });
        resetButton.addEventListener('click', handlePaletteHueReset);
      }
    }

    function handlePaletteSwatchSelect(index) {
      if (!paletteState.colors || !paletteState.colors[index]) {
        return;
      }
      const editor = paletteEditState.elements.container;
      if (!editor) {
        return;
      }
      const original = paletteState.originalColors && paletteState.originalColors[index]
        ? paletteState.originalColors[index]
        : paletteState.colors[index];
      const current = paletteState.colors[index];
      const [baseHue, baseS, baseL] = rgbToHsl(original.r, original.g, original.b);
      const [currentHue] = rgbToHsl(current.r, current.g, current.b);
      let editS = baseS;
      let editL = baseL;
      if (state.colorDepth === 'gray') {
        if (paletteState.userEdited) {
          editS = Math.max(baseS, GRAY_TINT_MIN_SATURATION);
          editL = Math.min(Math.max(baseL, GRAY_TINT_EDIT_LIGHTNESS), GRAY_TINT_MAX_LIGHTNESS);
        } else {
          editS = GRAY_TINT_EDIT_SATURATION;
          editL = GRAY_TINT_EDIT_LIGHTNESS;
        }
      }
      paletteEditState.activeIndex = index;
      paletteEditState.baseS = editS;
      paletteEditState.baseL = editL;
      updateActivePaletteSwatch(index);
      editor.hidden = false;

      const slider = paletteEditState.elements.slider;
      const valueLabel = paletteEditState.elements.value;
      const preview = paletteEditState.elements.preview;
      const hueDegrees = Math.round((((currentHue % 1) + 1) % 1) * 360);
      if (slider) {
        slider.value = String(hueDegrees);
      }
      if (valueLabel) {
        valueLabel.textContent = `${hueDegrees}°`;
      }
      if (preview) {
        preview.style.background = `rgb(${current.r}, ${current.g}, ${current.b})`;
      }
    }

    function applyPaletteColorAtIndex(index, newColor) {
      if (!paletteState.colors || !paletteState.colors[index]) {
        return;
      }
      paletteState.colors[index] = { ...newColor };
      paletteState.cache = new Map();
      paletteState.lastUpdated = typeof performance !== 'undefined' ? performance.now() : Date.now();
      const originalColors = paletteState.originalColors || [];
      let isDifferent = originalColors.length !== paletteState.colors.length;
      if (!isDifferent) {
        for (let i = 0; i < paletteState.colors.length; i += 1) {
          const currentColor = paletteState.colors[i];
          const originalColor = originalColors[i];
          if (!originalColor || originalColor.r !== currentColor.r || originalColor.g !== currentColor.g || originalColor.b !== currentColor.b) {
            isDifferent = true;
            break;
          }
        }
      }
      paletteState.userEdited = isDifferent;
      paletteDisplayKey = '';
      const chip = paletteDisplay
        ? paletteDisplay.querySelector(`.palette-swatch[data-palette-index="${index}"] .palette-swatch__chip`)
        : null;
      if (chip) {
        chip.style.background = `rgb(${newColor.r}, ${newColor.g}, ${newColor.b})`;
      }
      if (paletteEditState.elements.preview) {
        paletteEditState.elements.preview.style.background = `rgb(${newColor.r}, ${newColor.g}, ${newColor.b})`;
      }
      if (state.dotMode) {
        refreshOverlayStatus();
      }
    }

    function handlePaletteHueInput(event) {
      if (paletteEditState.activeIndex == null) {
        return;
      }
      if (event) {
        event.stopPropagation();
      }
      const slider = event && event.target ? event.target : paletteEditState.elements.slider;
      if (!slider) {
        return;
      }
      const hueDeg = Number(slider.value) || 0;
      const normalizedDeg = ((hueDeg % 360) + 360) % 360;
      const hueNormalized = normalizedDeg / 360;
      const index = paletteEditState.activeIndex;
      let targetS = paletteEditState.baseS;
      let targetL = paletteEditState.baseL;
      if (state.colorDepth === 'gray') {
        const fallbackS = Number.isFinite(targetS) ? targetS : GRAY_TINT_EDIT_SATURATION;
        const fallbackL = Number.isFinite(targetL) ? targetL : GRAY_TINT_EDIT_LIGHTNESS;
        targetS = Math.max(fallbackS, GRAY_TINT_MIN_SATURATION);
        targetL = Math.min(Math.max(fallbackL, GRAY_TINT_EDIT_LIGHTNESS), GRAY_TINT_MAX_LIGHTNESS);
        paletteEditState.baseS = targetS;
        paletteEditState.baseL = targetL;
      }
      const newColor = hslToRgb(hueNormalized, targetS, targetL);
      applyPaletteColorAtIndex(index, newColor);
      if (paletteEditState.elements.value) {
        paletteEditState.elements.value.textContent = `${Math.round(normalizedDeg)}°`;
      }
    }

    function handlePaletteHueReset(event) {
      if (paletteEditState.activeIndex == null) {
        return;
      }
      if (event) {
        event.stopPropagation();
      }
      const index = paletteEditState.activeIndex;
      const original = paletteState.originalColors && paletteState.originalColors[index]
        ? paletteState.originalColors[index]
        : paletteState.colors[index];
      if (!original) {
        return;
      }
      const [origHue, origS, origL] = rgbToHsl(original.r, original.g, original.b);
      const normalizedDeg = Math.round((((origHue % 1) + 1) % 1) * 360);
      if (paletteEditState.elements.slider) {
        paletteEditState.elements.slider.value = String(normalizedDeg);
      }
      if (paletteEditState.elements.value) {
        paletteEditState.elements.value.textContent = `${normalizedDeg}°`;
      }
      paletteEditState.baseS = origS;
      paletteEditState.baseL = origL;
      applyPaletteColorAtIndex(index, { ...original });
      if (state.colorDepth === 'gray') {
        paletteEditState.baseS = GRAY_TINT_EDIT_SATURATION;
        paletteEditState.baseL = GRAY_TINT_EDIT_LIGHTNESS;
      }
    }
    function updatePaletteToggleAvailability() {
      if (!paletteToggleBtn) {
        return;
      }
      const canShow = state.dotMode
        && state.colorDepth !== 'full';
      paletteToggleBtn.disabled = !canShow;
      if (canShow) {
        paletteToggleBtn.removeAttribute('aria-disabled');
      } else {
        paletteToggleBtn.setAttribute('aria-disabled', 'true');
      }
      if (!canShow && paletteDisplayEnabled) {
        setPaletteDisplayEnabled(false);
      }
    }

    function ensurePaletteColor(palette, target) {
      if (palette.some((entry) => entry.r === target.r && entry.g === target.g && entry.b === target.b)) {
        return;
      }
      const color = { ...target };
      if (typeof color.count !== 'number') {
        color.count = Number.MAX_SAFE_INTEGER;
      }
      palette.push(color);
    }

    function applyPreAverage(imageData) {
      if (PRE_AVERAGE_RADIUS <= 0) {
        return;
      }
      const width = imageData.width || 0;
      const height = imageData.height || 0;
      if (!width || !height) {
        return;
      }
      const radius = Math.floor(PRE_AVERAGE_RADIUS);
      const source = new Uint8ClampedArray(imageData.data);
      const data = imageData.data;
      for (let y = 0; y < height; y += 1) {
        const yMin = Math.max(0, y - radius);
        const yMax = Math.min(height - 1, y + radius);
        for (let x = 0; x < width; x += 1) {
          const xMin = Math.max(0, x - radius);
          const xMax = Math.min(width - 1, x + radius);
          let rSum = 0;
          let gSum = 0;
          let bSum = 0;
          let count = 0;
          for (let yy = yMin; yy <= yMax; yy += 1) {
            const base = yy * width;
            for (let xx = xMin; xx <= xMax; xx += 1) {
              const idx = (base + xx) * 4;
              rSum += source[idx];
              gSum += source[idx + 1];
              bSum += source[idx + 2];
              count += 1;
            }
          }
          const target = (y * width + x) * 4;
          data[target] = Math.round(rSum / count);
          data[target + 1] = Math.round(gSum / count);
          data[target + 2] = Math.round(bSum / count);
        }
      }
    }

    function boostSaturation(imageData) {
      if (SATURATION_BOOST <= 1) {
        return;
      }
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        data[i] = Math.max(0, Math.min(255, Math.round(luminance + (r - luminance) * SATURATION_BOOST)));
        data[i + 1] = Math.max(0, Math.min(255, Math.round(luminance + (g - luminance) * SATURATION_BOOST)));
        data[i + 2] = Math.max(0, Math.min(255, Math.round(luminance + (b - luminance) * SATURATION_BOOST)));
      }
    }

    function adjustChannelContrast(value) {
      if (CONTRAST_STRENGTH <= 1) {
        return value;
      }
      const normalized = value / 255;
      const contrasted = ((normalized - 0.5) * CONTRAST_STRENGTH) + 0.5;
      return Math.max(0, Math.min(255, Math.round(contrasted * 255)));
    }

    function applyContrastToImageData(imageData) {
      if (CONTRAST_STRENGTH <= 1) {
        return;
      }
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = adjustChannelContrast(data[i]);
        data[i + 1] = adjustChannelContrast(data[i + 1]);
        data[i + 2] = adjustChannelContrast(data[i + 2]);
      }
    }

    function liftShadows(imageData) {
      if (SHADOW_LIFT_AMOUNT <= 0) {
        return;
      }
      const threshold = Math.max(1, SHADOW_LIFT_THRESHOLD);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (luminance >= threshold) {
          continue;
        }
        const lift = SHADOW_LIFT_AMOUNT * (1 - luminance / threshold);
        data[i] = Math.max(0, Math.min(255, Math.round(r + lift)));
        data[i + 1] = Math.max(0, Math.min(255, Math.round(g + lift)));
        data[i + 2] = Math.max(0, Math.min(255, Math.round(b + lift)));
      }
    }

    function rgbToHsl(r, g, b) {
      const rn = r / 255;
      const gn = g / 255;
      const bn = b / 255;
      const max = Math.max(rn, gn, bn);
      const min = Math.min(rn, gn, bn);
      const chroma = max - min;
      let hue = 0;
      if (chroma !== 0) {
        if (max === rn) {
          hue = ((gn - bn) / chroma + (gn < bn ? 6 : 0)) / 6;
        } else if (max === gn) {
          hue = ((bn - rn) / chroma + 2) / 6;
        } else {
          hue = ((rn - gn) / chroma + 4) / 6;
        }
      }
      const lightness = (max + min) / 2;
      const saturation = chroma === 0 ? 0 : chroma / (1 - Math.abs(2 * lightness - 1));
      return [hue, saturation, lightness];
    }

    function clampByte(value) {
      return Math.max(0, Math.min(255, Math.round(value)));
    }

    function hslToRgb(h, s, l) {
      let hue = h;
      if (!Number.isFinite(hue)) {
        hue = 0;
      }
      hue = ((hue % 1) + 1) % 1;
      const saturation = Math.max(0, Math.min(1, s));
      const lightness = Math.max(0, Math.min(1, l));
      if (saturation === 0) {
        const value = clampByte(lightness * 255);
        return { r: value, g: value, b: value };
      }
      const q = lightness < 0.5
        ? lightness * (1 + saturation)
        : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      const hueToRgb = (t) => {
        let temp = t;
        if (temp < 0) {
          temp += 1;
        }
        if (temp > 1) {
          temp -= 1;
        }
        if (temp < 1 / 6) {
          return p + (q - p) * 6 * temp;
        }
        if (temp < 1 / 2) {
          return q;
        }
        if (temp < 2 / 3) {
          return p + (q - p) * (2 / 3 - temp) * 6;
        }
        return p;
      };
      const r = hueToRgb(hue + 1 / 3);
      const g = hueToRgb(hue);
      const b = hueToRgb(hue - 1 / 3);
      return {
        r: clampByte(r * 255),
        g: clampByte(g * 255),
        b: clampByte(b * 255)
      };
    }

    function refinePaletteForDepth(palette, depth, desired) {
      return palette;
    }



    function buildPaletteFromImage(imageData, desired, depth) {
      const bins = new Map();
      const data = imageData.data;
      const totalPixels = data.length / 4;
      const minCount = Math.max(1, Math.floor(totalPixels * 0.005));
      for (let i = 0; i < data.length; i += 4) {
        const rIndex = getColorBinIndex(data[i]);
        const gIndex = getColorBinIndex(data[i + 1]);
        const bIndex = getColorBinIndex(data[i + 2]);
        const key = (rIndex << 8) | (gIndex << 4) | bIndex;
        const existing = bins.get(key);
        if (existing) {
          existing.count += 1;
        } else {
          bins.set(key, {
            rIndex,
            gIndex,
            bIndex,
            count: 1
          });
        }
      }
      const sortedBins = Array.from(bins.values()).sort((a, b) => b.count - a.count);
      const palette = [];
      for (const bin of sortedBins) {
        const color = {
          r: binIndexToColorValue(bin.rIndex),
          g: binIndexToColorValue(bin.gIndex),
          b: binIndexToColorValue(bin.bIndex),
          count: bin.count
        };
        if (bin.count < minCount && palette.length >= 2) {
          continue;
        }
        palette.push(color);
        if (palette.length >= desired) {
          break;
        }
      }

      ensurePaletteColor(palette, BLACK_COLOR);
      ensurePaletteColor(palette, WHITE_COLOR);

      palette.sort((a, b) => b.count - a.count);
      while (palette.length > desired) {
        palette.pop();
      }

      const trimmed = palette.map(({ r, g, b }) => ({ r, g, b }));
      const refined = refinePaletteForDepth(trimmed, depth, desired);
      return refined.map(({ r, g, b }) => ({ r, g, b }));
    }

    function shouldRebuildPalette(depth, desired) {
      if (depth !== paletteState.depth || desired !== paletteState.desired) {
        return true;
      }
      if (paletteState.userEdited) {
        return false;
      }
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      return now - paletteState.lastUpdated >= PALETTE_HOLD_MS;
    }

    function applyColorDepth(imageData) {
      const depth = state.colorDepth || '4';
      if (depth === 'full') {
        applyPreAverage(imageData);
        boostSaturation(imageData);
        applyContrastToImageData(imageData);
        liftShadows(imageData);
        paletteState.colors = [];
        paletteState.originalColors = [];
        paletteState.cache = new Map();
        paletteState.depth = null;
        paletteState.desired = 0;
        paletteState.lastUpdated = 0;
        paletteState.userEdited = false;
        resetPaletteDisplay();
        return;
      }
      applyPreAverage(imageData);
      boostSaturation(imageData);
      applyContrastToImageData(imageData);
      liftShadows(imageData);
      const timestamp = typeof performance !== 'undefined' ? performance.now() : Date.now();
      if (depth === '4') {
        const needsUpdate = paletteState.depth !== '4'
          || paletteState.colors.length !== FIXED_FOUR_COLOR_PALETTE.length
          || paletteState.originalColors.length !== FIXED_FOUR_COLOR_PALETTE.length;
        if (needsUpdate) {
          applyNewPaletteColors(FIXED_FOUR_COLOR_PALETTE);
          paletteState.depth = '4';
          paletteState.desired = FIXED_FOUR_COLOR_PALETTE.length;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      } else if (depth === '2') {
        const needsUpdate = paletteState.depth !== '2'
          || paletteState.colors.length !== FIXED_TWO_COLOR_PALETTE.length
          || paletteState.originalColors.length !== FIXED_TWO_COLOR_PALETTE.length;
        if (needsUpdate) {
          applyNewPaletteColors(FIXED_TWO_COLOR_PALETTE);
          paletteState.depth = '2';
          paletteState.desired = FIXED_TWO_COLOR_PALETTE.length;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      } else if (depth === 'gray') {
        const needsInit = paletteState.depth !== 'gray'
          || paletteState.colors.length !== 1;
        if (needsInit) {
          applyNewPaletteColors([GRAY_TINT_DEFAULT_COLOR]);
          paletteState.depth = 'gray';
          paletteState.desired = 1;
          paletteState.lastUpdated = timestamp;
          paletteState.userEdited = false;
          if (paletteDisplayEnabled) {
            updatePaletteDisplay(true);
          }
        } else {
          paletteState.depth = 'gray';
          paletteState.desired = 1;
          paletteState.lastUpdated = timestamp;
        }
        const baseColor = paletteState.colors[0] || GRAY_TINT_DEFAULT_COLOR;
        const [baseHue, baseSaturation, baseLightness] = rgbToHsl(
          baseColor.r,
          baseColor.g,
          baseColor.b
        );
        const tintActive = paletteState.userEdited && baseSaturation > 0.001;
        const dataArr = imageData.data;
        if (!tintActive) {
          for (let i = 0; i < dataArr.length; i += 4) {
            const value = Math.round(
              0.2126 * dataArr[i] +
              0.7152 * dataArr[i + 1] +
              0.0722 * dataArr[i + 2]
            );
            const clamped = Math.max(0, Math.min(255, value));
            dataArr[i] = clamped;
            dataArr[i + 1] = clamped;
            dataArr[i + 2] = clamped;
          }
        } else {
          const minLightness = Math.min(
            GRAY_TINT_MAX_LIGHTNESS * 0.25,
            Math.max(GRAY_TINT_MIN_LIGHTNESS, baseLightness * 0.12)
          );
          const maxLightness = Math.min(
            GRAY_TINT_MAX_LIGHTNESS,
            Math.max(baseLightness, GRAY_TINT_EDIT_LIGHTNESS)
          );
          const tintSaturation = Math.max(baseSaturation, GRAY_TINT_MIN_SATURATION);
          for (let i = 0; i < dataArr.length; i += 4) {
            const luminance = Math.max(
              0,
              Math.min(
                255,
                Math.round(
                  0.2126 * dataArr[i] +
                  0.7152 * dataArr[i + 1] +
                  0.0722 * dataArr[i + 2]
                )
              )
            );
            const normalized = luminance / 255;
            const lightness = minLightness + (maxLightness - minLightness) * normalized;
            const saturation = tintSaturation * (0.25 + 0.75 * normalized);
            const tinted = hslToRgb(baseHue, saturation, lightness);
            dataArr[i] = tinted.r;
            dataArr[i + 1] = tinted.g;
            dataArr[i + 2] = tinted.b;
          }
        }
        return;
      } else {
        const desiredColors = Math.max(2, Number(depth) || 4);
        if (shouldRebuildPalette(depth, desiredColors)) {
          let palette = buildPaletteFromImage(imageData, desiredColors, depth);
          applyNewPaletteColors(palette);
          paletteState.depth = depth;
          paletteState.desired = desiredColors;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      }
      const palette = paletteState.colors;
      if (!palette || !palette.length) {
        return;
      }
      const data = imageData.data;
      const cache = paletteState.cache;

      const findNearestColor = (r, g, b, key) => {
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (depth !== '4' && luminance < 48) {
          cache.set(key, BLACK_COLOR);
          return BLACK_COLOR;
        }
        if (depth !== '4' && luminance > 224) {
          cache.set(key, WHITE_COLOR);
          return WHITE_COLOR;
        }
        if (depth === '4' && luminance < FOUR_COLOR_DARK_THRESHOLD) {
          const darkest = palette[palette.length - 1] || { r: 0, g: 0, b: 0 };
          cache.set(key, darkest);
          return darkest;
        }
        let cached = cache.get(key);
        if (cached) {
          return cached;
        }
        let bestIndex = 0;
        let bestDistance = Number.POSITIVE_INFINITY;
        for (let i = 0; i < palette.length; i += 1) {
          const color = palette[i];
          const dr = r - color.r;
          const dg = g - color.g;
          const db = b - color.b;
          const dist = dr * dr + dg * dg + db * db;
          if (dist < bestDistance) {
            bestDistance = dist;
            bestIndex = i;
          }
        }
        cached = palette[bestIndex];
        cache.set(key, cached);
        return cached;
      };

      for (let i = 0; i < data.length; i += 4) {
        const rIndex = getColorBinIndex(data[i]);
        const gIndex = getColorBinIndex(data[i + 1]);
        const bIndex = getColorBinIndex(data[i + 2]);
        const key = (rIndex << 8) | (gIndex << 4) | bIndex;
        const nearest = findNearestColor(data[i], data[i + 1], data[i + 2], key);
        data[i] = nearest.r;
        data[i + 1] = nearest.g;
        data[i + 2] = nearest.b;
      }
    }

    function buildSimplifiedPalette(imageData, maxColors = COLOR_SIMPLIFY_MAX_COLORS, bucket = COLOR_SIMPLIFY_BUCKET) {
      if (!imageData || !imageData.data || !imageData.data.length) {
        return [];
      }
      const data = imageData.data;
      const freq = new Map();
      const step = Math.max(1, Number.isFinite(bucket) ? bucket : 16);
      for (let i = 0; i < data.length; i += 4) {
        const r = Math.min(255, Math.max(0, Math.round(data[i] / step) * step));
        const g = Math.min(255, Math.max(0, Math.round(data[i + 1] / step) * step));
        const b = Math.min(255, Math.max(0, Math.round(data[i + 2] / step) * step));
        const key = `${r},${g},${b}`;
        freq.set(key, (freq.get(key) || 0) + 1);
      }
      const sorted = Array.from(freq.entries())
        .map(([key, count]) => {
          const [r, g, b] = key.split(',').map((v) => Number(v));
          return { r, g, b, count };
        })
        .sort((a, b) => b.count - a.count);
      return sorted.slice(0, Math.max(1, Math.round(maxColors || 8))).map(({ r, g, b }) => ({ r, g, b }));
    }

    function applyPaletteToImage(imageData, palette) {
      if (!imageData || !imageData.data || !palette || !palette.length) {
        return false;
      }
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        let bestIndex = 0;
        let bestDist = Number.POSITIVE_INFINITY;
        for (let j = 0; j < palette.length; j += 1) {
          const color = palette[j];
          const dr = data[i] - color.r;
          const dg = data[i + 1] - color.g;
          const db = data[i + 2] - color.b;
          const dist = dr * dr + dg * dg + db * db;
          if (dist < bestDist) {
            bestDist = dist;
            bestIndex = j;
          }
        }
        const chosen = palette[bestIndex];
        data[i] = chosen.r;
        data[i + 1] = chosen.g;
        data[i + 2] = chosen.b;
      }
      return true;
    }

    function simplifyCanvasColors(canvas) {
      if (!canvas || !canvas.getContext) {
        return false;
      }
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      if (!ctx) {
        return false;
      }
      let imageData;
      try {
        imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      } catch (error) {
        return false;
      }
      const palette = buildSimplifiedPalette(imageData);
      if (!palette.length) {
        return false;
      }
      const applied = applyPaletteToImage(imageData, palette);
      if (!applied) {
        return false;
      }
      ctx.putImageData(imageData, 0, 0);
      return true;
    }

    function updateDotModeUI() {
      if (dotModeBtn) {
        dotModeBtn.classList.add('is-active');
        dotModeBtn.setAttribute('aria-pressed', 'true');
        setIconButtonLabel(dotModeBtn, 'ドット設定を開く');
      }
      setDotSettingsOpen(dotScalePanelOpen && state.dotMode);
      if (dotScaleSelect) {
        const value = String(state.dotScale);
        if (dotScaleSelect.value !== value) {
          dotScaleSelect.value = value;
        }
      }
      if (colorDepthSelect) {
        const depthValue = state.colorDepth;
        if (colorDepthSelect.value !== depthValue) {
          colorDepthSelect.value = depthValue;
        }
      }
      updatePaletteToggleAvailability();
      if (paletteDisplayEnabled) {
        updatePaletteDisplay(true);
      } else {
        resetPaletteDisplay();
      }
    }

    function renderDotFrame() {
      if (!state.dotMode || !dotCanvas || !dotCanvasCtx) {
        dotState.frameHandle = null;
        return;
      }
      ensureDotResolution();
      const crop = getDotSourceRect();
      if (video.readyState >= 2 && crop) {
        const targetWidth = dotCanvas.width;
        const targetHeight = dotCanvas.height;
        if (!targetWidth || !targetHeight) {
          dotState.frameHandle = requestAnimationFrame(renderDotFrame);
          return;
        }
        if (smoothingCanvas && smoothingCtx) {
          if (smoothingCanvas.width !== targetWidth || smoothingCanvas.height !== targetHeight) {
            smoothingCanvas.width = targetWidth;
            smoothingCanvas.height = targetHeight;
          }
          smoothingCtx.save();
          smoothingCtx.imageSmoothingEnabled = true;
          smoothingCtx.imageSmoothingQuality = 'high';
          const smoothingFilter = currentCameraFilterString
            ? `blur(${DOT_SMOOTHING_BLUR}px) ${currentCameraFilterString}`
            : `blur(${DOT_SMOOTHING_BLUR}px)`;
          smoothingCtx.filter = smoothingFilter;
          smoothingCtx.clearRect(0, 0, targetWidth, targetHeight);
          smoothingCtx.drawImage(
            video,
            crop.sx,
            crop.sy,
            crop.sw,
            crop.sh,
            0,
            0,
            targetWidth,
            targetHeight
          );
          smoothingCtx.restore();
          const imageData = smoothingCtx.getImageData(0, 0, targetWidth, targetHeight);
          applyColorDepth(imageData);
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          dotCanvasCtx.putImageData(imageData, 0, 0);
        } else {
          dotCanvasCtx.save();
          dotCanvasCtx.imageSmoothingEnabled = false;
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          dotCanvasCtx.drawImage(
            video,
            crop.sx,
            crop.sy,
            crop.sw,
            crop.sh,
            0,
            0,
            targetWidth,
            targetHeight
          );
          const imageData = dotCanvasCtx.getImageData(0, 0, targetWidth, targetHeight);
          applyColorDepth(imageData);
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          dotCanvasCtx.putImageData(imageData, 0, 0);
          dotCanvasCtx.restore();
        }
      }
      dotState.frameHandle = requestAnimationFrame(renderDotFrame);
    }

    function startDotRendering() {
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      dotCanvas.hidden = false;
      applyDotCanvasLayoutFromState();
      ensureDotResolution();
      resnapAllOverlaysToDotGrid();
      if (dotState.frameHandle == null) {
        dotState.frameHandle = requestAnimationFrame(renderDotFrame);
      }
    }

    function stopDotRendering() {
      if (dotState.frameHandle != null) {
        cancelAnimationFrame(dotState.frameHandle);
        dotState.frameHandle = null;
      }
      if (dotCanvas) {
        dotCanvas.hidden = true;
      }
    }

    function setDotMode(enabled = true) {
      if (!enabled) {
        return;
      }
      state.dotMode = true;
      updateDotModeUI();
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      startDotRendering();
      resnapAllOverlaysToDotGrid();
      refreshOverlayStatus();
      updatePaletteDisplay(true);
    }

    function getDotGridInfo() {
      if (!state.dotMode || !dotCanvas || !pixelPreview) {
        return null;
      }
      const gridWidth = Number.isFinite(dotState.width) ? dotState.width : 0;
      const gridHeight = Number.isFinite(dotState.height) ? dotState.height : 0;
      if (!gridWidth || !gridHeight) {
        return null;
      }
      const dotRect = dotCanvas.getBoundingClientRect();
      const previewRect = pixelPreview.getBoundingClientRect();
      const layoutWidth = dotRect.width;
      const layoutHeight = dotRect.height;
      const offsetX = dotRect.left - previewRect.left;
      const offsetY = dotRect.top - previewRect.top;
      if (!Number.isFinite(layoutWidth) || !Number.isFinite(layoutHeight) || layoutWidth <= 0 || layoutHeight <= 0) {
        return null;
      }
      const cellWidth = layoutWidth / gridWidth;
      const cellHeight = layoutHeight / gridHeight;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
        return null;
      }
      const cellSize = Math.min(cellWidth, cellHeight);
      return {
        offsetX,
        offsetY,
        cellWidth,
        cellHeight,
        cellSize
      };
    }

    function snapOverlayScale(overlay, scale, constraints = {}) {
      if (!overlay || !overlay.baseWidth || !overlay.baseHeight) {
        return {
          scale: Math.round(Number.isFinite(scale) ? scale : 1),
          snapped: false
        };
      }
      const grid = getDotGridInfo();
      const fallbackScale = Math.round(Number.isFinite(scale) ? scale : overlay.scale || 1);
      if (!grid) {
        return {
          scale: fallbackScale,
          snapped: false
        };
      }
      const { cellWidth, cellHeight, cellSize } = grid;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || !Number.isFinite(cellSize) || cellWidth <= 0 || cellHeight <= 0 || cellSize <= 0) {
        return {
          scale: fallbackScale,
          snapped: false
        };
      }
      const { maxScale: maxConstraint, minScale: minConstraint } = constraints || {};
      const EPSILON = 1e-6;
      const targetScale = Number.isFinite(scale) && scale > 0 ? scale : overlay.scale || cellSize;
      const lowerBound = Number.isFinite(minConstraint)
        ? Math.max(minConstraint, cellSize)
        : cellSize;
      let upperBound = Number.isFinite(maxConstraint)
        ? Math.max(lowerBound, maxConstraint)
        : Number.POSITIVE_INFINITY;
      if (upperBound < cellSize - EPSILON && Number.isFinite(maxConstraint)) {
        return {
          scale: Math.max(overlay.minScale, Math.min(maxConstraint, fallbackScale)),
          snapped: false
        };
      }
      const clampedTarget = Math.max(lowerBound, Math.min(upperBound, targetScale));
      let multiplier = Math.max(1, Math.round(clampedTarget / cellSize));
      let snappedScale = multiplier * cellSize;
      if (Number.isFinite(upperBound) && snappedScale > upperBound + EPSILON) {
        multiplier = Math.max(1, Math.floor(upperBound / cellSize));
        snappedScale = multiplier * cellSize;
      }
      if (!Number.isFinite(snappedScale) || snappedScale <= 0) {
        snappedScale = lowerBound;
      }
      snappedScale = Math.max(lowerBound, Math.min(upperBound, snappedScale));
      return {
        scale: snappedScale,
        snapped: true
      };
    }

    function snapOverlayPosition(overlay, x, y) {
      const targetX = Number.isFinite(x) ? x : overlay.offsetX || 0;
      const targetY = Number.isFinite(y) ? y : overlay.offsetY || 0;
      const grid = getDotGridInfo();
      if (!grid) {
        return {
          x: Math.round(targetX),
          y: Math.round(targetY),
          snapped: false
        };
      }
      const { offsetX, offsetY, cellWidth, cellHeight } = grid;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
        return {
          x: Math.round(targetX),
          y: Math.round(targetY),
          snapped: false
        };
      }
      const relativeX = targetX - offsetX;
      const relativeY = targetY - offsetY;
      const snappedX = offsetX + Math.round(relativeX / cellWidth) * cellWidth;
      const snappedY = offsetY + Math.round(relativeY / cellHeight) * cellHeight;
      return {
        x: Number.isFinite(snappedX) ? snappedX : Math.round(targetX),
        y: Number.isFinite(snappedY) ? snappedY : Math.round(targetY),
        snapped: true
      };
    }

    function getViewportScaleLimit(width, height) {
      if (!width || !height) {
        return 64;
      }
      const widthLimit = Math.max(1, Math.floor((window.innerWidth * 0.9) / width));
      const heightLimit = Math.max(1, Math.floor((window.innerHeight * 0.85) / height));
      return Math.max(1, Math.min(widthLimit, heightLimit));
    }

    function getAnchorPoint(handle, rect) {
      switch (handle) {
        case 'nw':
          return { x: rect.right, y: rect.bottom };
        case 'ne':
          return { x: rect.left, y: rect.bottom };
        case 'sw':
          return { x: rect.right, y: rect.top };
        case 'se':
        default:
          return { x: rect.left, y: rect.top };
      }
    }

    function attachGlobalInteractionListeners() {
      if (interactionState.listenersAttached) {
        return;
      }
      window.addEventListener('pointermove', handleWindowPointerMove, { passive: false });
      window.addEventListener('pointerup', handleWindowPointerUp);
      window.addEventListener('pointercancel', handleWindowPointerUp);
      interactionState.listenersAttached = true;
    }

    function detachGlobalInteractionListeners() {
      if (!interactionState.listenersAttached) {
        return;
      }
      if (interactionState.dragOverlay || interactionState.resizeOverlay) {
        return;
      }
      window.removeEventListener('pointermove', handleWindowPointerMove);
      window.removeEventListener('pointerup', handleWindowPointerUp);
      window.removeEventListener('pointercancel', handleWindowPointerUp);
      interactionState.listenersAttached = false;
    }

    function handleWindowPointerMove(event) {
      if (interactionState.resizeOverlay) {
        if (handleOverlayResizeMove(interactionState.resizeOverlay, event)) {
          return;
        }
      }
      if (interactionState.dragOverlay) {
        handleOverlayDragMove(interactionState.dragOverlay, event);
      }
    }

    function handleWindowPointerUp(event) {
      if (interactionState.resizeOverlay) {
        finishOverlayResize(interactionState.resizeOverlay, event);
      }
      if (interactionState.dragOverlay) {
        finishOverlayDrag(interactionState.dragOverlay, event);
      }
    }

    function createOverlayElements() {
      const wrap = document.createElement('div');
      wrap.className = 'pixel-canvas-wrap';
      wrap.style.left = '24px';
      wrap.style.top = '24px';
      wrap.style.isolation = 'isolate';

      const moveHandle = document.createElement('button');
      moveHandle.type = 'button';
      moveHandle.className = 'pixel-move-handle';
      moveHandle.setAttribute('aria-label', 'ドット絵を移動');
      wrap.appendChild(moveHandle);

      const image = document.createElement('img');
      image.className = 'pixel-canvas';
      image.alt = '';
      wrap.appendChild(image);

      const tint = document.createElement('canvas');
      tint.className = 'pixel-canvas pixel-canvas--tint';
      tint.hidden = true;
      tint.style.opacity = '0';
      wrap.appendChild(tint);

      const labelMap = {
        nw: '左上ハンドル',
        ne: '右上ハンドル',
        se: '右下ハンドル',
        sw: '左下ハンドル'
      };

      const handles = ['nw', 'ne', 'se', 'sw'].map((dir) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `pixel-handle pixel-handle--${dir}`;
        button.dataset.handle = dir;
        button.setAttribute('aria-label', labelMap[dir] || 'ハンドル');
        wrap.appendChild(button);
        return button;
      });

      return { wrap, moveHandle, image, tint, handles };
    }

    function updateOverlayStacking() {
      overlays.forEach((item, index) => {
        item.elements.wrap.style.zIndex = String(100 + index);
        pixelPreview.appendChild(item.elements.wrap);
      });
    }

    function promoteOverlay(overlay) {
      const currentIndex = overlays.indexOf(overlay);
      if (currentIndex === -1) {
        return;
      }
      if (currentIndex !== overlays.length - 1) {
        overlays.splice(currentIndex, 1);
        overlays.push(overlay);
      }
      updateOverlayStacking();
    }

    function setActiveOverlay(overlay) {
      if (overlay) {
        promoteOverlay(overlay);
      } else {
        updateOverlayStacking();
      }
      activeOverlay = overlay || null;
      overlays.forEach((item, index) => {
        const isActive = item === activeOverlay;
        item.elements.wrap.classList.toggle('is-active', isActive);
        if (isActive) {
          item.elements.wrap.style.zIndex = String(200 + index);
        } else {
          item.elements.wrap.style.zIndex = String(100 + index);
        }
      });
      const hasOverlays = overlays.length > 0;
      pixelPreview.hidden = !hasOverlays;
      clearPixelBtn.classList.toggle('is-visible', hasOverlays);
      clearPixelBtn.setAttribute('aria-hidden', hasOverlays ? 'false' : 'true');
      clearPixelBtn.disabled = !hasOverlays;
      updateZoomControlMode(activeOverlay);
      refreshOverlayStatus();
    }

    function clampHueValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return 0;
      }
      const normalized = ((numeric % 360) + 360) % 360;
      return Math.round(normalized);
    }

    function formatHueValue(value) {
      return `${clampHueValue(value)}°`;
    }

    function isOverlayHueAdjustable(overlay) {
      return Boolean(overlay && overlay.hueAdjustable);
    }

    function clampSaturationValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return SATURATION_CONTROL_RANGE.min;
      }
      const clamped = Math.min(SATURATION_CONTROL_RANGE.max, Math.max(SATURATION_CONTROL_RANGE.min, Math.round(numeric)));
      return clamped;
    }

    function formatSaturationValue(value) {
      return `${clampSaturationValue(value)}%`;
    }

    function ensureOverlayTintResources(overlay) {
      if (!overlay || !overlay.hueAdjustable || !overlay.elements) {
        return null;
      }
      const tintCanvas = overlay.elements.tint;
      if (!tintCanvas || !overlay.baseWidth || !overlay.baseHeight) {
        return null;
      }
      const ctx = overlay.tintCtx || tintCanvas.getContext('2d');
      if (!ctx) {
        return null;
      }
      if (tintCanvas.width !== overlay.baseWidth || tintCanvas.height !== overlay.baseHeight) {
        tintCanvas.width = overlay.baseWidth;
        tintCanvas.height = overlay.baseHeight;
      }
      overlay.tintCtx = ctx;
      return ctx;
    }

    function renderOverlayTint(overlay) {
      if (!overlay || !overlay.hueAdjustable || !overlay.elements) {
        return;
      }
      const tintCanvas = overlay.elements.tint;
      const imageElement = overlay.elements.image;
      const params = overlay.tintParams;
      if (!tintCanvas || !imageElement || !params || params.ratio <= 0.001) {
        if (tintCanvas) {
          tintCanvas.hidden = true;
          tintCanvas.style.opacity = '0';
        }
        return;
      }
      const ctx = ensureOverlayTintResources(overlay);
      if (!ctx) {
        tintCanvas.hidden = true;
        tintCanvas.style.opacity = '0';
        return;
      }
      const { hue, saturation } = params;
      const width = overlay.baseWidth;
      const height = overlay.baseHeight;
      const saturationNormalized = Math.min(1, Math.max(0, saturation / SATURATION_CONTROL_RANGE.max));
      const fillSaturation = Math.max(5, Math.round(saturationNormalized * 100));
      const fillLightness = Math.round(48 + (1 - saturationNormalized) * 20);
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0, 0, width, height);
      ctx.save();
      const alphaFactor = Math.max(0.08, saturationNormalized);
      ctx.globalAlpha = alphaFactor;
      ctx.fillStyle = `hsl(${hue}deg ${fillSaturation}% ${fillLightness}%)`;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(imageElement, 0, 0, width, height);
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 1;
      ctx.drawImage(imageElement, 0, 0, width, height);
      ctx.globalCompositeOperation = 'source-over';
      tintCanvas.hidden = false;
      tintCanvas.style.opacity = '1';
      if (typeof window !== 'undefined' && window.PIXIEE_DEBUG_TINT) {
        try {
          console.debug('PiXiEE tint preview:', tintCanvas.toDataURL('image/png'));
        } catch (error) {
          console.debug('PiXiEE tint preview failed:', error);
        }
      }
    }

    function applyOverlayColorTransform(overlay, { hue = null, saturation = null } = {}) {
      if (!overlay || !overlay.elements || !overlay.elements.wrap) {
        return;
      }
      const { image, tint } = overlay.elements;
      if (!isOverlayHueAdjustable(overlay)) {
        overlay.hue = COLOR_CONTROL_DEFAULTS.hue;
        overlay.saturation = COLOR_CONTROL_DEFAULTS.saturation;
        if (image) {
          image.classList.remove('pixel-canvas--colorized');
          image.style.mixBlendMode = '';
          image.style.filter = '';
        }
      if (tint) {
        tint.hidden = true;
        tint.style.backgroundColor = 'transparent';
        tint.style.opacity = '0';
        tint.style.maskImage = '';
        tint.style.webkitMaskImage = '';
        tint.style.maskRepeat = '';
        tint.style.webkitMaskRepeat = '';
        tint.style.maskPosition = '';
        tint.style.webkitMaskPosition = '';
        tint.style.maskSize = '';
        tint.style.webkitMaskSize = '';
        tint.style.maskMode = '';
        tint.style.webkitMaskMode = '';
      }
      overlay.tintParams = null;
      overlay.tintUpdateScheduled = false;
      overlay.elements.wrap.removeAttribute('data-hue');
      overlay.elements.wrap.removeAttribute('data-saturation');
      return;
    }
      if (hue != null) {
        overlay.hue = clampHueValue(hue);
      } else {
        overlay.hue = clampHueValue(overlay.hue);
      }
      if (saturation != null) {
        overlay.saturation = clampSaturationValue(saturation);
      } else {
        overlay.saturation = clampSaturationValue(overlay.saturation);
      }
      const hueValue = overlay.hue;
      const saturationValue = overlay.saturation;
      const ratio = Math.min(1, Math.max(0, (saturationValue - SATURATION_CONTROL_RANGE.min) /
        Math.max(1, SATURATION_CONTROL_RANGE.max - SATURATION_CONTROL_RANGE.min)));
      if (tint && ratio <= 0.001) {
        tint.hidden = true;
        tint.style.opacity = '0';
        overlay.tintParams = null;
        overlay.tintUpdateScheduled = false;
        if (overlay.tintCtx) {
          overlay.tintCtx.clearRect(0, 0, overlay.baseWidth || 0, overlay.baseHeight || 0);
        }
        if (overlay.elements && overlay.elements.wrap) {
          overlay.elements.wrap.dataset.hue = String(hueValue);
          overlay.elements.wrap.dataset.saturation = String(saturationValue);
        }
        return;
      }
      if (overlay.hueAdjustable) {
        ensureOverlayTintResources(overlay);
      }
      if (image) {
        image.classList.add('pixel-canvas--colorized');
        image.style.mixBlendMode = '';
        image.style.filter = '';
      }
      overlay.elements.wrap.dataset.hue = String(hueValue);
      overlay.elements.wrap.dataset.saturation = String(saturationValue);
      overlay.tintParams = { hue: hueValue, saturation: saturationValue, ratio };
      if (!overlay.tintUpdateScheduled) {
        overlay.tintUpdateScheduled = true;
        requestAnimationFrame(() => {
          overlay.tintUpdateScheduled = false;
          renderOverlayTint(overlay);
        });
      }
    }

    function getHueFromSliderValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return HUE_CONTROL_RANGE.min;
      }
      return clampHueValue(numeric);
    }

    function getSliderValueFromHue(hue) {
      return clampHueValue(hue);
    }

    function getSaturationFromSliderValue(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        return SATURATION_CONTROL_RANGE.min;
      }
      return clampSaturationValue(numeric);
    }

    function getSliderValueFromSaturation(saturation) {
      return clampSaturationValue(saturation);
    }

    function syncColorControls(overlay) {
      if (!colorControl || !hueSlider || !hueValueDisplay || !saturationSlider || !saturationValueDisplay) {
        return;
      }
      hueSlider.min = String(HUE_CONTROL_RANGE.min);
      hueSlider.max = String(HUE_CONTROL_RANGE.max);
      hueSlider.step = String(Math.max(1, HUE_CONTROL_RANGE.step || 1));
      saturationSlider.min = String(SATURATION_CONTROL_RANGE.min);
      saturationSlider.max = String(SATURATION_CONTROL_RANGE.max);
      saturationSlider.step = String(Math.max(1, SATURATION_CONTROL_RANGE.step || 1));
      const enabled = overlay && isOverlayHueAdjustable(overlay);
      colorControl.hidden = !enabled;
      if (!enabled) {
        const fallbackHue = clampHueValue(COLOR_CONTROL_DEFAULTS.hue);
        const fallbackSat = clampSaturationValue(COLOR_CONTROL_DEFAULTS.saturation);
        hueSlider.value = String(fallbackHue);
        hueSlider.setAttribute('aria-valuenow', String(fallbackHue));
        hueSlider.setAttribute('aria-valuetext', formatHueValue(fallbackHue));
        hueSlider.disabled = true;
        hueSlider.setAttribute('aria-disabled', 'true');
        hueValueDisplay.textContent = formatHueValue(fallbackHue);
        saturationSlider.value = String(fallbackSat);
        saturationSlider.setAttribute('aria-valuenow', String(fallbackSat));
        saturationSlider.setAttribute('aria-valuetext', formatSaturationValue(fallbackSat));
        saturationSlider.disabled = true;
        saturationSlider.setAttribute('aria-disabled', 'true');
        saturationValueDisplay.textContent = formatSaturationValue(fallbackSat);
        return;
      }
      const hueValue = clampHueValue(overlay.hue ?? HUE_CONTROL_RANGE.min);
      const sliderValue = getSliderValueFromHue(hueValue);
      const saturationValue = clampSaturationValue(overlay.saturation ?? COLOR_CONTROL_DEFAULTS.saturation);
      const saturationSliderValue = getSliderValueFromSaturation(saturationValue);
      hueSlider.disabled = false;
      hueSlider.removeAttribute('aria-disabled');
      hueSlider.value = String(sliderValue);
      hueSlider.setAttribute('aria-valuenow', String(sliderValue));
      hueSlider.setAttribute('aria-valuetext', formatHueValue(hueValue));
      hueValueDisplay.textContent = formatHueValue(hueValue);
      saturationSlider.disabled = false;
      saturationSlider.removeAttribute('aria-disabled');
      saturationSlider.value = String(saturationSliderValue);
      saturationSlider.setAttribute('aria-valuenow', String(saturationSliderValue));
      saturationSlider.setAttribute('aria-valuetext', formatSaturationValue(saturationValue));
      saturationValueDisplay.textContent = formatSaturationValue(saturationValue);
    }

    function syncZoomSliderFromCamera() {
      if (!zoomSlider) {
        return;
      }
      const value = state.cameraSettings.zoom ?? 0;
      zoomSlider.value = String(value);
      zoomSlider.setAttribute('aria-valuenow', String(value));
      zoomSlider.setAttribute('aria-valuetext', formatCameraSettingValue(value, 'zoom'));
      zoomSlider.setAttribute('aria-label', 'ズーム倍率');
      refreshZoomMeterVisuals(value);
    }

    function updateZoomControlMode(overlay) {
      const colorizableOverlay = overlay && isOverlayHueAdjustable(overlay) ? overlay : null;
      const desiredMode = colorizableOverlay ? 'color' : 'zoom';
      if (zoomControlMode === desiredMode && (desiredMode !== 'color' || (colorizableOverlay && colorControlOverlayId === colorizableOverlay.id))) {
        if (desiredMode === 'color') {
          syncColorControls(colorizableOverlay);
        } else {
          syncZoomSliderFromCamera();
        }
        return;
      }
      zoomControlMode = desiredMode;
      if (desiredMode === 'color') {
        colorControlOverlayId = colorizableOverlay ? colorizableOverlay.id : null;
        if (zoomControl) {
          zoomControl.classList.add('is-color-mode');
          zoomControl.hidden = false;
          zoomControl.setAttribute('aria-hidden', 'false');
          zoomControl.classList.remove('is-collapsed');
          zoomControl.classList.add('is-expanded');
        }
        if (zoomSlider) {
          zoomSlider.disabled = true;
          zoomSlider.setAttribute('aria-disabled', 'true');
        }
        syncColorControls(colorizableOverlay);
      } else {
        colorControlOverlayId = null;
        if (zoomControl) {
          zoomControl.classList.remove('is-color-mode');
        }
        if (colorControl) {
          colorControl.hidden = true;
        }
        const zoomAvailable = cameraZoomCapabilityKnown && Boolean(cameraZoomCapability);
        if (zoomSlider) {
          zoomSlider.disabled = !zoomAvailable;
          if (zoomAvailable) {
            zoomSlider.removeAttribute('aria-disabled');
          } else {
            zoomSlider.setAttribute('aria-disabled', 'true');
          }
        }
        syncZoomSliderFromCamera();
        if (zoomAvailable) {
          updateZoomScaleOptions();
        }
      }
      syncColorControls(colorizableOverlay);
      updateZoomSliderAvailability();
    }

    function handleHueSliderInput(rawValue) {
      const overlay = activeOverlay && isOverlayHueAdjustable(activeOverlay) ? activeOverlay : null;
      if (!overlay) {
        return;
      }
      const hueValue = getHueFromSliderValue(rawValue);
      applyOverlayColorTransform(overlay, { hue: hueValue });
      syncColorControls(overlay);
      refreshOverlayStatus();
    }

    function handleSaturationSliderInput(rawValue) {
      const overlay = activeOverlay && isOverlayHueAdjustable(activeOverlay) ? activeOverlay : null;
      if (!overlay) {
        return;
      }
      const saturationValue = getSaturationFromSliderValue(rawValue);
      applyOverlayColorTransform(overlay, { saturation: saturationValue });
      syncColorControls(overlay);
      refreshOverlayStatus();
    }

    function applyOverlayScale(overlay) {
      if (!overlay.hasImage) {
        return;
      }
      const displayWidth = overlay.baseWidth * overlay.scale;
      const displayHeight = overlay.baseHeight * overlay.scale;
      const grid = getDotGridInfo();
      let appliedWidth = displayWidth;
      let appliedHeight = displayHeight;
      let appliedX = overlay.offsetX;
      let appliedY = overlay.offsetY;
      const EPSILON = 1e-6;
      if (grid && Number.isFinite(grid.cellWidth) && Number.isFinite(grid.cellHeight) && grid.cellWidth > EPSILON && grid.cellHeight > EPSILON) {
        appliedWidth = Math.max(grid.cellWidth, Math.round(displayWidth / grid.cellWidth) * grid.cellWidth);
        appliedHeight = Math.max(grid.cellHeight, Math.round(displayHeight / grid.cellHeight) * grid.cellHeight);
        const relativeX = overlay.offsetX - grid.offsetX;
        const relativeY = overlay.offsetY - grid.offsetY;
        appliedX = grid.offsetX + Math.round(relativeX / grid.cellWidth) * grid.cellWidth;
        appliedY = grid.offsetY + Math.round(relativeY / grid.cellHeight) * grid.cellHeight;
      }
      overlay.elements.image.style.width = `${appliedWidth}px`;
      overlay.elements.image.style.height = `${appliedHeight}px`;
      if (overlay.elements.tint) {
        overlay.elements.tint.style.width = `${appliedWidth}px`;
        overlay.elements.tint.style.height = `${appliedHeight}px`;
      }
      overlay.elements.wrap.style.width = `${appliedWidth}px`;
      overlay.elements.wrap.style.height = `${appliedHeight}px`;
      overlay.elements.wrap.style.left = `${appliedX}px`;
      overlay.elements.wrap.style.top = `${appliedY}px`;
      overlay.offsetX = appliedX;
      overlay.offsetY = appliedY;
    }

    function setOverlayScale(overlay, scale) {
      if (!overlay.hasImage) {
        return;
      }
      const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
      const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
      const limited = Math.max(overlay.minScale, Math.min(maxScale, Number.isFinite(scale) ? scale : overlay.scale || overlay.minScale));
      const snappedScale = snapOverlayScale(overlay, limited, { maxScale, minScale: overlay.minScale });
      let desiredScale = snappedScale.scale;
      if (!snappedScale.snapped) {
        desiredScale = Math.round(desiredScale);
      }
      let clamped = Math.max(overlay.minScale, Math.min(maxScale, desiredScale));
      if (!Number.isFinite(clamped) || clamped <= 0) {
        clamped = overlay.minScale;
      }
      if (clamped !== overlay.scale) {
        overlay.scale = clamped;
      }
      const snappedPosition = snapOverlayPosition(overlay, overlay.offsetX, overlay.offsetY);
      const finalX = Number.isFinite(snappedPosition.x) ? snappedPosition.x : overlay.offsetX;
      const finalY = Number.isFinite(snappedPosition.y) ? snappedPosition.y : overlay.offsetY;
      overlay.offsetX = finalX;
      overlay.offsetY = finalY;
      applyOverlayScale(overlay);
      if (overlay === activeOverlay) {
        refreshOverlayStatus();
      }
    }

    function resnapAllOverlaysToDotGrid() {
      if (!state.dotMode || !dotState.width || !dotState.height) {
        return;
      }
      overlays.forEach((overlay) => {
        if (!overlay.hasImage) {
          return;
        }
        setOverlayScale(overlay, overlay.scale);
      });
    }

    function startOverlayDrag(overlay, event, captureTarget) {
      if (!overlay.hasImage || overlay.resize) {
        return;
      }
      if (typeof event.button === 'number' && event.button !== 0) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setActiveOverlay(overlay);
      if (overlay.resize) {
        overlay.resize = null;
        if (interactionState.resizeOverlay === overlay) {
          interactionState.resizeOverlay = null;
        }
      }
      overlay.drag = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        originX: overlay.offsetX,
        originY: overlay.offsetY,
        captureTarget: captureTarget || overlay.elements.wrap
      };
      interactionState.dragOverlay = overlay;
      try {
        overlay.drag.captureTarget.setPointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay pointer capture failed', error);
      }
      attachGlobalInteractionListeners();
    }

    function handleOverlayDragMove(overlay, event) {
      const drag = overlay.drag;
      if (!drag || event.pointerId !== drag.pointerId) {
        return false;
      }
      event.preventDefault();
      const deltaX = event.clientX - drag.startX;
      const deltaY = event.clientY - drag.startY;
      const snapped = snapOverlayPosition(overlay, drag.originX + deltaX, drag.originY + deltaY);
      overlay.offsetX = Number.isFinite(snapped.x) ? snapped.x : drag.originX + deltaX;
      overlay.offsetY = Number.isFinite(snapped.y) ? snapped.y : drag.originY + deltaY;
      overlay.elements.wrap.style.left = `${overlay.offsetX}px`;
      overlay.elements.wrap.style.top = `${overlay.offsetY}px`;
      return true;
    }

    function finishOverlayDrag(overlay, event) {
      const drag = overlay.drag;
      if (!drag || event.pointerId !== drag.pointerId) {
        return false;
      }
      try {
        drag.captureTarget.releasePointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay pointer release failed', error);
      }
      overlay.drag = null;
      if (interactionState.dragOverlay === overlay) {
        interactionState.dragOverlay = null;
      }
      const snappedPosition = snapOverlayPosition(overlay, overlay.offsetX, overlay.offsetY);
      if (Number.isFinite(snappedPosition.x)) {
        overlay.offsetX = snappedPosition.x;
      }
      if (Number.isFinite(snappedPosition.y)) {
        overlay.offsetY = snappedPosition.y;
      }
      applyOverlayScale(overlay);
      detachGlobalInteractionListeners();
      refreshOverlayStatus();
      return true;
    }

    function startOverlayResize(overlay, handle, event) {
      if (!overlay.hasImage || !overlay.baseWidth || !overlay.baseHeight) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setActiveOverlay(overlay);
      if (overlay.drag) {
        overlay.drag = null;
        if (interactionState.dragOverlay === overlay) {
          interactionState.dragOverlay = null;
        }
      }
      const rect = overlay.elements.wrap.getBoundingClientRect();
      const anchor = getAnchorPoint(handle.dataset.handle, rect);
      overlay.resize = {
        pointerId: event.pointerId,
        handle,
        anchorX: anchor.x,
        anchorY: anchor.y
      };
      interactionState.resizeOverlay = overlay;
      try {
        handle.setPointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay resize capture failed', error);
      }
      attachGlobalInteractionListeners();
    }

    function handleOverlayResizeMove(overlay, event) {
      const resize = overlay.resize;
      if (!resize || event.pointerId !== resize.pointerId) {
        return false;
      }
      if (!overlay.baseWidth || !overlay.baseHeight) {
        return false;
      }
      event.preventDefault();
      event.stopPropagation();
      const distX = Math.abs(event.clientX - resize.anchorX);
      const distY = Math.abs(event.clientY - resize.anchorY);
      const targetWidth = Math.max(distX, 1);
      const targetHeight = Math.max(distY, 1);
      const desiredScale = Math.max(
        targetWidth / overlay.baseWidth,
        targetHeight / overlay.baseHeight
      );
      setOverlayScale(overlay, desiredScale);
      return true;
    }

    function finishOverlayResize(overlay, event) {
      const resize = overlay.resize;
      if (!resize || event.pointerId !== resize.pointerId) {
        return false;
      }
      event.preventDefault();
      event.stopPropagation();
      try {
        resize.handle.releasePointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay resize release failed', error);
      }
      overlay.resize = null;
      if (interactionState.resizeOverlay === overlay) {
        interactionState.resizeOverlay = null;
      }
      setOverlayScale(overlay, overlay.scale);
      detachGlobalInteractionListeners();
      refreshOverlayStatus();
      return true;
    }

    function setupOverlayEvents(overlay) {
      const { wrap, moveHandle, handles } = overlay.elements;

      wrap.addEventListener('pointerdown', (event) => {
        if (!overlay.hasImage || overlay.resize) {
          return;
        }
        if (handles.includes(event.target) || event.target === moveHandle) {
          return;
        }
        if (typeof event.button === 'number' && event.button !== 0) {
          return;
        }
        startOverlayDrag(overlay, event, wrap);
      });

      wrap.addEventListener('pointermove', (event) => {
        handleOverlayDragMove(overlay, event);
      });

      wrap.addEventListener('pointerup', (event) => {
        finishOverlayDrag(overlay, event);
      });

      wrap.addEventListener('pointercancel', (event) => {
        finishOverlayDrag(overlay, event);
      });

      wrap.addEventListener('contextmenu', (event) => {
        if (overlay.hasImage) {
          event.preventDefault();
        }
      });

      wrap.addEventListener('click', (event) => {
        if (!overlay.hasImage) {
          return;
        }
        setActiveOverlay(overlay);
        event.stopPropagation();
      });

      moveHandle.addEventListener('pointerdown', (event) => {
        if (!overlay.hasImage || overlay.resize) {
          return;
        }
        startOverlayDrag(overlay, event, moveHandle);
      });

      moveHandle.addEventListener('pointermove', (event) => {
        handleOverlayDragMove(overlay, event);
      });

      moveHandle.addEventListener('pointerup', (event) => {
        finishOverlayDrag(overlay, event);
      });

      moveHandle.addEventListener('pointercancel', (event) => {
        finishOverlayDrag(overlay, event);
      });

      moveHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      handles.forEach((handle) => {
        handle.addEventListener('pointerdown', (event) => startOverlayResize(overlay, handle, event));
        handle.addEventListener('pointermove', (event) => handleOverlayResizeMove(overlay, event));
        handle.addEventListener('pointerup', (event) => finishOverlayResize(overlay, event));
        handle.addEventListener('pointercancel', (event) => finishOverlayResize(overlay, event));
        handle.addEventListener('click', (event) => event.stopPropagation());
      });
    }

    function removeOverlay(overlay) {
      if (!overlay) {
        return;
      }
      const index = overlays.indexOf(overlay);
      if (index === -1) {
        return;
      }
      if (interactionState.dragOverlay === overlay) {
        interactionState.dragOverlay = null;
      }
      if (interactionState.resizeOverlay === overlay) {
        interactionState.resizeOverlay = null;
      }
      if (overlay.drag && overlay.drag.captureTarget) {
        try {
          overlay.drag.captureTarget.releasePointerCapture(overlay.drag.pointerId);
        } catch (error) {
          console.debug('overlay pointer release cleanup failed', error);
        }
      }
      if (overlay.resize && overlay.resize.handle) {
        try {
          overlay.resize.handle.releasePointerCapture(overlay.resize.pointerId);
        } catch (error) {
          console.debug('overlay resize release cleanup failed', error);
        }
      }
      overlay.drag = null;
      overlay.resize = null;
      overlay.tintCanvas = null;
      overlay.tintCtx = null;
      overlay.tintParams = null;
      overlay.tintUpdateScheduled = false;
      overlays.splice(index, 1);
      updateOverlayStacking();
      if (overlay.objectUrl) {
        URL.revokeObjectURL(overlay.objectUrl);
      }
      if (overlay.elements.wrap.parentElement === pixelPreview) {
        pixelPreview.removeChild(overlay.elements.wrap);
      }
      if (activeOverlay === overlay) {
        activeOverlay = null;
      }
      if (overlays.length > 0) {
        setActiveOverlay(overlays[overlays.length - 1]);
      } else {
        pixelPreview.hidden = true;
        clearPixelBtn.classList.remove('is-visible');
        clearPixelBtn.setAttribute('aria-hidden', 'true');
        clearPixelBtn.disabled = true;
        updateZoomControlMode(null);
        refreshOverlayStatus();
      }
      detachGlobalInteractionListeners();
    }

    function clearActiveOverlay() {
      if (!activeOverlay) {
        return;
      }
      removeOverlay(activeOverlay);
    }

    function createOverlayFromImageSource(imageSrc, { objectUrl = null, stamp = null } = {}) {
      if (!imageSrc) {
        return Promise.resolve(false);
      }
      return new Promise((resolve) => {
        const initialHue = clampHueValue(
          stamp && Number.isFinite(Number(stamp.defaultHue)) ? Number(stamp.defaultHue) : COLOR_CONTROL_DEFAULTS.hue
        );
        const initialSaturation = clampSaturationValue(
          stamp && Number.isFinite(Number(stamp.defaultSaturation))
            ? Number(stamp.defaultSaturation)
            : COLOR_CONTROL_DEFAULTS.saturation
        );
        const overlay = {
          id: `overlay-${Date.now()}-${Math.random().toString(16).slice(2)}`,
          objectUrl,
          stampId: stamp && stamp.id ? String(stamp.id) : null,
          hueAdjustable: Boolean(stamp && stamp.hueAdjustable),
          hue: initialHue,
          saturation: initialSaturation,
          hasImage: false,
          baseWidth: 0,
          baseHeight: 0,
          scale: 1,
          minScale: 1,
          maxScale: 64,
          offsetX: 24,
          offsetY: 24,
          drag: null,
          resize: null,
          tintCanvas: null,
          tintCtx: null,
          tintParams: null,
          tintUpdateScheduled: false,
          imageSource: imageSrc,
          elements: createOverlayElements()
        };

        if (overlay.elements && overlay.elements.wrap) {
          overlay.elements.wrap.dataset.overlayId = overlay.id;
          if (overlay.stampId) {
            overlay.elements.wrap.dataset.stampId = overlay.stampId;
          }
          if (overlay.hueAdjustable) {
            overlay.elements.wrap.dataset.hueAdjustable = 'true';
          } else {
            delete overlay.elements.wrap.dataset.hueAdjustable;
          }
        }

        setupOverlayEvents(overlay);
        pixelPreview.appendChild(overlay.elements.wrap);
        pixelPreview.hidden = false;
        overlays.push(overlay);
        setActiveOverlay(overlay);

        overlay.elements.image.onload = () => {
          overlay.elements.image.onload = null;
          overlay.elements.image.onerror = null;
          overlay.hasImage = true;
          overlay.baseWidth = overlay.elements.image.naturalWidth || overlay.elements.image.width;
          overlay.baseHeight = overlay.elements.image.naturalHeight || overlay.elements.image.height;
          const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
          const initialScaleCandidate = Math.min(
            viewportLimit,
            Math.max(1, Math.floor((window.innerWidth * 0.35) / overlay.baseWidth)),
            Math.max(1, Math.floor((window.innerHeight * 0.35) / overlay.baseHeight))
          ) || 1;
          const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
          overlay.scale = Math.max(overlay.minScale, Math.min(maxScale, initialScaleCandidate));
          const displayWidth = overlay.baseWidth * overlay.scale;
          const displayHeight = overlay.baseHeight * overlay.scale;
          const offsetStep = Math.min(overlays.length - 1, 5) * 32;
          overlay.offsetX = Math.round((window.innerWidth - displayWidth) / 2 + offsetStep);
          overlay.offsetY = Math.round((window.innerHeight - displayHeight) / 2 + offsetStep);
          if (!Number.isFinite(overlay.offsetX)) {
            overlay.offsetX = 24;
          }
          if (!Number.isFinite(overlay.offsetY)) {
            overlay.offsetY = 24;
          }
          setOverlayScale(overlay, overlay.scale);
          overlay.elements.wrap.classList.add('is-active');
          clearPixelBtn.classList.add('is-visible');
          clearPixelBtn.setAttribute('aria-hidden', 'false');
          clearPixelBtn.disabled = false;
          applyOverlayColorTransform(overlay);
          refreshOverlayStatus();
          resolve(true);
        };

        overlay.elements.image.onerror = () => {
          overlay.elements.image.onload = null;
          overlay.elements.image.onerror = null;
          removeOverlay(overlay);
          setStatus('ドット絵を読み込めませんでした');
          resolve(false);
        };

        overlay.elements.image.src = imageSrc;
      });
    }

    function loadPixelArt(file) {
      if (!file) {
        return Promise.resolve(false);
      }
      const objectUrl = URL.createObjectURL(file);
      return createOverlayFromImageSource(objectUrl, { objectUrl });
    }

    pixelArtBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      closeAllMenus();
      pixelArtInput.click();
    });

    pixelArtInput.addEventListener('change', async (event) => {
      const files = Array.from(event.target.files || []);
      for (const file of files) {
        await loadPixelArt(file);
      }
      pixelArtInput.value = '';
    });

    clearPixelBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      closeAllMenus();
      clearActiveOverlay();
    });

    if (qrReadout) {
      ['click', 'pointerdown', 'mousedown', 'touchstart'].forEach((type) => {
        qrReadout.addEventListener(type, (event) => event.stopPropagation(), { passive: false });
      });
    }
    if (qrCloseBtn) {
      qrCloseBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        setQrReadoutVisibility(false);
      });
    }

    if (qrCopyBtn) {
      qrCopyBtn.addEventListener('click', async (event) => {
        event.stopPropagation();
        if (!qrLastValue) {
          return;
        }
        const textToCopy = qrLastValue;
        try {
          if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            await navigator.clipboard.writeText(textToCopy);
          } else {
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
          }
          updateQrReadout('コピーしました。', qrScanEnabled ? 'スキャン中' : '停止中', {
            resultText: qrLastValue,
            openUrl: qrOpenTarget || getOpenableUrl(qrLastValue),
            forceShow: true
          });
          setStatus('QRの内容をコピーしました');
        } catch (error) {
          console.warn('Failed to copy QR result', error);
          setStatus('QRのコピーに失敗しました');
        }
      });
    }

    if (qrOpenBtn) {
      qrOpenBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const targetUrl = qrOpenTarget || getOpenableUrl(qrLastValue);
        if (!targetUrl) {
          return;
        }
        const opened = window.open(targetUrl, '_blank', 'noopener');
        if (!opened) {
          setStatus('リンクを開けませんでした');
        }
      });
    }

    if (cameraActionBtn) {
      cameraActionBtn.addEventListener('click', async () => {
        if (state.restarting) {
          return;
        }
        closeAllMenus();
        if (cameraActionMode === 'switch') {
          state.useFrontCamera = !state.useFrontCamera;
        }
        if (cameraStartLocked) {
          cameraStartLocked = false;
        }
        if (cameraActionMode !== 'switch') {
          hideCameraStartOverlay();
        }
        await startCamera();
      });
    }

    if (aspectMenuBtn) {
      aspectMenuBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('aspect');
      });
    }

    if (stampBtn) {
      stampBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('stamps');
      });
    }

    if (cameraSettingsBtn) {
      cameraSettingsBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('cameraSettings');
      });
    }

    cameraSettingSliders.forEach((slider) => {
      const key = slider.dataset.setting;
      if (!key) {
        return;
      }
      slider.addEventListener('input', (event) => {
        event.stopPropagation();
        setCameraSettingValue(key, slider.value);
        slider.setAttribute('aria-valuenow', slider.value);
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(Number(slider.value), key));
      });
      slider.addEventListener('change', (event) => {
        event.stopPropagation();
        setCameraSettingValue(key, slider.value);
        slider.setAttribute('aria-valuenow', slider.value);
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(Number(slider.value), key));
      });
      slider.addEventListener('pointerdown', (event) => {
        event.stopPropagation();
      });
      slider.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });

    if (cameraSettingsResetBtn) {
      cameraSettingsResetBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        resetCameraSettings();
      });
    }

    function handleTapAutoAdjust(event) {
      if (!video || video.readyState < 2) {
        return;
      }
      if (event.button != null && event.button !== 0) {
        return;
      }
      const rect = video.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      const metrics = sampleFrameForAutoAdjust({ x, y });
      if (!metrics) {
        setStatus('タップした位置の解析に失敗しました');
        return;
      }
      const nextSettings = buildAutoAdjustedSettings(metrics);
      if (!nextSettings) {
        setStatus('自動調整を適用できませんでした');
        return;
      }
      applyCameraSettingsBatch(nextSettings);
      setStatus('タップ位置を基準に自動調整しました');
    }

    if (video) {
      video.addEventListener('pointerdown', handleTapAutoAdjust);
    }

    if (paletteToggleBtn) {
      paletteToggleBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (paletteToggleBtn.disabled) {
          return;
        }
        const nextState = !paletteDisplayEnabled;
        if (nextState && !dotScalePanelOpen) {
          openMenuExclusive('dotScale');
        }
        setPaletteDisplayEnabled(nextState);
      });
    }

    if (dotModeBtn) {
      dotModeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        setDotMode(true);
        if (dotScalePanelOpen && dotSettingsPanel && !dotSettingsPanel.hidden) {
          closeAllMenus();
        } else {
          openMenuExclusive('dotScale');
        }
      });
    }

    function getVideoCoverSourceRect(viewportWidth, viewportHeight) {
      if (!video) {
        return null;
      }
      const videoWidth = Number.isFinite(video.videoWidth) ? video.videoWidth : 0;
      const videoHeight = Number.isFinite(video.videoHeight) ? video.videoHeight : 0;
      if (!videoWidth || !videoHeight) {
        return null;
      }
      const displayWidth = Math.max(1, Number.isFinite(viewportWidth) ? viewportWidth : videoWidth);
      const displayHeight = Math.max(1, Number.isFinite(viewportHeight) ? viewportHeight : videoHeight);
      const scale = Math.max(displayWidth / videoWidth, displayHeight / videoHeight);
      if (!Number.isFinite(scale) || scale <= 0) {
        return null;
      }
      const visibleWidth = displayWidth / scale;
      const visibleHeight = displayHeight / scale;
      const sx = Math.max(0, (videoWidth - visibleWidth) / 2);
      const sy = Math.max(0, (videoHeight - visibleHeight) / 2);
      return {
        sx,
        sy,
        sw: Math.min(videoWidth, visibleWidth),
        sh: Math.min(videoHeight, visibleHeight)
      };
    }

    function drawVideoLayer(ctx, viewportWidth, viewportHeight) {
      if (!video || video.readyState < 2) {
        return false;
      }
      const source = getVideoCoverSourceRect(viewportWidth, viewportHeight);
      if (!source) {
        return false;
      }
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.filter = currentCameraFilterString || 'none';
      ctx.drawImage(
        video,
        source.sx,
        source.sy,
        source.sw,
        source.sh,
        0,
        0,
        viewportWidth,
        viewportHeight
      );
      ctx.restore();
      return true;
    }

    function drawDotLayer(ctx) {
      if (!state.dotMode || !dotCanvas || dotCanvas.hidden) {
        return;
      }
      const rect = dotCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(dotCanvas, rect.left, rect.top, rect.width, rect.height);
      ctx.restore();
    }

    function drawPixelOverlaysLayer(ctx) {
      if (!overlays.length) {
        return;
      }
      overlays.forEach((overlay) => {
        if (!overlay || !overlay.hasImage || !overlay.elements || !overlay.elements.image) {
          return;
        }
        const width = overlay.baseWidth * overlay.scale;
        const height = overlay.baseHeight * overlay.scale;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
          return;
        }
        const x = Number.isFinite(overlay.offsetX) ? overlay.offsetX : 0;
        const y = Number.isFinite(overlay.offsetY) ? overlay.offsetY : 0;
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(overlay.elements.image, x, y, width, height);
        ctx.restore();
      });
    }

    function drawCaptureLayers(ctx, viewportWidth, viewportHeight) {
      const videoDrawn = drawVideoLayer(ctx, viewportWidth, viewportHeight);
      drawDotLayer(ctx);
      drawPixelOverlaysLayer(ctx);
      return videoDrawn || (state.dotMode && dotCanvas && !dotCanvas.hidden) || overlays.length > 0;
    }

    function getCaptureViewportRect(viewportWidth, viewportHeight) {
      const width = Math.max(1, Number.isFinite(viewportWidth) ? viewportWidth : 0);
      const height = Math.max(1, Number.isFinite(viewportHeight) ? viewportHeight : 0);
      if (!width || !height) {
        return { x: 0, y: 0, width: 0, height: 0 };
      }
      const layout = dotState.layout || {};
      if (!layout.width || !layout.height) {
        return { x: 0, y: 0, width, height };
      }
      const offsetX = Number.isFinite(layout.offsetX) ? layout.offsetX : 0;
      const offsetY = Number.isFinite(layout.offsetY) ? layout.offsetY : 0;
      const cropWidth = Math.max(1, Math.min(width, Math.round(layout.width)));
      const cropHeight = Math.max(1, Math.min(height, Math.round(layout.height)));
      const x = Math.max(0, Math.min(width - 1, Math.round(offsetX)));
      const y = Math.max(0, Math.min(height - 1, Math.round(offsetY)));
      const adjustedWidth = Math.max(1, Math.min(cropWidth, width - x));
      const adjustedHeight = Math.max(1, Math.min(cropHeight, height - y));
      return {
        x,
        y,
        width: adjustedWidth,
        height: adjustedHeight
      };
    }

    function canvasToBlobWithFallback(canvas) {
      return new Promise((resolve) => {
        if (!canvas) {
          resolve({ blob: null, dataUrl: null });
          return;
        }
        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (blob) {
              resolve({ blob, dataUrl: null });
            } else {
              resolve({ blob: null, dataUrl: canvas.toDataURL('image/png') });
            }
          }, 'image/png');
          return;
        }
        resolve({ blob: null, dataUrl: canvas.toDataURL('image/png') });
      });
    }

    function blobToDataUrl(blob) {
      return new Promise((resolve, reject) => {
        if (!(blob instanceof Blob)) {
          resolve(null);
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const result = typeof reader.result === 'string' ? reader.result : null;
          resolve(result);
        };
        reader.onerror = () => reject(reader.error || new Error('blob-to-dataurl-error'));
        reader.readAsDataURL(blob);
      });
    }

    async function createDrawImportPayload(result, filename) {
      if (!result) {
        return null;
      }
      let width = Number(result.width);
      let height = Number(result.height);
      let dataUrl = typeof result.dataUrl === 'string' && result.dataUrl ? result.dataUrl : null;

      if (state.dotMode && dotCanvas && dotCanvas.width && dotCanvas.height) {
        try {
          dataUrl = dotCanvas.toDataURL('image/png');
          width = dotCanvas.width;
          height = dotCanvas.height;
        } catch (error) {
          console.warn('Failed to capture dot canvas for PiXiEEDraw import', error);
        }
      }

      if (!dataUrl && result.blob instanceof Blob) {
        try {
          dataUrl = await blobToDataUrl(result.blob);
        } catch (error) {
          console.warn('Failed to build data URL for PiXiEEDraw import', error);
          dataUrl = null;
        }
      }

      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return null;
      }
      if (!dataUrl || typeof dataUrl !== 'string' || !dataUrl.startsWith('data:image/')) {
        return null;
      }
      const payload = {
        version: DRAW_IMPORT_STORAGE_VERSION,
        createdAt: Date.now(),
        filename: typeof filename === 'string' && filename ? filename : 'pixiee-lens.png',
        width,
        height,
        dotScale: state.dotScale,
        colorDepth: state.colorDepth,
        dataUrl
      };
      return payload;
    }

    function storeDrawImportPayload(payload) {
      if (!payload || typeof payload !== 'object') {
        return false;
      }
      try {
        const enriched = {
          ...payload,
          expiresAt: Date.now() + DRAW_IMPORT_EXPIRY_MS
        };
        localStorage.setItem(DRAW_IMPORT_STORAGE_KEY, JSON.stringify(enriched));
        return true;
      } catch (error) {
        console.warn('Failed to store PiXiEEDraw transfer payload', error);
        return false;
      }
    }

    function openCaptureInDraw() {
      if (!capturePreviewEditPayload || typeof capturePreviewEditPayload.dataUrl !== 'string') {
        setStatus('PiXiEEDraw に送信できるデータがありません');
        return;
      }
      const stored = storeDrawImportPayload(capturePreviewEditPayload);
      if (!stored) {
        setStatus('PiXiEEDraw への送信に失敗しました');
        return;
      }
      const baseUrl = new URL('./', window.location.href);
      const drawUrl = new URL('../pixiedraw/', baseUrl);
      drawUrl.searchParams.set('lens', '1');
      const opened = window.open(drawUrl.toString(), '_blank', 'noopener');
      if (!opened) {
        setStatus('PiXiEEDraw を開けませんでした。ポップアップがブロックされていないか確認してください。');
        return;
      }
      setStatus('PiXiEEDraw を新しいタブで開きました');
      closeCapturePreview();
    }

    function composeCaptureFrame() {
      const viewportWidth = Math.max(1, Math.round(window.innerWidth || 0));
      const viewportHeight = Math.max(1, Math.round(window.innerHeight || 0));
      if (!viewportWidth || !viewportHeight) {
        return Promise.resolve(null);
      }
      const deviceRatio = window.devicePixelRatio || 1;
      const pixelRatio = Math.min(Math.max(deviceRatio, 1), 2.5);
      const viewportCanvas = document.createElement('canvas');
      viewportCanvas.width = Math.max(1, Math.round(viewportWidth * pixelRatio));
      viewportCanvas.height = Math.max(1, Math.round(viewportHeight * pixelRatio));
      const ctx = viewportCanvas.getContext('2d', { willReadFrequently: false });
      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, viewportCanvas.width, viewportCanvas.height);
      ctx.save();
      ctx.scale(pixelRatio, pixelRatio);
      const hasContent = drawCaptureLayers(ctx, viewportWidth, viewportHeight);
      ctx.restore();
      if (!hasContent) {
        return Promise.resolve(null);
      }
      const captureRect = getCaptureViewportRect(viewportWidth, viewportHeight);
      const cropX = Math.max(0, Math.min(viewportWidth, captureRect.x));
      const cropY = Math.max(0, Math.min(viewportHeight, captureRect.y));
      const cropWidth = Math.max(1, Math.min(viewportWidth - cropX, captureRect.width));
      const cropHeight = Math.max(1, Math.min(viewportHeight - cropY, captureRect.height));
      const isFullViewport =
        Math.abs(cropX) < 0.5 &&
        Math.abs(cropY) < 0.5 &&
        Math.abs(cropWidth - viewportWidth) < 0.5 &&
        Math.abs(cropHeight - viewportHeight) < 0.5;
      let outputCanvas = viewportCanvas;
      let outputWidth = viewportCanvas.width;
      let outputHeight = viewportCanvas.height;
      if (!isFullViewport) {
        const sx = Math.max(0, Math.min(viewportCanvas.width - 1, Math.round(cropX * pixelRatio)));
        const sy = Math.max(0, Math.min(viewportCanvas.height - 1, Math.round(cropY * pixelRatio)));
        const sw = Math.max(1, Math.min(viewportCanvas.width - sx, Math.round(cropWidth * pixelRatio)));
        const sh = Math.max(1, Math.min(viewportCanvas.height - sy, Math.round(cropHeight * pixelRatio)));
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = sw;
        croppedCanvas.height = sh;
        const croppedCtx = croppedCanvas.getContext('2d', { willReadFrequently: false });
        croppedCtx.imageSmoothingEnabled = false;
        croppedCtx.drawImage(
          viewportCanvas,
          sx,
          sy,
          sw,
          sh,
          0,
          0,
          sw,
          sh
        );
        outputCanvas = croppedCanvas;
        outputWidth = sw;
        outputHeight = sh;
      }
      if (state.colorDepth === 'full') {
        simplifyCanvasColors(outputCanvas);
      }
      return canvasToBlobWithFallback(outputCanvas).then((payload) => ({
        ...payload,
        width: outputWidth,
        height: outputHeight,
        cssWidth: Math.round(outputWidth / pixelRatio),
        cssHeight: Math.round(outputHeight / pixelRatio)
      }));
    }

    function getCaptureFilename() {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      return `pixiee-lens-${timestamp}.png`;
    }

    async function deliverCaptureResult(result, filename) {
      if (!result) {
        return false;
      }
      const { blob, dataUrl, cssWidth, cssHeight } = result;
      const supportsDownloadAttr = 'download' in HTMLAnchorElement.prototype;
      const isIOS = /iP(hone|ad|od)/i.test(navigator.userAgent);
      const drawPayload = await createDrawImportPayload(result, filename);
      let previewUrl = drawPayload && typeof drawPayload.dataUrl === 'string' ? drawPayload.dataUrl : null;
      if (!previewUrl && typeof dataUrl === 'string' && dataUrl) {
        previewUrl = dataUrl;
      }
      let sharePayload = null;
      let infoMessage = drawPayload
        ? 'PiXiEEDrawで編集するか、画像を保存してご利用ください。'
        : '画像を保存してご利用ください。';
      if (blob instanceof Blob) {
        const shareFile = new File([blob], filename, { type: 'image/png' });
        const canShareFiles = isIOS && typeof navigator.share === 'function' && (!navigator.canShare || navigator.canShare({ files: [shareFile] }));
        if (isIOS && canShareFiles) {
          try {
            await navigator.share({
              files: [shareFile],
              title: 'PiXiEELENS',
              text: '撮影した画像'
            });
          } catch (error) {
            if (error && error.name !== 'AbortError') {
              console.warn('Share failed', error);
            }
            // continue to fallback preview
          }
        }
        if (supportsDownloadAttr) {
          const downloadUrl = URL.createObjectURL(blob);
          const anchor = document.createElement('a');
          anchor.href = downloadUrl;
          anchor.download = filename;
          anchor.rel = 'noopener';
          anchor.style.position = 'absolute';
          anchor.style.left = '-9999px';
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          setTimeout(() => URL.revokeObjectURL(downloadUrl), 1000);
          infoMessage = drawPayload
            ? '画像を自動的に保存しました。「PiXiEEDrawで編集」で続けて編集できます。'
            : '画像を自動的に保存しました。';
        } else if (canShareFiles) {
          infoMessage = drawPayload
            ? '「共有する」ボタンで保存するか、「PiXiEEDrawで編集」で編集できます。'
            : '「共有する」ボタンから保存してください。';
        } else {
          infoMessage = drawPayload
            ? '画像を長押しして保存するか、「PiXiEEDrawで編集」で編集できます。'
            : '画像を長押しして写真に保存してください。';
        }
        if (canShareFiles) {
          const shareUrl = previewUrl && previewUrl.startsWith('blob:')
            ? previewUrl
            : URL.createObjectURL(blob);
          sharePayload = {
            file: shareFile,
            blobUrl: shareUrl
          };
          if (!previewUrl) {
            previewUrl = shareUrl;
          }
        }
        if (!previewUrl) {
          previewUrl = URL.createObjectURL(blob);
        }
      }
      if (!previewUrl) {
        return false;
      }
      const previewWidth = drawPayload ? drawPayload.width : cssWidth;
      const previewHeight = drawPayload ? drawPayload.height : cssHeight;
      showCapturePreview({
        url: previewUrl,
        filename,
        width: previewWidth,
        height: previewHeight,
        sharePayload,
        infoMessage,
        drawPayload
      });
      return true;
    }

    async function handleCaptureAction() {
      if (captureInProgress) {
        return;
      }
      if (!cameraReady || !state.stream || !video || video.readyState < 2) {
        setStatus('カメラの準備が完了してから撮影してください');
        return;
      }
      captureInProgress = true;
      if (captureBtn) {
        captureBtn.disabled = true;
        captureBtn.setAttribute('aria-busy', 'true');
      }
      try {
        const result = await composeCaptureFrame();
        if (!result || (!result.blob && !result.dataUrl)) {
          setStatus('撮影に失敗しました');
          return;
        }
        const filename = getCaptureFilename();
        const saved = await deliverCaptureResult(result, filename);
        if (!saved) {
          setStatus('撮影データを保存できませんでした');
          return;
        }
        setStatus(`撮影しました: ${result.width}×${result.height}px`);
      } catch (error) {
        console.error(error);
        setStatus('撮影に失敗しました');
      } finally {
        captureInProgress = false;
        if (captureBtn) {
          captureBtn.disabled = false;
          captureBtn.removeAttribute('aria-busy');
        }
      }
    }

    if (captureBtn) {
      captureBtn.addEventListener('click', async (event) => {
        event.stopPropagation();
        closeAllMenus();
        await handleCaptureAction();
      });
    }

    aspectButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const mode = button.dataset.aspect || '1:1';
        setAspectMode(mode);
      });
    });

    if (dotScaleSelect) {
      ['mousedown', 'touchstart', 'pointerdown', 'click'].forEach((type) => {
        dotScaleSelect.addEventListener(type, (event) => {
          event.stopPropagation();
        });
      });
      dotScaleSelect.addEventListener('change', () => {
        const value = Number(dotScaleSelect.value);
        if (!Number.isFinite(value)) {
          return;
        }
        if (value === state.dotScale) {
          return;
        }
        state.dotScale = Math.max(1, Math.min(5, Math.round(value)));
        ensureDotResolution();
        if (state.dotMode) {
          refreshOverlayStatus();
        }
        updateDotModeUI();
      });
    }

    if (colorDepthSelect) {
      ['mousedown', 'touchstart', 'pointerdown', 'click'].forEach((type) => {
        colorDepthSelect.addEventListener(type, (event) => {
          event.stopPropagation();
        });
      });
      colorDepthSelect.addEventListener('change', () => {
        const value = colorDepthSelect.value;
        if (!COLOR_DEPTHS.includes(value)) {
          return;
        }
        if (value === state.colorDepth) {
          return;
        }
        state.colorDepth = value;
        if (state.dotMode) {
          refreshOverlayStatus();
        }
        updateDotModeUI();
      });
    }

    pixelPreview.addEventListener('click', (event) => {
      event.stopPropagation();
    });

    document.addEventListener('click', (event) => {
      if (!openMenuKey) {
        return;
      }
      if (openMenuKey === 'dotScale') {
        if (!dotSettingsPanel || !dotModeBtn) {
          openMenuKey = null;
          return;
        }
        if (!dotSettingsPanel.contains(event.target) && !dotModeBtn.contains(event.target)) {
          setDotSettingsOpen(false);
        }
        return;
      }
      const entry = menus[openMenuKey];
      if (!entry || !entry.panel || !entry.button) {
        openMenuKey = null;
        return;
      }
      if (!entry.panel.contains(event.target) && !entry.button.contains(event.target)) {
        closeMenu(openMenuKey);
      }
    });

    document.addEventListener('click', (event) => {
      if (!overlays.length) {
        return;
      }
      if (pixelArtBtn.contains(event.target) || clearPixelBtn.contains(event.target)) {
        return;
      }
      const clickedOverlay = overlays.find((overlay) => overlay.elements.wrap.contains(event.target));
      if (clickedOverlay) {
        setActiveOverlay(clickedOverlay);
        return;
      }
      if (interactionState.dragOverlay || interactionState.resizeOverlay) {
        return;
      }
      setActiveOverlay(null);
    });

    function stopCamera() {
      stopQrScanLoop();
      if (state.stream) {
        state.stream.getTracks().forEach((track) => track.stop());
        state.stream = null;
      }
      video.srcObject = null;
      stopDotRendering();
      cameraReady = false;
      cameraZoomCapability = null;
      cameraZoomCapabilityKnown = false;
      updateZoomSliderAvailability();
      updateCameraActionState();
    }

    async function startCamera() {
      if (state.restarting) {
        return cameraReady;
      }
      state.restarting = true;
      cameraReady = false;
      setCameraStatus('カメラを初期化しています…');
      cameraZoomCapability = null;
      cameraZoomCapabilityKnown = false;
      updateZoomSliderAvailability();
      updateCameraActionState();

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setCameraStatus('このブラウザはカメラアクセスに対応していません。');
        cameraPermissionDenied = false;
        state.restarting = false;
        updateCameraActionState();
        return false;
      }

      let success = false;
      let failureMessage = null;

      try {
        stopCamera();
        const facingMode = state.useFrontCamera ? 'user' : 'environment';
        const constraintCandidates = [
          {
            video: {
              facingMode,
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            },
            audio: false
          },
          {
            video: {
              facingMode
            },
            audio: false
          },
          {
            video: true,
            audio: false
          }
        ];
        let stream = null;
        let lastError = null;
        for (const constraints of constraintCandidates) {
          try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            break;
          } catch (error) {
            lastError = error;
          }
        }
        if (!stream) {
          throw lastError || new Error('Camera unavailable');
        }
        state.stream = stream;
        cameraConstraintErrorLogged = false;
        video.srcObject = stream;
        const track = getActiveVideoTrack();
        if (track && typeof track.getCapabilities === 'function') {
          try {
            const capabilities = track.getCapabilities();
            cameraZoomCapabilityKnown = true;
            if (capabilities && Object.prototype.hasOwnProperty.call(capabilities, 'zoom')) {
              cameraZoomCapability = capabilities.zoom;
              syncZoomStateFromTrack(track);
            } else {
              cameraZoomCapability = null;
            }
          } catch (error) {
            cameraZoomCapability = null;
            cameraZoomCapabilityKnown = false;
          }
        }
        updateZoomSliderAvailability();
        try {
          await video.play();
        } catch (playError) {
          throw playError instanceof Error ? playError : new Error('Camera playback failed');
        }
        await waitForVideoReady();
        video.style.transform = 'scaleX(1)';
        applyCameraSettings();
        cameraPermissionDenied = false;
        cameraReady = true;
        const cameraStatus = state.useFrontCamera ? 'フロントカメラ表示中' : '';
        setCameraStatus(cameraStatus);
        if (qrScanEnabled) {
          scheduleQrScanLoop(120);
        }
        updateAspectLayout();
        if (state.dotMode) {
          startDotRendering();
        } else {
          stopDotRendering();
        }
        success = true;
      } catch (error) {
        console.error(error);
        const isPermissionError = error && (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError');
        cameraPermissionDenied = Boolean(isPermissionError);
        cameraReady = false;
        const errorDetail = error && error.name ? ` (${error.name}${error.message ? `: ${error.message}` : ''})` : '';
        failureMessage = cameraPermissionDenied
          ? `カメラへのアクセスが許可されませんでした。設定アプリで「PiXiEELENS」のカメラを有効にしてください。${errorDetail}`
          : `カメラにアクセスできませんでした。端末の設定をご確認ください。${errorDetail}`;
        setStatus(failureMessage);
        setCameraStatus(failureMessage);
        stopCamera();
        stopDotRendering();
        if (requiresCameraUserGesture) {
          cameraStartLocked = true;
        }
      } finally {
        state.restarting = false;
        updateCameraActionState();
      }

      if (success) {
        cameraStartLocked = false;
        hideCameraStartOverlay();
      } else if (requiresCameraUserGesture) {
        const overlayMessage = failureMessage || 'カメラを起動できませんでした。もう一度お試しください。';
        showCameraStartOverlay(overlayMessage);
      }

      updateCameraActionState();
      return success;
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopCamera();
        stopQrScanLoop();
      } else {
        if (qrScanEnabled) {
          scheduleQrScanLoop(200);
        }
        if (!cameraStartLocked) {
          startCamera();
        }
      }
    });

    window.addEventListener('beforeunload', () => {
      stopQrScanLoop();
      stopCamera();
    });
    window.addEventListener('pagehide', () => {
      stopQrScanLoop();
      stopCamera();
    });

    window.addEventListener('focus', () => {
      if (document.hidden) {
        return;
      }
      if (cameraStartLocked) {
        return;
      }
      if (cameraReady) {
        return;
      }
      if (cameraStartOverlay && !cameraStartOverlay.hidden) {
        return;
      }
      if (qrScanEnabled) {
        scheduleQrScanLoop(200);
      }
      startCamera();
    });

    window.addEventListener('resize', () => {
      updateAspectLayout();
      if (state.dotMode) {
        ensureDotResolution();
      }
      updateControlPlacement();
      overlays.forEach((overlay) => {
        if (!overlay.hasImage) {
          return;
        }
        const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
        const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
        if (overlay.scale > maxScale) {
          setOverlayScale(overlay, maxScale);
        } else {
          setOverlayScale(overlay, overlay.scale);
        }
      });
      refreshOverlayStatus();
    });

    if (window.visualViewport) {
      const handleViewportChange = () => {
        updateAspectLayout();
        if (state.dotMode) {
          ensureDotResolution();
        }
        updateControlPlacement();
      };
      window.visualViewport.addEventListener('resize', handleViewportChange);
      window.visualViewport.addEventListener('scroll', handleViewportChange);
    }

    const handleOrientationChange = () => {
      updateControlPlacement();
    };

    window.addEventListener('orientationchange', handleOrientationChange);
    if (window.screen && window.screen.orientation && typeof window.screen.orientation.addEventListener === 'function') {
      window.screen.orientation.addEventListener('change', handleOrientationChange);
    }

    updatePaletteToggleAvailability();
    setDotMode(true);
    updateDotModeUI();
    setAspectMode(state.aspectMode);
    updateControlPlacement();
    setQrReadoutVisibility(false);

    if (iosStandaloneUnsupported) {
      showIOSStandaloneUnsupportedOverlay();
    } else if (requiresCameraUserGesture) {
      cameraStartLocked = true;
      showCameraStartOverlay('「カメラを起動」をタップするとカメラの許可ダイアログが表示されます。「許可」を選び、再度撮影をお試しください。');
    } else {
      cameraStartLocked = false;
      startCamera();
    }
  </script>
</body>
</html>
    .icon-button--ghost {
      background: transparent;
      border-color: transparent;
      box-shadow: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease;
    }
    .icon-button--ghost.is-visible {
      pointer-events: auto;
      opacity: 1;
      background: rgba(123, 207, 255, 0.2);
      border-color: rgba(123, 207, 255, 0.35);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.32);
    }
