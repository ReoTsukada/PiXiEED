<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PiXiEE Lens | Fullscreen Camera</title>
  <meta name="description" content="PiXiEE Lens は全画面カメラとドットモードを備えた実験ページです。">
  <meta name="theme-color" content="#050812">
  <meta property="og:type" content="website">
  <meta property="og:title" content="PiXiEE Lens | Fullscreen Camera">
  <meta property="og:description" content="PiXiEE Lens は全画面カメラとドットモードを備えた実験ページです。">
  <meta property="og:image" content="https://pixieed.jp/pixiee-lens/ogp.png">
  <meta property="og:url" content="https://pixieed.jp/pixiee-lens/index.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="PiXiEE Lens | Fullscreen Camera">
  <meta name="twitter:description" content="PiXiEE Lens は全画面カメラとドットモードを備えた実験ページです。">
  <meta name="twitter:image" content="https://pixieed.jp/pixiee-lens/ogp.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./icon-512.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <style>
    :root {
      color-scheme: dark;
      --bg: radial-gradient(circle at 20% 15%, rgba(123, 207, 255, 0.18), transparent 55%), radial-gradient(circle at 80% 8%, rgba(255, 143, 246, 0.15), transparent 50%), #050812;
      --fg: #e7eeff;
      --muted: #96a6cb;
      --accent: #7bcfff;
      font-family: "Inter", "Hiragino Sans", "Noto Sans JP", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      --hud-padding: clamp(18px, 4vw, 42px);
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }
    main {
      position: relative;
      width: 100vw;
      height: 100dvh;
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #020409;
      filter: saturate(1.05);
      z-index: 1;
    }
    .dot-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      pointer-events: none;
      z-index: 2;
    }
    .aspect-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.25s ease;
    }
    .aspect-shade {
      flex: 0 0 auto;
      width: 100%;
      background: #000;
      pointer-events: none;
      transition: height 0.25s ease;
    }
    .aspect-middle {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      pointer-events: none;
    }
    .aspect-side-shade {
      flex: 0 0 auto;
      height: 100%;
      background: #000;
      pointer-events: none;
      transition: width 0.25s ease;
    }
    .aspect-frame {
      flex: 0 0 auto;
      width: 0;
      height: 0;
      pointer-events: none;
      transition: width 0.25s ease, height 0.25s ease;
    }
    .hud {
      position: absolute;
      inset: 0;
      text-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
      pointer-events: none;
      z-index: 5;
      width: 100%;
    }
    .hud-top {
      position: absolute;
      top: calc(var(--hud-padding) + var(--safe-top));
      left: calc(var(--hud-padding) + var(--safe-left));
      right: calc(var(--hud-padding) + var(--safe-right));
      display: flex;
      flex-direction: column;
      gap: 18px;
      pointer-events: none;
    }
    .hud-top__bar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: nowrap;
      gap: 16px;
      width: 100%;
    }
    .hud-top__actions {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      flex-wrap: wrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .hud-top__actions--right {
      margin-left: auto;
      justify-content: flex-end;
      flex: 0 0 auto;
    }
    .hud-top__panel-wrap {
      display: flex;
      justify-content: flex-end;
      pointer-events: auto;
    }
    .hud-top__panel-wrap > * {
      width: min(360px, 92vw);
    }
    .hud-top__panel-wrap--left {
      justify-content: flex-start;
    }
    .hud-top__panel-wrap--right {
      justify-content: flex-end;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    p {
      margin: 0;
      line-height: 1.6;
      font-size: clamp(0.9rem, 2vw, 1.05rem);
      color: var(--muted);
    }
    .hud-bottom {
      position: absolute;
      bottom: calc(var(--hud-padding) + var(--safe-bottom));
      left: calc(var(--hud-padding) + var(--safe-left));
      right: calc(var(--hud-padding) + var(--safe-right));
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      pointer-events: none;
    }
    .hud-bottom__actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: nowrap;
      gap: clamp(12px, 4vw, 20px);
      width: 100%;
      pointer-events: none;
      flex-wrap: nowrap;
    }
    .hud-bottom__actions > * {
      pointer-events: auto;
    }
    .hud-bottom__actions-group {
      display: inline-flex;
      align-items: center;
      gap: clamp(10px, 3vw, 16px);
      flex: 0 0 auto;
    }
    .hud-bottom__actions-group--left {
      justify-content: flex-start;
    }
    .hud-bottom__actions-group--right {
      justify-content: flex-end;
    }
    .hud-bottom__center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      flex: 0 1 auto;
      pointer-events: auto;
      width: clamp(220px, 50vw, 280px);
    }
    .hud-bottom__capture-slot {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: clamp(60px, 18vw, 96px);
      height: clamp(60px, 18vw, 96px);
      pointer-events: auto;
    }
    body.is-landscape .hud-bottom__capture-slot {
      display: none;
    }
    .hud-landscape-capture {
      position: fixed;
      top: 50%;
      right: calc(var(--hud-padding) + var(--safe-right));
      transform: translateY(-50%);
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 6;
    }
    body.is-landscape .hud-landscape-capture {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(12px, 3vw, 18px);
    }
    .hud-landscape-capture > * {
      pointer-events: auto;
    }
    .zoom-meter {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      width: 100%;
      margin-inline: auto;
      pointer-events: auto;
      transition: transform 0.22s ease, opacity 0.22s ease;
      transform-origin: center top;
    }
    .zoom-meter.is-collapsed {
      opacity: 0.8;
      transform: translateY(6px) scaleY(0.74);
    }
    .zoom-meter.is-expanded {
      opacity: 1;
      transform: translateY(0) scaleY(1);
    }
    .zoom-meter__tape {
      position: relative;
      width: 100%;
      padding: 18px 12px;
      overflow: hidden;
      background: transparent;
      touch-action: none;
      cursor: ew-resize;
      user-select: none;
    }
    .zoom-meter.is-collapsed .zoom-meter__tape {
      padding: 12px 10px;
    }
    .zoom-meter__tape::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      background: rgba(231, 238, 255, 0.28);
      transform: translateY(-50%);
      pointer-events: none;
    }
    .zoom-meter__indicator {
      position: absolute;
      top: 8px;
      bottom: 8px;
      left: 50%;
      width: 2px;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(123, 207, 255, 0.55);
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 2;
    }
    .zoom-meter.is-collapsed .zoom-meter__indicator {
      top: 6px;
      bottom: 6px;
    }
    .zoom-meter.is-collapsed .zoom-meter__tape::before {
      background: rgba(231, 238, 255, 0.2);
    }
    .zoom-meter__scale {
      position: relative;
      overflow: hidden;
      width: 100%;
      pointer-events: none;
      mask-image: linear-gradient(90deg, transparent 0 4%, #000 20% 80%, transparent 96% 100%);
    }
    .zoom-meter__scale-track {
      display: inline-flex;
      align-items: center;
      gap: clamp(5px, 1.1vw, 9px);
      transform: translateX(0);
      transition: transform 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 6px 0;
      will-change: transform;
      pointer-events: none;
    }
    .zoom-meter__scale-track.is-static {
      transition: none;
    }
    .zoom-meter__scale-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 48px;
      font-size: 0.95rem;
      font-weight: 500;
      color: rgba(231, 238, 255, 0.55);
      position: relative;
      pointer-events: none;
      transition: transform 0.2s ease, color 0.2s ease;
    }
    .zoom-meter__scale-value::after {
      content: '';
      position: absolute;
      bottom: -12px;
      left: 50%;
      width: 2px;
      height: 8px;
      background: rgba(231, 238, 255, 0.28);
      transform: translateX(-50%);
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value {
      transform: scale(0.86);
      font-size: 0.85rem;
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value::after {
      height: 6px;
    }
    .zoom-meter__scale-value.is-active {
      color: var(--accent);
      font-weight: 600;
      transform: scale(1.12);
    }
    .zoom-meter__scale-value.is-active::after {
      height: 14px;
      background: var(--accent);
    }
    .zoom-meter__scale-value--major {
      font-size: 1.05rem;
      font-weight: 600;
      color: rgba(231, 238, 255, 0.85);
    }
    .zoom-meter__scale-value--major::after {
      height: 12px;
      width: 3px;
      background: rgba(231, 238, 255, 0.42);
    }
    .zoom-meter.is-collapsed .zoom-meter__scale-value--major {
      font-size: 0.94rem;
      transform: scale(0.95);
    }
    .zoom-meter__slider {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: default;
      -webkit-appearance: none;
      appearance: none;
      z-index: 3;
      pointer-events: none;
    }
    .zoom-meter__slider::-webkit-slider-thumb,
    .zoom-meter__slider::-moz-range-thumb,
    .zoom-meter__slider::-ms-thumb {
      width: 0;
      height: 0;
      appearance: none;
      -webkit-appearance: none;
      border: 0;
      background: transparent;
    }
    body.is-landscape .zoom-meter {
      width: clamp(320px, 36vw, 420px);
      margin-inline: auto;
    }
    body.is-landscape .hud-bottom__center {
      flex-direction: row;
      align-items: flex-end;
      justify-content: center;
      gap: 18px;
    }
    body.is-landscape .hud-bottom__center .zoom-meter {
      width: clamp(280px, 32vw, 360px);
      margin-inline: 0;
    }
    body.is-landscape .zoom-meter__tape {
      padding: 18px 16px;
    }
    .hud-bottom__menus {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
      pointer-events: auto;
    }
    .hud-bottom__menus > * {
      width: min(420px, 92vw);
    }
    .hud-top__actions {
      pointer-events: auto;
    }
    .capture-button {
      position: relative;
      width: clamp(64px, 19vw, 96px);
      height: clamp(64px, 19vw, 96px);
      border-radius: 50%;
      border: 3px solid rgba(123, 207, 255, 0.6);
      background: rgba(5, 9, 18, 0.75);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45), inset 0 0 18px rgba(123, 207, 255, 0.35);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease, background 0.18s ease;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    .capture-button:hover:enabled {
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.5), inset 0 0 22px rgba(123, 207, 255, 0.45);
      border-color: rgba(123, 207, 255, 0.8);
      background: rgba(12, 20, 36, 0.82);
    }
    .capture-button:active:enabled {
      transform: scale(0.96);
    }
    .capture-button:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.9);
      outline-offset: 4px;
    }
    .capture-button__icon {
      width: 64%;
      max-width: 72px;
      aspect-ratio: 1 / 1;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .capture-button__icon svg,
    .capture-button__icon img {
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      image-rendering: pixelated;
    }
    .stamp-panel {
      gap: 12px;
    }
    .stamp-panel__hint {
      margin: 0;
      font-size: 0.8rem;
      color: rgba(231, 238, 255, 0.7);
      letter-spacing: 0.04em;
      text-align: left;
    }
    .stamp-panel__grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
      gap: 4px;
    }
    .stamp-panel__empty {
      font-size: 0.8rem;
      color: rgba(231, 238, 255, 0.65);
      text-align: center;
      padding: 16px;
      border: 1px dashed rgba(123, 207, 255, 0.45);
      border-radius: 12px;
      letter-spacing: 0.06em;
    }
    .stamp-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 12px;
      background: transparent;
      border: none;
      color: inherit;
      aspect-ratio: 1 / 1;
      width: 100%;
      transition: transform 0.16s ease, background 0.16s ease;
    }
    .stamp-button.is-loading {
      opacity: 0.6;
      cursor: progress;
      transform: none;
    }
    .stamp-button:hover,
    .stamp-button:focus-visible {
      background: rgba(123, 207, 255, 0.14);
      transform: translateY(-1px);
      outline: none;
    }
    .stamp-button:active {
      transform: translateY(1px) scale(0.96);
    }
    .stamp-button__preview {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background: rgba(8, 13, 26, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px;
    }
    .stamp-button__preview img {
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 10px 16px;
      border-radius: 14px;
      background: rgba(5, 9, 18, 0.65);
      border: 1px solid rgba(123, 207, 255, 0.28);
      letter-spacing: 0.05em;
      font-size: 0.85rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .controls--aspect,
    .controls--dot-scale,
    .controls--color {
      gap: 10px;
      align-items: center;
    }
    .controls--dot-scale {
      justify-content: center;
    }
    button {
      border: none;
      cursor: pointer;
      background: none;
      color: inherit;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    button:disabled {
      cursor: not-allowed;
    }
    .icon-button {
      width: 56px;
      height: 56px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      background: rgba(123, 207, 255, 0.2);
      border: 1px solid rgba(123, 207, 255, 0.35);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.32);
      transition: transform 0.18s ease, background 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
      position: relative;
      color: var(--fg);
    }
    .icon-button:hover:enabled {
      transform: translateY(-1px);
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.55);
    }
    .icon-button:active:enabled {
      transform: translateY(1px);
    }
    .icon-button.is-active {
      background: rgba(123, 207, 255, 0.36);
      border-color: rgba(123, 207, 255, 0.75);
    }
    .icon-button:disabled {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: none;
      color: rgba(255, 255, 255, 0.5);
    }
    .option-button {
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 12px;
      background: rgba(5, 9, 18, 0.65);
      color: inherit;
      padding: 10px 16px;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
    }
    .option-button:hover,
    .option-button:focus-visible {
      background: rgba(123, 207, 255, 0.28);
      border-color: rgba(123, 207, 255, 0.55);
      outline: none;
    }
    .option-button.is-active {
      background: rgba(123, 207, 255, 0.4);
      border-color: rgba(123, 207, 255, 0.8);
      color: #050812;
    }
    .option-button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
    }
    .select-control {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }
    .select-control__label {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      color: rgba(231, 238, 255, 0.75);
    }
    .select-control select {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background: linear-gradient(150deg, rgba(123, 207, 255, 0.22), rgba(5, 9, 18, 0.88));
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 12px;
      padding: 12px 16px;
      font: inherit;
      color: inherit;
      letter-spacing: 0.08em;
      box-shadow: inset 0 0 18px rgba(123, 207, 255, 0.18);
      transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }
    .select-control select:hover {
      border-color: rgba(123, 207, 255, 0.55);
    }
    .select-control select:focus-visible {
      outline: 2px solid rgba(123, 207, 255, 0.85);
      outline-offset: 3px;
    }
    .select-control select:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    .dot-settings-panel {
      gap: 12px;
    }
    .dot-settings-panel__row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: center;
      gap: 12px;
    }
    .dot-settings-panel__row .select-control {
      flex: 1 1 160px;
      min-width: 140px;
    }
    .dot-settings-panel__row .palette-toggle {
      flex: 0 0 auto;
      align-self: stretch;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      padding: 10px 18px;
    }
    .camera-settings-panel {
      gap: 16px;
    }
    .controls--camera {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .slider-control__label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      color: rgba(231, 238, 255, 0.75);
    }
    .slider-control__value {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .slider-control input[type="range"] {
      width: 100%;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: rgba(123, 207, 255, 0.2);
      outline: none;
      box-shadow: inset 0 0 12px rgba(123, 207, 255, 0.22);
    }
    .slider-control input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      transition: transform 0.18s ease;
    }
    .slider-control input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(0.9);
    }
    .slider-control input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
    }
    .slider-control input[type="range"]::-ms-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(231, 238, 255, 0.95);
      border: 1px solid rgba(123, 207, 255, 0.55);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
    }
    .slider-control input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .slider-control input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .camera-settings__reset {
      align-self: flex-end;
      padding: 8px 16px;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
    }
    .control-icon {
      width: 26px;
      height: 26px;
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
    }
    .control-icon rect,
    .control-icon path {
      fill: currentColor;
      opacity: 0.88;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .pixel-preview {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 4;
    }
    .pixel-preview > * {
      pointer-events: auto;
    }
    .pixel-canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      border-radius: 12px;
      background: transparent;
    }
    .pixel-canvas-wrap {
      position: absolute;
      display: inline-block;
      margin: 0;
      pointer-events: auto;
      left: 24px;
      top: 24px;
      touch-action: none;
      cursor: move;
    }
    .pixel-canvas-wrap::after {
      content: '';
      position: absolute;
      inset: -6px;
      border: 2px dashed rgba(123, 207, 255, 0.6);
      border-radius: 10px;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
    }
    .menu-panel {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin-top: 14px;
      padding: 14px 16px;
      border-radius: 14px;
      background: rgba(5, 9, 18, 0.72);
      border: 1px solid rgba(123, 207, 255, 0.28);
      box-shadow: 0 22px 38px rgba(0, 0, 0, 0.35);
    }
    .menu-panel.is-open {
      display: flex;
    }
    .menu-panel > .controls {
      flex-wrap: wrap;
      gap: 10px;
    }
    .menu-panel > .controls .option-button {
      flex: 1 1 auto;
    }
    .palette-toggle {
      align-self: flex-start;
    }
    .palette-display {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px 14px;
      border: 1px solid rgba(123, 207, 255, 0.28);
      border-radius: 12px;
      background: rgba(5, 9, 18, 0.6);
    }
    .palette-display.is-visible {
      display: flex;
    }
    .palette-display__label {
      font-size: 0.8rem;
      letter-spacing: 0.04em;
      color: var(--muted);
      text-align: center;
    }
    .palette-display__swatches {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }
    .palette-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      cursor: pointer;
      transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
      outline: none;
      color: inherit;
      font: inherit;
      line-height: 0;
    }
    .palette-swatch:hover {
      border-color: rgba(123, 207, 255, 0.45);
      box-shadow: 0 0 0 2px rgba(123, 207, 255, 0.12);
      transform: translateY(-1px);
    }
    .palette-swatch:focus-visible {
      border-color: rgba(123, 207, 255, 0.65);
      box-shadow: 0 0 0 3px rgba(123, 207, 255, 0.28);
    }
    .palette-swatch--active {
      border-color: rgba(123, 207, 255, 0.75);
      box-shadow: 0 0 0 3px rgba(123, 207, 255, 0.32);
    }
    .palette-swatch__chip {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid rgba(0, 0, 0, 0.45);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      flex-shrink: 0;
    }
    .palette-editor {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.12);
    }
    .palette-editor[hidden] {
      display: none !important;
    }
    .palette-editor__header {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .palette-editor__preview {
      width: 36px;
      height: 36px;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      background: transparent;
      flex-shrink: 0;
    }
    .palette-editor__slider {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .palette-editor__label {
      font-size: 0.8rem;
      letter-spacing: 0.06em;
      color: rgba(231, 238, 255, 0.78);
    }
    .palette-editor__slider input[type="range"] {
      flex: 1 1 auto;
      accent-color: rgba(123, 207, 255, 0.75);
    }
    .palette-editor__value {
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: rgba(231, 238, 255, 0.85);
    }
    .palette-editor__reset {
      align-self: flex-end;
      border: 1px solid rgba(123, 207, 255, 0.35);
      border-radius: 10px;
      background: rgba(5, 9, 18, 0.6);
      color: inherit;
      font: inherit;
      padding: 6px 12px;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: border-color 0.18s ease, background 0.18s ease;
    }
    .palette-editor__reset:hover,
    .palette-editor__reset:focus-visible {
      border-color: rgba(123, 207, 255, 0.65);
      background: rgba(123, 207, 255, 0.18);
      outline: none;
    }
    .pixel-canvas-wrap.is-active::after {
      opacity: 1;
    }
    .pixel-canvas-wrap:not(.is-active) .pixel-handle {
      display: none;
    }
    .pixel-move-handle {
      position: absolute;
      top: -10px;
      left: calc(50% - 11px);
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid rgba(0, 0, 0, 0.65);
      background: rgba(123, 207, 255, 0.9);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
      padding: 0;
      display: block;
      pointer-events: auto;
      cursor: grab;
      touch-action: none;
      transition: transform 0.15s ease, background 0.2s ease, border-color 0.2s ease;
      transform-origin: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .pixel-canvas-wrap:not(.is-active) .pixel-move-handle {
      display: none;
    }
    .pixel-move-handle:hover {
      background: rgba(123, 207, 255, 1);
      border-color: rgba(123, 207, 255, 0.8);
    }
    .pixel-move-handle:active {
      cursor: grabbing;
      transform: scale(0.96);
    }
    .pixel-handle {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 2px solid rgba(0, 0, 0, 0.65);
      background: rgba(123, 207, 255, 0.9);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
      cursor: nwse-resize;
      padding: 0;
      transition: none;
    }
    .pixel-handle:hover,
    .pixel-handle:active {
      transform: none;
    }
    .pixel-handle--nw {
      top: -10px;
      left: -10px;
      cursor: nwse-resize;
    }
    .pixel-handle--ne {
      top: -10px;
      right: -10px;
      cursor: nesw-resize;
    }
    .pixel-handle--se {
      bottom: -10px;
      right: -10px;
      cursor: nwse-resize;
    }
    .pixel-handle--sw {
      bottom: -10px;
      left: -10px;
      cursor: nesw-resize;
    }
    @media (max-width: 640px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .hud-top__bar {
        flex-wrap: nowrap;
        align-items: flex-start;
        text-align: left;
        gap: 12px;
      }
      .hud-top__actions {
        justify-content: flex-start;
        flex-wrap: wrap;
      }
      .hud-top__actions--right {
        margin-left: auto;
        justify-content: flex-end;
        flex: 0 0 auto;
      }
      .hud-top__panel-wrap {
        justify-content: flex-start;
        width: 100%;
      }
      .hud-top__panel-wrap > * {
        width: 100%;
      }
      .hud-bottom__actions {
        gap: clamp(10px, 5vw, 16px);
      }
      .hud-bottom__actions-group {
        gap: clamp(8px, 4vw, 14px);
      }
      .hud-bottom__capture-slot {
        min-width: clamp(56px, 24vw, 84px);
        height: clamp(56px, 24vw, 84px);
      }
      .hud-bottom__center {
        width: clamp(220px, 70vw, 300px);
        margin-inline: auto;
      }
      .zoom-meter {
        width: 100%;
        gap: 12px;
      }
      .zoom-meter__tape {
        padding: 20px 14px;
      }
      .zoom-meter__scale-track {
        gap: clamp(14px, 8vw, 24px);
      }
      .zoom-meter__scale-value {
        min-width: 42px;
      }
      .hud-bottom__menus > * {
        width: 100%;
      }
      .pixel-canvas-wrap {
        left: clamp(16px, 4vw, 24px);
        top: clamp(16px, 4vw, 24px);
      }
    }
  </style>
</head>
  <body>
  <main>
    <video id="cameraFeed" autoplay muted playsinline></video>
    <canvas id="dotCanvas" class="dot-canvas" hidden></canvas>
    <div id="aspectOverlay" class="aspect-overlay" hidden>
      <div id="aspectShadeTop" class="aspect-shade" aria-hidden="true"></div>
      <div id="aspectCenter" class="aspect-middle" aria-hidden="true">
        <div id="aspectShadeLeft" class="aspect-side-shade"></div>
        <div id="aspectFrame" class="aspect-frame"></div>
        <div id="aspectShadeRight" class="aspect-side-shade"></div>
      </div>
      <div id="aspectShadeBottom" class="aspect-shade" aria-hidden="true"></div>
    </div>
    <div class="hud">
      <div class="hud-top">
        <div class="hud-top__bar">
          <div class="hud-top__actions" role="group" aria-label="ドット絵コントロール">
            <button id="pixelArtBtn" class="icon-button" type="button" aria-label="ドット絵を読み込む">
              <svg class="control-icon" viewBox="0 0 24 24" aria-hidden="true" shape-rendering="crispEdges" xmlns="http://www.w3.org/2000/svg">
                <rect x="1" y="0" width="14" height="1" fill="#FFFFFF"></rect>
                <rect x="0" y="1" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="14" y="1" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="0" y="2" width="1" height="21" fill="#FFFFFF"></rect>
                <rect x="15" y="2" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="16" y="3" width="7" height="1" fill="#FFFFFF"></rect>
                <rect x="22" y="4" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="23" y="5" width="1" height="18" fill="#FFFFFF"></rect>
                <rect x="1" y="9" width="22" height="1" fill="#FFFFFF"></rect>
                <rect x="1" y="10" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="22" y="10" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>
              </svg>
              <span class="icon-button__label visually-hidden">ドット絵を読み込む</span>
            </button>
            <button id="stampBtn" class="icon-button" type="button" aria-label="スタンプを開く" aria-expanded="false" aria-controls="stampPanel">
              <img src="./icon-stamp.svg" class="control-icon" alt="" aria-hidden="true" draggable="false">
              <span class="icon-button__label visually-hidden">スタンプを開く</span>
            </button>
            <button id="clearPixelBtn" class="icon-button icon-button--ghost" type="button" aria-label="ドット絵を閉じる">
              <svg class="control-icon" viewBox="0 0 24 24" aria-hidden="true" shape-rendering="crispEdges" xmlns="http://www.w3.org/2000/svg">
                <rect x="2" y="0" width="2" height="6" fill="#FFFFFF"></rect>
                <rect x="20" y="0" width="2" height="6" fill="#FFFFFF"></rect>
                <rect x="1" y="1" width="1" height="4" fill="#FFFFFF"></rect>
                <rect x="4" y="1" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="19" y="1" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="22" y="1" width="1" height="4" fill="#FFFFFF"></rect>
                <rect x="0" y="2" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="5" y="2" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="18" y="2" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="23" y="2" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="6" y="3" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="17" y="3" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="7" y="4" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="16" y="4" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="8" y="5" width="1" height="14" fill="#FFFFFF"></rect>
                <rect x="15" y="5" width="1" height="14" fill="#FFFFFF"></rect>
                <rect x="3" y="6" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="9" y="6" width="1" height="12" fill="#FFFFFF"></rect>
                <rect x="14" y="6" width="1" height="12" fill="#FFFFFF"></rect>
                <rect x="20" y="6" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="10" y="7" width="1" height="10" fill="#FFFFFF"></rect>
                <rect x="13" y="7" width="1" height="10" fill="#FFFFFF"></rect>
                <rect x="11" y="8" width="2" height="8" fill="#FFFFFF"></rect>
                <rect x="7" y="13" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="16" y="13" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="6" y="14" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="17" y="14" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="5" y="15" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="18" y="15" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="4" y="16" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="19" y="16" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="3" y="17" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="20" y="17" width="1" height="7" fill="#FFFFFF"></rect>
                <rect x="2" y="18" width="1" height="6" fill="#FFFFFF"></rect>
                <rect x="21" y="18" width="1" height="6" fill="#FFFFFF"></rect>
                <rect x="1" y="19" width="1" height="4" fill="#FFFFFF"></rect>
                <rect x="22" y="19" width="1" height="4" fill="#FFFFFF"></rect>
                <rect x="0" y="20" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="23" y="20" width="1" height="2" fill="#FFFFFF"></rect>
              </svg>
              <span class="icon-button__label visually-hidden">ドット絵を閉じる</span>
            </button>
          </div>
          <div class="hud-top__actions hud-top__actions--right" role="group" aria-label="カメラ操作">
            <button id="cameraActionBtn" class="icon-button" type="button" aria-label="再接続" data-mode="resume">
              <svg id="cameraActionIcon" class="control-icon" viewBox="0 0 24 24" aria-hidden="true" shape-rendering="crispEdges" xmlns="http://www.w3.org/2000/svg">
                <rect x="17" y="0" width="6" height="1" fill="#FFFFFF"></rect>
                <rect x="16" y="1" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="22" y="1" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="16" y="2" width="1" height="5" fill="#FFFFFF"></rect>
                <rect x="21" y="2" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="23" y="2" width="1" height="5" fill="#FFFFFF"></rect>
                <rect x="20" y="3" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="19" y="4" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="18" y="5" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="17" y="6" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="22" y="6" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="8" y="7" width="8" height="1" fill="#FFFFFF"></rect>
                <rect x="18" y="7" width="4" height="1" fill="#FFFFFF"></rect>
                <rect x="3" y="8" width="3" height="2" fill="#FFFFFF"></rect>
                <rect x="7" y="8" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="15" y="8" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="1" y="9" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="6" y="9" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="10" y="9" width="4" height="1" fill="#FFFFFF"></rect>
                <rect x="16" y="9" width="7" height="1" fill="#FFFFFF"></rect>
                <rect x="0" y="10" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="22" y="10" width="2" height="1" fill="#FFFFFF"></rect>
                <rect x="0" y="11" width="1" height="12" fill="#FFFFFF"></rect>
                <rect x="23" y="11" width="1" height="12" fill="#FFFFFF"></rect>
                <rect x="9" y="12" width="6" height="1" fill="#FFFFFF"></rect>
                <rect x="8" y="13" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="15" y="13" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="7" y="14" width="1" height="6" fill="#FFFFFF"></rect>
                <rect x="16" y="14" width="1" height="6" fill="#FFFFFF"></rect>
                <rect x="8" y="20" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="15" y="20" width="1" height="1" fill="#FFFFFF"></rect>
                <rect x="9" y="21" width="6" height="1" fill="#FFFFFF"></rect>
                <rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>
                <rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>
              </svg>
              <span class="icon-button__label visually-hidden">再接続</span>
            </button>
            <button id="cameraSettingsBtn" class="icon-button" type="button" aria-label="カメラ設定" aria-expanded="false" aria-controls="cameraSettingsPanel">
              <img src="./icon-setting.svg" class="control-icon" alt="" aria-hidden="true">
              <span class="icon-button__label visually-hidden">カメラ設定</span>
            </button>
          </div>
        </div>
        <div class="hud-top__panel-wrap hud-top__panel-wrap--left">
          <div id="stampPanel" class="menu-panel stamp-panel" hidden>
            <p class="stamp-panel__hint">スタンプを選択すると画面に追加されます。</p>
            <div id="stampList" class="stamp-panel__grid" role="group" aria-label="スタンプ一覧"></div>
            <p id="stampEmptyMessage" class="stamp-panel__empty" hidden>スタンプがまだ登録されていません。</p>
          </div>
        </div>
        <div class="hud-top__panel-wrap hud-top__panel-wrap--right">
          <div id="cameraSettingsPanel" class="menu-panel camera-settings-panel" hidden>
            <div class="controls controls--camera" role="group" aria-label="カメラ基本設定">
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">明るさ</span>
                  <span class="slider-control__value" data-setting-value="brightness">0</span>
                </span>
                <input id="cameraSettingBrightness" type="range" min="-100" max="100" step="1" value="0" data-setting="brightness">
              </label>
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">露光</span>
                  <span class="slider-control__value" data-setting-value="exposure">0</span>
                </span>
                <input id="cameraSettingExposure" type="range" min="-100" max="100" step="1" value="0" data-setting="exposure">
              </label>
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">彩度</span>
                  <span class="slider-control__value" data-setting-value="saturation">0</span>
                </span>
                <input id="cameraSettingSaturation" type="range" min="-100" max="100" step="1" value="0" data-setting="saturation">
              </label>
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">シャドウ</span>
                  <span class="slider-control__value" data-setting-value="shadows">0</span>
                </span>
                <input id="cameraSettingShadows" type="range" min="-100" max="100" step="1" value="0" data-setting="shadows">
              </label>
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">コントラスト</span>
                  <span class="slider-control__value" data-setting-value="contrast">0</span>
                </span>
                <input id="cameraSettingContrast" type="range" min="-100" max="100" step="1" value="0" data-setting="contrast">
              </label>
              <label class="slider-control">
                <span class="slider-control__label-row">
                  <span class="slider-control__label">ホワイトバランス</span>
                  <span class="slider-control__value" data-setting-value="whiteBalance">0</span>
                </span>
                <input id="cameraSettingWhiteBalance" type="range" min="-100" max="100" step="1" value="0" data-setting="whiteBalance">
              </label>
            </div>
            <button id="cameraSettingsResetBtn" class="option-button camera-settings__reset" type="button">設定をリセット</button>
          </div>
        </div>
      </div>
      <div class="hud-bottom">
        <div class="hud-bottom__menus">
          <div id="aspectMenu" class="menu-panel" hidden>
            <div class="controls controls--aspect" role="group" aria-label="アスペクト比">
              <button class="option-button is-active" type="button" data-aspect="3:2" aria-pressed="true">3:2</button>
              <button class="option-button" type="button" data-aspect="1:1" aria-pressed="false">1:1</button>
              <button class="option-button" type="button" data-aspect="4:3" aria-pressed="false">4:3</button>
              <button class="option-button" type="button" data-aspect="16:9" aria-pressed="false">16:9</button>
            </div>
          </div>
          <div id="dotSettingsPanel" class="menu-panel dot-settings-panel" hidden>
            <div class="dot-settings-panel__row">
              <label for="dotScaleSelect" class="select-control">
                <span class="select-control__label">ドット拡大率</span>
                <select id="dotScaleSelect" name="dotScale">
                  <option value="1">x1</option>
                  <option value="2">x2</option>
                  <option value="3">x3</option>
                  <option value="4">x4</option>
                </select>
              </label>
              <label for="colorDepthSelect" class="select-control">
                <span class="select-control__label">色数</span>
                <select id="colorDepthSelect" name="colorDepth">
                  <option value="full">フルカラー</option>
                  <option value="gray">グレースケール</option>
                  <option value="4" selected>4色</option>
                  <option value="2">2色</option>
                </select>
              </label>
              <button id="paletteToggleBtn" class="option-button palette-toggle" type="button" aria-pressed="false" aria-label="パレットを表示">パレット</button>
            </div>
            <div id="paletteDisplay" class="palette-display" aria-hidden="true"></div>
          </div>
        </div>
      <div class="hud-bottom__actions" role="group" aria-label="操作">
        <div class="hud-bottom__actions-group hud-bottom__actions-group--left">
          <button id="dotModeBtn" class="icon-button" type="button" aria-label="ドット設定を開く" aria-pressed="true">
            <img src="./icon-dotmode.svg" class="control-icon" alt="" aria-hidden="true" draggable="false">
            <span class="icon-button__label visually-hidden">ドット設定</span>
          </button>
        </div>
        <div class="hud-bottom__center">
          <div id="zoomControl" class="zoom-meter is-collapsed" hidden>
            <div class="zoom-meter__tape">
              <div class="zoom-meter__indicator" aria-hidden="true"></div>
              <div class="zoom-meter__scale" aria-hidden="true">
                <div class="zoom-meter__scale-track"></div>
              </div>
              <input id="cameraZoomSlider" class="zoom-meter__slider" type="range" min="0" max="100" step="1" value="0" aria-label="ズーム倍率" data-setting="zoom">
            </div>
          </div>
          <div class="hud-bottom__capture-slot">
            <button id="captureBtn" class="capture-button" type="button" aria-label="撮影">
              <img src="./icon-capture.svg" class="capture-button__icon" alt="" aria-hidden="true" draggable="false">
            </button>
          </div>
        </div>
        <div class="hud-bottom__actions-group hud-bottom__actions-group--right">
          <button id="aspectMenuBtn" class="icon-button" type="button" aria-expanded="false" aria-controls="aspectMenu" aria-label="キャンバスサイズを選択">
            <img src="./icon-aspect.svg" class="control-icon" alt="" aria-hidden="true">
            <span class="icon-button__label visually-hidden">キャンバスサイズ</span>
          </button>
        </div>
      </div>
      <div class="hud-landscape-capture" aria-hidden="true"></div>
    </div>
    <div id="pixelPreview" class="pixel-preview" hidden></div>
  </main>
  <input id="pixelArtInput" type="file" accept="image/png, image/gif, image/webp, image/bmp" multiple hidden>
  <script>
    const video = document.getElementById('cameraFeed');
    const cameraActionBtn = document.getElementById('cameraActionBtn');
    const cameraActionIcon = document.getElementById('cameraActionIcon');
    const cameraSettingsBtn = document.getElementById('cameraSettingsBtn');
    const cameraSettingsPanel = document.getElementById('cameraSettingsPanel');
    const cameraSettingsResetBtn = document.getElementById('cameraSettingsResetBtn');
    const stampBtn = document.getElementById('stampBtn');
    const stampPanel = document.getElementById('stampPanel');
    const stampList = document.getElementById('stampList');
    const stampEmptyMessage = document.getElementById('stampEmptyMessage');
    const pixelArtBtn = document.getElementById('pixelArtBtn');
    const clearPixelBtn = document.getElementById('clearPixelBtn');
    const dotModeBtn = document.getElementById('dotModeBtn');
    const captureBtn = document.getElementById('captureBtn');
    const aspectMenuBtn = document.getElementById('aspectMenuBtn');
    const pixelArtInput = document.getElementById('pixelArtInput');
    const pixelPreview = document.getElementById('pixelPreview');
    const landscapeCaptureSlot = document.querySelector('.hud-landscape-capture');
    const captureButtonOriginalParent = captureBtn ? captureBtn.parentElement : null;
    const cameraSettingSliders = cameraSettingsPanel ? Array.from(cameraSettingsPanel.querySelectorAll('input[data-setting]')) : [];
    const cameraSettingValueEls = new Map();
    if (cameraSettingsPanel) {
      Array.from(cameraSettingsPanel.querySelectorAll('[data-setting-value]')).forEach((element) => {
        const key = element.dataset.settingValue;
        if (key) {
          cameraSettingValueEls.set(key, element);
        }
      });
    }
    const zoomControl = document.getElementById('zoomControl');
    const zoomSlider = document.getElementById('cameraZoomSlider');
    const zoomMeterTape = zoomControl ? zoomControl.querySelector('.zoom-meter__tape') : null;
    const zoomScaleWrapper = zoomControl ? zoomControl.querySelector('.zoom-meter__scale') : null;
    const zoomScaleTrack = zoomScaleWrapper ? zoomScaleWrapper.querySelector('.zoom-meter__scale-track') : null;
    const ZOOM_MARK_STEP = 0.5;
    const ZOOM_FALLBACK_MIN = 1;
    const ZOOM_FALLBACK_MAX = 8;
    const ZOOM_MAJOR_EPSILON = 1e-3;
    let zoomScaleItems = [];
    let zoomScaleMarks = [];
    let zoomScaleTranslate = 0;
    let zoomMeterLastAppliedIndex = -1;
    const zoomMeterDrag = {
      active: false,
      pointerId: null,
      startClientX: 0,
      startTranslate: 0,
      samples: []
    };
    const zoomMeterInertia = {
      active: false,
      frameId: 0,
      velocity: 0,
      lastTimestamp: 0
    };
    let zoomMeterCollapseTimeout = null;
    if (zoomSlider && !cameraSettingSliders.includes(zoomSlider)) {
      cameraSettingSliders.push(zoomSlider);
    }
    if (zoomSlider) {
      zoomSlider.addEventListener('focus', () => {
        setZoomMeterExpanded(true);
        if (zoomMeterCollapseTimeout) {
          clearTimeout(zoomMeterCollapseTimeout);
          zoomMeterCollapseTimeout = null;
        }
      });
      zoomSlider.addEventListener('blur', () => {
        scheduleZoomMeterCollapse(700);
      });
      zoomSlider.addEventListener('keydown', (event) => {
        if (event.key === 'Tab') {
          setZoomMeterExpanded(false);
        }
      });
      zoomSlider.addEventListener('change', () => {
        scheduleZoomMeterCollapse(600);
      });
    }
    if (zoomMeterTape) {
      zoomMeterTape.addEventListener('pointerdown', handleZoomMeterPointerDown);
    }
    const dotCanvas = document.getElementById('dotCanvas');
    const dotCanvasCtx = dotCanvas ? dotCanvas.getContext('2d', { willReadFrequently: true }) : null;
    const smoothingCanvas = dotCanvas ? document.createElement('canvas') : null;
    const smoothingCtx = smoothingCanvas ? smoothingCanvas.getContext('2d', { willReadFrequently: true }) : null;
    const aspectOverlay = document.getElementById('aspectOverlay');
    const aspectFrame = document.getElementById('aspectFrame');
    const aspectCenter = document.getElementById('aspectCenter');
    const aspectShadeTop = document.getElementById('aspectShadeTop');
    const aspectShadeBottom = document.getElementById('aspectShadeBottom');
    const aspectShadeLeft = document.getElementById('aspectShadeLeft');
    const aspectShadeRight = document.getElementById('aspectShadeRight');
    const aspectMenu = document.getElementById('aspectMenu');
    const hudTopBar = document.querySelector('.hud-top__bar');
    const aspectButtons = Array.from(document.querySelectorAll('.option-button[data-aspect]'));
    const dotSettingsPanel = document.getElementById('dotSettingsPanel');
    const paletteToggleBtn = document.getElementById('paletteToggleBtn');
    const paletteDisplay = document.getElementById('paletteDisplay');
    const dotScaleSelect = document.getElementById('dotScaleSelect');
    const colorDepthSelect = document.getElementById('colorDepthSelect');

    if (paletteDisplay) {
      ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
        paletteDisplay.addEventListener(type, (event) => event.stopPropagation());
      });
    }
    if (stampPanel) {
      ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
        stampPanel.addEventListener(type, (event) => event.stopPropagation());
      });
    }

    function preventBrowserZoom(event) {
      if (event.ctrlKey || event.metaKey) {
        event.preventDefault();
      }
    }

    window.addEventListener('wheel', preventBrowserZoom, { passive: false });
    window.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && ['=', '+', '-', '_', '0', 'Add', 'Subtract'].includes(event.key)) {
        event.preventDefault();
      }
    }, { passive: false });
    window.addEventListener('gesturestart', (event) => {
      event.preventDefault();
    });

    if (!dotCanvasCtx) {
      if (dotModeBtn) {
        dotModeBtn.disabled = true;
        dotModeBtn.setAttribute('aria-disabled', 'true');
        dotModeBtn.title = 'ドット設定はこのブラウザで利用できません';
      }
      setSelectEnabled(dotScaleSelect, false);
      setSelectEnabled(colorDepthSelect, false);
      if (paletteToggleBtn) {
        paletteToggleBtn.disabled = true;
        paletteToggleBtn.setAttribute('aria-disabled', 'true');
      }
    } else {
      setSelectEnabled(dotScaleSelect, true);
      setSelectEnabled(colorDepthSelect, true);
      if (dotModeBtn) {
        dotModeBtn.disabled = false;
        dotModeBtn.removeAttribute('aria-disabled');
        dotModeBtn.removeAttribute('title');
      }
      if (paletteToggleBtn) {
        paletteToggleBtn.disabled = false;
        paletteToggleBtn.removeAttribute('aria-disabled');
      }
    }

    const CAMERA_SETTING_CONFIG = Object.freeze({
      brightness: { min: -100, max: 100, step: 1, default: 0 },
      exposure: { min: -100, max: 100, step: 1, default: 0 },
      saturation: { min: -100, max: 100, step: 1, default: 0 },
      shadows: { min: -100, max: 100, step: 1, default: 0 },
      contrast: { min: -100, max: 100, step: 1, default: 0 },
      whiteBalance: { min: -100, max: 100, step: 1, default: 0 },
      zoom: { min: 0, max: 100, step: 1, default: 0 }
    });
    const CAMERA_SETTING_KEYS = Object.freeze(Object.keys(CAMERA_SETTING_CONFIG));
    const CAMERA_SETTING_DEFAULTS = Object.freeze(
      CAMERA_SETTING_KEYS.reduce((accumulator, key) => {
        const config = CAMERA_SETTING_CONFIG[key] || {};
        const defaultValue = Number(config.default);
        accumulator[key] = Number.isFinite(defaultValue) ? defaultValue : 0;
        return accumulator;
      }, {})
    );
    const CAMERA_BASE_SATURATION = 1.05;
    const CAMERA_TRACK_CAPABILITY_MAP = {
      brightness: 'brightness',
      exposure: 'exposureCompensation',
      saturation: 'saturation',
      contrast: 'contrast',
      whiteBalance: 'colorTemperature',
      zoom: 'zoom'
    };
    const STAMP_LIBRARY = Object.freeze([
      { id: 'sparkle', label: 'スパークル', src: './stamps/sparkle.png' },
      { id: 'frame', label: 'フレーム', src: './stamps/frame.png' },
      { id: 'heart', label: 'ハート', src: './stamps/heart.png' },
      { id: 'megane', label: 'メガネ', src: './stamps/st-megane.png' }
    ]);

    const state = {
      stream: null,
      useFrontCamera: false,
      restarting: false,
      aspectMode: '3:2',
      dotMode: true,
      dotScale: 1,
      colorDepth: '4',
      cameraSettings: { ...CAMERA_SETTING_DEFAULTS }
    };

    const overlays = [];
    let activeOverlay = null;

    const interactionState = {
      dragOverlay: null,
      resizeOverlay: null,
      listenersAttached: false
    };

    let cameraZoomCapability = null;
    let cameraZoomCapabilityKnown = false;
    let cameraStatusMessage = '';
    let dotScalePanelOpen = false;
    const dotState = {
      frameHandle: null,
      width: 0,
      height: 0,
      layout: {
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0,
        mode: 'contain'
      }
    };

    let cameraPermissionDenied = false;
    let cameraReady = false;
    let captureInProgress = false;

    const menus = {
      aspect: { button: aspectMenuBtn, panel: aspectMenu },
      stamps: { button: stampBtn, panel: stampPanel },
      cameraSettings: { button: cameraSettingsBtn, panel: cameraSettingsPanel }
    };
    let openMenuKey = null;

    let currentCameraFilterString = '';
    let cameraConstraintsFrameScheduled = false;
    let cameraConstraintErrorLogged = false;

    function getCameraSettingConfig(key) {
      return CAMERA_SETTING_CONFIG[key] || null;
    }

    function getCameraSettingRange(key) {
      const config = getCameraSettingConfig(key);
      const min = config && Number.isFinite(config.min) ? Number(config.min) : -100;
      const max = config && Number.isFinite(config.max) ? Number(config.max) : 100;
      if (max < min) {
        return { min: max, max: min };
      }
      return { min, max };
    }

    function clampCameraSettingValue(value, key) {
      const config = getCameraSettingConfig(key);
      const { min, max } = getCameraSettingRange(key);
      const step = config && Number.isFinite(config.step) && config.step > 0 ? Number(config.step) : null;
      let numeric = Number(value);
      if (!Number.isFinite(numeric)) {
        const fallback = config && Number.isFinite(config.default) ? Number(config.default) : 0;
        numeric = fallback;
      }
      if (numeric < min) {
        numeric = min;
      } else if (numeric > max) {
        numeric = max;
      }
      if (step) {
        numeric = min + Math.round((numeric - min) / step) * step;
        if (numeric < min) {
          numeric = min;
        } else if (numeric > max) {
          numeric = max;
        }
      }
      return Number(Number.isFinite(numeric) ? numeric : min);
    }

    function getCameraSettingRatio(value, key) {
      const { min, max } = getCameraSettingRange(key);
      const clamped = clampCameraSettingValue(value, key);
      if (max <= min) {
        return 0;
      }
      const ratio = (clamped - min) / (max - min);
      return Math.min(1, Math.max(0, Number.isFinite(ratio) ? ratio : 0));
    }

    function getSliderValueFromRatio(ratio, key) {
      const { min, max } = getCameraSettingRange(key);
      const normalized = Math.min(1, Math.max(0, Number.isFinite(ratio) ? ratio : 0));
      return clampCameraSettingValue(min + (max - min) * normalized, key);
    }

    function getZoomDisplayValue(value) {
      const ratio = getCameraSettingRatio(value, 'zoom');
      if (cameraZoomCapability) {
        if (Array.isArray(cameraZoomCapability)) {
          if (!cameraZoomCapability.length) {
            return null;
          }
          const index = Math.min(
            cameraZoomCapability.length - 1,
            Math.max(0, Math.round(ratio * (cameraZoomCapability.length - 1)))
          );
          const option = Number(cameraZoomCapability[index]);
          return Number.isFinite(option) ? option : null;
        }
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          let mapped = min + (max - min) * ratio;
          const step = Number(cameraZoomCapability.step);
          if (Number.isFinite(step) && step > 0) {
            mapped = min + Math.round((mapped - min) / step) * step;
          }
          if (mapped < min) {
            mapped = min;
          } else if (mapped > max) {
            mapped = max;
          }
          return mapped;
        }
      }
      const fallbackMin = 1;
      const fallbackMax = 4;
      return fallbackMin + (fallbackMax - fallbackMin) * ratio;
    }

    function formatZoomDisplay(value) {
      const zoomValue = getZoomDisplayValue(value);
      if (!Number.isFinite(zoomValue)) {
        return `${clampCameraSettingValue(value, 'zoom')}%`;
      }
      const formatted = zoomValue.toFixed(2).replace(/\.?0+$/, '');
      return `${formatted}x`;
    }

    function formatZoomScaleLabel(value) {
      if (!Number.isFinite(value)) {
        return '';
      }
      const decimals = value < 10 ? 2 : 1;
      let formatted = value.toFixed(decimals);
      formatted = formatted.replace(/(\.\d*?)0+$/, '$1');
      formatted = formatted.replace(/\.$/, '.0');
      if (!formatted.includes('.')) {
        formatted = `${formatted}.0`;
      }
      return formatted;
    }

    function setZoomMeterExpanded(expanded) {
      if (!zoomControl) {
        return;
      }
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
        zoomMeterCollapseTimeout = null;
      }
      if (expanded) {
        zoomControl.classList.add('is-expanded');
        zoomControl.classList.remove('is-collapsed');
      } else {
        zoomControl.classList.add('is-collapsed');
        zoomControl.classList.remove('is-expanded');
      }
    }

    function scheduleZoomMeterCollapse(delay = 400) {
      if (!zoomControl || zoomControl.hidden) {
        return;
      }
      if (zoomMeterInertia.active) {
        return;
      }
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
      }
      zoomMeterCollapseTimeout = window.setTimeout(() => {
        zoomMeterCollapseTimeout = null;
        setZoomMeterExpanded(false);
      }, Math.max(0, delay));
    }

    function formatCameraSettingValue(value, key) {
      const clamped = clampCameraSettingValue(value, key);
      if (key === 'zoom') {
        if (!cameraZoomCapabilityKnown) {
          return '---';
        }
        if (!cameraZoomCapability) {
          return '未対応';
        }
        return formatZoomDisplay(clamped);
      }
      return clamped > 0 ? `+${clamped}` : `${clamped}`;
    }

    function updateCameraSettingDisplay(key) {
      if (!state.cameraSettings || !Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
        return;
      }
      const element = cameraSettingValueEls.get(key);
      if (element) {
        const value = state.cameraSettings[key] ?? 0;
        element.textContent = formatCameraSettingValue(value, key);
      }
    }

    function syncCameraSettingInputs() {
      cameraSettingSliders.forEach((slider) => {
        const key = slider.dataset.setting;
        if (!key) {
          return;
        }
        const value = state.cameraSettings[key] ?? 0;
        slider.value = String(value);
        slider.setAttribute('aria-valuenow', String(value));
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(value, key));
        if (key === 'zoom') {
          refreshZoomMeterVisuals(value);
        }
      });
    }

    function clampFilterFactor(value, min = 0.2, max = 3) {
      if (!Number.isFinite(value)) {
        return 1;
      }
      return Math.min(max, Math.max(min, value));
    }

    function computeCameraFilterComponents(settings = state.cameraSettings) {
      if (!settings) {
        return [
          'brightness(1.000)',
          'contrast(1.000)',
          `saturate(${CAMERA_BASE_SATURATION.toFixed(3)})`
        ];
      }
      const brightnessValue = clampCameraSettingValue(settings.brightness ?? 0, 'brightness') / 100;
      const exposureValue = clampCameraSettingValue(settings.exposure ?? 0, 'exposure') / 100;
      const saturationValue = clampCameraSettingValue(settings.saturation ?? 0, 'saturation') / 100;
      const shadowValue = clampCameraSettingValue(settings.shadows ?? 0, 'shadows') / 100;
      const contrastValue = clampCameraSettingValue(settings.contrast ?? 0, 'contrast') / 100;
      const whiteBalanceValue = clampCameraSettingValue(settings.whiteBalance ?? 0, 'whiteBalance') / 100;

      const brightnessFactor = clampFilterFactor(1 + brightnessValue * 0.6, 0.2, 3);
      const exposureFactor = clampFilterFactor(1 + exposureValue * 0.9, 0.2, 3);
      const saturationFactor = clampFilterFactor(1 + saturationValue, 0.1, 3);
      const shadowContrastFactor = clampFilterFactor(1 + shadowValue * 0.6, 0.2, 3);
      const userContrastFactor = clampFilterFactor(1 + contrastValue, 0.2, 4);
      const combinedContrast = clampFilterFactor(userContrastFactor * shadowContrastFactor, 0.2, 4);

      const combinedBrightness = clampFilterFactor(brightnessFactor * exposureFactor, 0.2, 3);
      const combinedSaturation = clampFilterFactor(CAMERA_BASE_SATURATION * saturationFactor, 0.05, 4);

      const components = [
        `brightness(${combinedBrightness.toFixed(3)})`,
        `contrast(${combinedContrast.toFixed(3)})`,
        `saturate(${combinedSaturation.toFixed(3)})`
      ];

      const whiteBalanceFilters = computeWhiteBalanceFilters(whiteBalanceValue);
      if (whiteBalanceFilters.length) {
        components.push(...whiteBalanceFilters);
      }

      return components;
    }

    function computeWhiteBalanceFilters(value) {
      if (!Number.isFinite(value) || Math.abs(value) < 0.001) {
        return [];
      }
      const filters = [];
      const clamped = Math.max(-1, Math.min(1, value));
      const warm = clamped > 0;
      const intensity = Math.abs(clamped);
      const hueRotate = warm ? intensity * 12 : -intensity * 12;
      filters.push(`hue-rotate(${hueRotate.toFixed(3)}deg)`);
      const saturateFactor = clampFilterFactor(1 + intensity * 0.25 * (warm ? 1 : -0.5), 0.4, 2.5);
      filters.push(`saturate(${saturateFactor.toFixed(3)})`);
      if (warm) {
        const sepia = Math.min(0.35, intensity * 0.45);
        if (sepia > 0.001) {
          filters.push(`sepia(${sepia.toFixed(3)})`);
        }
        const brighten = clampFilterFactor(1 + intensity * 0.08, 0.5, 1.5);
        filters.push(`brightness(${brighten.toFixed(3)})`);
      } else {
        const coolBrightness = clampFilterFactor(1 + intensity * -0.08, 0.5, 1.5);
        filters.push(`brightness(${coolBrightness.toFixed(3)})`);
      }
      return filters;
    }

    function updateCameraFilters() {
      const components = computeCameraFilterComponents();
      currentCameraFilterString = components.join(' ');
      if (video) {
        video.style.filter = currentCameraFilterString;
      }
    }

    function scheduleCameraSettingsConstraintUpdate() {
      if (cameraConstraintsFrameScheduled) {
        return;
      }
      cameraConstraintsFrameScheduled = true;
      requestAnimationFrame(() => {
        cameraConstraintsFrameScheduled = false;
        void applyCameraSettingsToTrack();
      });
    }

    function applyCameraSettings() {
      updateCameraFilters();
      scheduleCameraSettingsConstraintUpdate();
    }

    function setCameraSettingValue(key, rawValue, { syncInput = false } = {}) {
      if (!state.cameraSettings || !Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
        return;
      }
      const value = clampCameraSettingValue(Number(rawValue), key);
      if (state.cameraSettings[key] === value) {
        updateCameraSettingDisplay(key);
        if (syncInput) {
          syncCameraSettingInputs();
        }
        return;
      }
      state.cameraSettings[key] = value;
      updateCameraSettingDisplay(key);
      if (key === 'zoom') {
        refreshZoomMeterVisuals(value);
      }
      if (syncInput) {
        syncCameraSettingInputs();
      }
      applyCameraSettings();
    }

    function resetCameraSettings() {
      CAMERA_SETTING_KEYS.forEach((key) => {
        const defaultValue = CAMERA_SETTING_DEFAULTS[key] ?? 0;
        state.cameraSettings[key] = clampCameraSettingValue(defaultValue, key);
        updateCameraSettingDisplay(key);
      });
      syncCameraSettingInputs();
      updateZoomSliderAvailability();
      applyCameraSettings();
    }

    function initializeCameraSettingsUI() {
      CAMERA_SETTING_KEYS.forEach((key) => {
        if (!Object.prototype.hasOwnProperty.call(state.cameraSettings, key)) {
          state.cameraSettings[key] = clampCameraSettingValue(CAMERA_SETTING_DEFAULTS[key] ?? 0, key);
        }
        updateCameraSettingDisplay(key);
      });
      syncCameraSettingInputs();
      updateCameraFilters();
      updateZoomSliderAvailability();
    }

    function getActiveVideoTrack() {
      if (!state.stream || typeof state.stream.getVideoTracks !== 'function') {
        return null;
      }
      const tracks = state.stream.getVideoTracks();
      if (!tracks || !tracks.length) {
        return null;
      }
      return tracks[0] || null;
    }

    function mapSliderValueToCapability(value, capability, key) {
      if (capability == null) {
        return null;
      }
      const ratio = getCameraSettingRatio(value, key);
      if (Array.isArray(capability)) {
        if (!capability.length) {
          return null;
        }
        if (capability.length === 1) {
          const single = Number(capability[0]);
          return Number.isFinite(single) ? single : capability[0];
        }
        const index = Math.min(capability.length - 1, Math.max(0, Math.round(ratio * (capability.length - 1))));
        const candidate = capability[index];
        const numericCandidate = Number(candidate);
        return Number.isFinite(numericCandidate) ? numericCandidate : candidate;
      }
      const min = Number(capability.min);
      const max = Number(capability.max);
      if (!Number.isFinite(min) || !Number.isFinite(max)) {
        return null;
      }
      if (min === max) {
        return min;
      }
      const step = Number(capability.step);
      let mapped = min + (max - min) * ratio;
      if (Number.isFinite(step) && step > 0) {
        mapped = min + Math.round((mapped - min) / step) * step;
      }
      if (mapped > max) {
        mapped = max;
      } else if (mapped < min) {
        mapped = min;
      }
      return mapped;
    }

    function mapCapabilityValueToSlider(value, capability, key) {
      if (capability == null) {
        return clampCameraSettingValue(value, key);
      }
      const numericValue = Number(value);
      if (!Number.isFinite(numericValue)) {
        return clampCameraSettingValue(value, key);
      }
      if (Array.isArray(capability)) {
        if (!capability.length) {
          return clampCameraSettingValue(value, key);
        }
        const finiteValues = capability
          .map((entry) => Number(entry))
          .filter((entry) => Number.isFinite(entry))
          .sort((a, b) => a - b);
        if (!finiteValues.length) {
          return clampCameraSettingValue(value, key);
        }
        const min = finiteValues[0];
        const max = finiteValues[finiteValues.length - 1];
        if (max <= min) {
          return clampCameraSettingValue(value, key);
        }
        let closest = finiteValues[0];
        let minDiff = Math.abs(numericValue - closest);
        for (let index = 1; index < finiteValues.length; index += 1) {
          const candidate = finiteValues[index];
          const diff = Math.abs(candidate - numericValue);
          if (diff < minDiff) {
            minDiff = diff;
            closest = candidate;
          }
        }
        const ratio = (closest - min) / (max - min);
        return getSliderValueFromRatio(ratio, key);
      }
      const min = Number(capability.min);
      const max = Number(capability.max);
      if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
        return clampCameraSettingValue(value, key);
      }
      const ratio = (numericValue - min) / (max - min);
      return getSliderValueFromRatio(ratio, key);
    }

    function syncZoomStateFromTrack(track) {
      if (!track || typeof track.getSettings !== 'function') {
        return;
      }
      if (!cameraZoomCapability) {
        return;
      }
      let settings;
      try {
        settings = track.getSettings();
      } catch (error) {
        return;
      }
      if (!settings || !Number.isFinite(settings.zoom)) {
        return;
      }
      const sliderValue = mapCapabilityValueToSlider(settings.zoom, cameraZoomCapability, 'zoom');
      if (!Number.isFinite(sliderValue)) {
        return;
      }
      const clamped = clampCameraSettingValue(sliderValue, 'zoom');
      if (state.cameraSettings.zoom === clamped) {
        return;
      }
      state.cameraSettings.zoom = clamped;
      syncCameraSettingInputs();
      updateZoomSliderAvailability();
    }

    function refreshZoomMeterVisuals(value = state.cameraSettings.zoom ?? 0) {
      if (!zoomControl || zoomControl.hidden) {
        return;
      }
      if (zoomMeterDrag.active) {
        updateZoomScaleActiveFromLayout({ commit: false });
        return;
      }
      updateZoomScaleDisplay(value);
    }

    function roundZoomValue(value, precision = 2) {
      if (!Number.isFinite(value)) {
        return 0;
      }
      const factor = 10 ** precision;
      return Math.round(value * factor) / factor;
    }

    function isMajorZoomValue(value) {
      if (!Number.isFinite(value)) {
        return false;
      }
      return Math.abs(value - Math.round(value)) < ZOOM_MAJOR_EPSILON;
    }

    function generateZoomMarks(min, max, step = ZOOM_MARK_STEP) {
      let effectiveMin = Number.isFinite(min) ? Math.max(min, ZOOM_FALLBACK_MIN) : ZOOM_FALLBACK_MIN;
      let effectiveMax = Number.isFinite(max) ? Math.max(effectiveMin, max) : ZOOM_FALLBACK_MAX;
      effectiveMin = roundZoomValue(effectiveMin);
      effectiveMax = roundZoomValue(effectiveMax);
      const adjustedStep = Number.isFinite(step) && step > 0 ? step : ZOOM_MARK_STEP;
      const marks = new Set();
      const epsilon = 1e-6;
      let current = effectiveMin;
      while (current <= effectiveMax + epsilon) {
        marks.add(roundZoomValue(current));
        current += adjustedStep;
      }
      if (!marks.size) {
        marks.add(ZOOM_FALLBACK_MIN);
        marks.add(ZOOM_FALLBACK_MAX);
      }
      return Array.from(marks).sort((a, b) => a - b);
    }

    function computeZoomScaleMarks() {
      if (Array.isArray(cameraZoomCapability) && cameraZoomCapability.length) {
        const unique = Array.from(
          new Set(
            cameraZoomCapability
              .map((entry) => Number(entry))
              .filter((entry) => Number.isFinite(entry))
          )
        ).sort((a, b) => a - b);
        if (unique.length >= 2) {
          const min = unique[0];
          const max = unique[unique.length - 1];
          return generateZoomMarks(min, max);
        }
      }
      if (cameraZoomCapability && typeof cameraZoomCapability === 'object') {
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          return generateZoomMarks(min, max);
        }
      }
      return generateZoomMarks(ZOOM_FALLBACK_MIN, ZOOM_FALLBACK_MAX);
    }

    function updateZoomScaleOptions() {
      if (!zoomScaleTrack) {
        zoomScaleMarks = [];
        zoomScaleItems = [];
        return;
      }
      const nextMarks = computeZoomScaleMarks();
      const hasChanged =
        nextMarks.length !== zoomScaleMarks.length ||
        nextMarks.some((mark, index) => Math.abs((zoomScaleMarks[index] ?? Number.NaN) - mark) > 0.0001);
      zoomScaleMarks = nextMarks;
      if (!hasChanged && zoomScaleItems.length === zoomScaleMarks.length && zoomScaleItems.length > 0) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0);
        return;
      }
      zoomScaleTrack.textContent = '';
      setZoomScaleTranslate(0, { animate: false });
      zoomMeterLastAppliedIndex = -1;
      if (!zoomScaleMarks.length) {
        zoomScaleItems = [];
        return;
      }
      zoomScaleMarks.forEach((mark) => {
        const label = document.createElement('span');
        label.className = 'zoom-meter__scale-value';
        label.dataset.zoomValue = String(mark);
        label.textContent = formatZoomScaleLabel(mark);
        if (isMajorZoomValue(mark)) {
          label.classList.add('zoom-meter__scale-value--major');
        }
        zoomScaleTrack.appendChild(label);
      });
      zoomScaleItems = Array.from(zoomScaleTrack.children);
      updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0, { animate: false });
    }

    function updateZoomScaleDisplay(value = state.cameraSettings.zoom ?? 0, { animate = true } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack || !zoomScaleMarks.length) {
        return;
      }
      if (zoomMeterDrag.active) {
        return;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length) {
        return;
      }
      const targetZoom = Number(getZoomDisplayValue(value));
      if (!Number.isFinite(targetZoom)) {
        return;
      }
      let bestIndex = 0;
      let minDiff = Number.POSITIVE_INFINITY;
      zoomScaleMarks.forEach((mark, index) => {
        const diff = Math.abs(Number(mark) - targetZoom);
        if (diff < minDiff) {
          minDiff = diff;
          bestIndex = index;
        }
      });
      alignZoomScaleToIndex(bestIndex, { animate });
      updateZoomScaleActiveFromLayout({ commit: false });
      zoomMeterLastAppliedIndex = bestIndex;
    }

    function setZoomScaleTranslate(translate, { animate = true } = {}) {
      if (!zoomScaleTrack) {
        zoomScaleTranslate = translate;
        return zoomScaleTranslate;
      }
      if (!animate) {
        zoomScaleTrack.classList.add('is-static');
      } else {
        zoomScaleTrack.classList.remove('is-static');
      }
      zoomScaleTranslate = translate;
      zoomScaleTrack.style.transform = `translateX(${translate}px)`;
      if (!animate) {
        requestAnimationFrame(() => {
          zoomScaleTrack.classList.remove('is-static');
        });
      }
      return zoomScaleTranslate;
    }

    function clampZoomScaleTranslate({ animate = false } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack || !zoomScaleItems.length) {
        return zoomScaleTranslate;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      const firstRect = zoomScaleItems[0].getBoundingClientRect();
      const lastRect = zoomScaleItems[zoomScaleItems.length - 1].getBoundingClientRect();
      let adjustedTranslate = zoomScaleTranslate;
      const firstCenter = firstRect.left + firstRect.width / 2;
      const lastCenter = lastRect.left + lastRect.width / 2;
      if (firstCenter > centerX) {
        adjustedTranslate += centerX - firstCenter;
      }
      if (lastCenter < centerX) {
        adjustedTranslate += centerX - lastCenter;
      }
      if (adjustedTranslate !== zoomScaleTranslate) {
        return setZoomScaleTranslate(adjustedTranslate, { animate });
      }
      return zoomScaleTranslate;
    }

    function alignZoomScaleToIndex(index, { animate = true } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        return false;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      const targetItem = zoomScaleItems[index];
      if (!targetItem) {
        return false;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      const itemRect = targetItem.getBoundingClientRect();
      const itemCenterX = itemRect.left + itemRect.width / 2;
      const adjustment = centerX - itemCenterX;
      if (!Number.isFinite(adjustment)) {
        return false;
      }
      setZoomScaleTranslate(zoomScaleTranslate + adjustment, { animate });
      updateZoomScaleActiveFromLayout({ commit: false });
      return true;
    }

    function updateZoomScaleActiveFromLayout({ commit = false, animate = false } = {}) {
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        return null;
      }
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length || !zoomScaleMarks.length) {
        return null;
      }
      const wrapperRect = zoomScaleWrapper.getBoundingClientRect();
      const centerX = wrapperRect.left + wrapperRect.width / 2;
      let bestIndex = 0;
      let minDistance = Number.POSITIVE_INFINITY;
      zoomScaleItems.forEach((item, index) => {
        const baseValue = Number(item.dataset.zoomValue);
        if (Number.isFinite(baseValue)) {
          item.textContent = formatZoomScaleLabel(baseValue);
          item.classList.toggle('zoom-meter__scale-value--major', isMajorZoomValue(baseValue));
        }
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.left + rect.width / 2;
        const distance = Math.abs(itemCenter - centerX);
        if (distance < minDistance) {
          minDistance = distance;
          bestIndex = index;
        }
      });
      zoomScaleItems.forEach((item, index) => {
        item.classList.toggle('is-active', index === bestIndex);
      });
      const activeValue = Number(zoomScaleMarks[bestIndex]);
      if (commit && Number.isFinite(activeValue) && bestIndex !== zoomMeterLastAppliedIndex) {
        commitZoomMarkIndex(bestIndex, { animate, fromDrag: zoomMeterDrag.active });
      }
      return { index: bestIndex, value: activeValue };
    }

    function getSliderValueForZoom(markValue) {
      if (!Number.isFinite(markValue)) {
        return null;
      }
      if (cameraZoomCapability) {
        const mapped = mapCapabilityValueToSlider(markValue, cameraZoomCapability, 'zoom');
        if (Number.isFinite(mapped)) {
          return mapped;
        }
      }
      if (zoomScaleMarks.length) {
        const min = Number(zoomScaleMarks[0]);
        const max = Number(zoomScaleMarks[zoomScaleMarks.length - 1]);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
          const ratio = (markValue - min) / (max - min);
          if (Number.isFinite(ratio)) {
            return getSliderValueFromRatio(ratio, 'zoom');
          }
        }
      }
      return null;
    }

    function commitZoomMarkIndex(index, { animate = false, fromDrag = false } = {}) {
      if (!Array.isArray(zoomScaleMarks) || index < 0 || index >= zoomScaleMarks.length) {
        return;
      }
      const markValue = Number(zoomScaleMarks[index]);
      if (!Number.isFinite(markValue)) {
        return;
      }
      const sliderValue = getSliderValueForZoom(markValue);
      if (!Number.isFinite(sliderValue)) {
        return;
      }
      if (zoomMeterLastAppliedIndex === index && state.cameraSettings.zoom === sliderValue) {
        return;
      }
      zoomMeterLastAppliedIndex = index;
      setCameraSettingValue('zoom', sliderValue, { syncInput: !fromDrag });
      if (!fromDrag) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? sliderValue, { animate });
      }
    }

    function getNearestMarkIndexByClientX(clientX) {
      if (!zoomScaleItems.length) {
        zoomScaleItems = Array.from(zoomScaleTrack.children);
      }
      if (!zoomScaleItems.length) {
        return -1;
      }
      let bestIndex = 0;
      let minDistance = Number.POSITIVE_INFINITY;
      zoomScaleItems.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.left + rect.width / 2;
        const distance = Math.abs(itemCenter - clientX);
        if (distance < minDistance) {
          minDistance = distance;
          bestIndex = index;
        }
      });
      return bestIndex;
    }

    function stopZoomMeterInertia({ finalize = false } = {}) {
      if (!zoomMeterInertia.active) {
        return;
      }
      zoomMeterInertia.active = false;
      if (zoomMeterInertia.frameId) {
        cancelAnimationFrame(zoomMeterInertia.frameId);
        zoomMeterInertia.frameId = 0;
      }
      zoomMeterInertia.velocity = 0;
      zoomMeterInertia.lastTimestamp = 0;
      if (finalize) {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
      }
    }

    function handleZoomMeterPointerDown(event) {
      if (!zoomControl || zoomControl.hidden) {
        return;
      }
      if (zoomMeterDrag.active) {
        return;
      }
      if (event.pointerType === 'mouse' && event.button !== 0) {
        return;
      }
      event.preventDefault();
      stopZoomMeterInertia({ finalize: false });
      setZoomMeterExpanded(true);
      if (zoomMeterCollapseTimeout) {
        clearTimeout(zoomMeterCollapseTimeout);
        zoomMeterCollapseTimeout = null;
      }
      zoomMeterDrag.active = true;
      zoomMeterDrag.pointerId = event.pointerId;
      if (zoomMeterTape && typeof zoomMeterTape.setPointerCapture === 'function') {
        zoomMeterTape.setPointerCapture(event.pointerId);
      }
      zoomMeterDrag.startTranslate = zoomScaleTranslate;
      zoomMeterDrag.startClientX = event.clientX;
      zoomMeterDrag.samples = [{ time: event.timeStamp, x: event.clientX }];
      updateZoomScaleActiveFromLayout({ commit: false });
      window.addEventListener('pointermove', handleZoomMeterPointerMove);
      window.addEventListener('pointerup', handleZoomMeterPointerUp);
      window.addEventListener('pointercancel', handleZoomMeterPointerUp);
    }

    function handleZoomMeterPointerMove(event) {
      if (!zoomMeterDrag.active || event.pointerId !== zoomMeterDrag.pointerId) {
        return;
      }
      event.preventDefault();
      const delta = event.clientX - zoomMeterDrag.startClientX;
      setZoomScaleTranslate(zoomMeterDrag.startTranslate + delta, { animate: false });
      clampZoomScaleTranslate({ animate: false });
      updateZoomScaleActiveFromLayout({ commit: true, animate: false });
      if (Array.isArray(zoomMeterDrag.samples)) {
        zoomMeterDrag.samples.push({ time: event.timeStamp, x: event.clientX });
        const cutoff = event.timeStamp - 120;
        zoomMeterDrag.samples = zoomMeterDrag.samples.filter((sample) => sample.time >= cutoff);
      }
    }

    function computeZoomDragVelocity(time) {
      const samples = Array.isArray(zoomMeterDrag.samples) ? zoomMeterDrag.samples : [];
      if (samples.length < 2) {
        return 0;
      }
      const first = samples[0];
      const last = samples[samples.length - 1];
      const dt = (time ?? last.time) - first.time;
      if (!Number.isFinite(dt) || dt <= 0) {
        return 0;
      }
      return (last.x - first.x) / dt; // px per ms
    }

    function finalizeZoomMeterPosition({ animate = true } = {}) {
      const state = updateZoomScaleActiveFromLayout({ commit: true, animate });
      if (state && Number.isInteger(state.index)) {
        alignZoomScaleToIndex(state.index, { animate });
      }
    }

    function startZoomMeterInertia(initialVelocity) {
      stopZoomMeterInertia();
      if (!zoomScaleWrapper || !zoomScaleTrack) {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
        return;
      }
      zoomMeterInertia.active = true;
      zoomMeterInertia.velocity = initialVelocity;
      zoomMeterInertia.lastTimestamp = performance.now();
      const friction = 0.0015; // px per ms^2
      const minVelocity = 0.04;

      const step = (timestamp) => {
        if (!zoomMeterInertia.active) {
          return;
        }
        const dt = Math.max(1, timestamp - zoomMeterInertia.lastTimestamp);
        zoomMeterInertia.lastTimestamp = timestamp;
        const translateDelta = zoomMeterInertia.velocity * dt;
        setZoomScaleTranslate(zoomScaleTranslate + translateDelta, { animate: false });
        const beforeClamp = zoomScaleTranslate;
        const clampedTranslate = clampZoomScaleTranslate({ animate: false });
        updateZoomScaleActiveFromLayout({ commit: true, animate: false });

        const velocitySign = Math.sign(zoomMeterInertia.velocity);
        zoomMeterInertia.velocity -= velocitySign * friction * dt;
        if (Math.sign(zoomMeterInertia.velocity) !== velocitySign) {
          zoomMeterInertia.velocity = 0;
        }

        const atEdge = clampedTranslate !== beforeClamp;
        if (Math.abs(zoomMeterInertia.velocity) <= minVelocity || atEdge) {
          stopZoomMeterInertia({ finalize: true });
          return;
        }
        zoomMeterInertia.frameId = requestAnimationFrame(step);
      };

      zoomMeterInertia.frameId = requestAnimationFrame(step);
    }

    function handleZoomMeterPointerUp(event) {
      if (!zoomMeterDrag.active || event.pointerId !== zoomMeterDrag.pointerId) {
        return;
      }
      event.preventDefault();
      zoomMeterDrag.active = false;
      zoomMeterDrag.pointerId = null;
      if (zoomMeterTape && typeof zoomMeterTape.releasePointerCapture === 'function') {
        try {
          zoomMeterTape.releasePointerCapture(event.pointerId);
        } catch (error) {
          // ignore
        }
      }
      window.removeEventListener('pointermove', handleZoomMeterPointerMove);
      window.removeEventListener('pointerup', handleZoomMeterPointerUp);
      window.removeEventListener('pointercancel', handleZoomMeterPointerUp);

      const velocity = computeZoomDragVelocity(event.timeStamp);
      zoomMeterDrag.samples = [];

      if (Math.abs(velocity) > 0.18) {
        startZoomMeterInertia(velocity);
      } else {
        finalizeZoomMeterPosition({ animate: true });
        scheduleZoomMeterCollapse();
      }
    }

    function setZoomSliderStepFromCapability() {
      if (!zoomSlider) {
        return;
      }
      let stepValue = 1;
      if (Array.isArray(cameraZoomCapability)) {
        if (cameraZoomCapability.length > 1) {
          stepValue = 100 / (cameraZoomCapability.length - 1);
        }
      } else if (cameraZoomCapability && typeof cameraZoomCapability === 'object') {
        const min = Number(cameraZoomCapability.min);
        const max = Number(cameraZoomCapability.max);
        const step = Number(cameraZoomCapability.step);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min && Number.isFinite(step) && step > 0) {
          const ratioStep = (step / (max - min)) * 100;
          if (Number.isFinite(ratioStep) && ratioStep > 0) {
            stepValue = ratioStep;
          }
        }
      }
      if (!Number.isFinite(stepValue) || stepValue <= 0) {
        stepValue = 1;
      }
      if (stepValue >= 1) {
        const fractional = Math.abs(stepValue - Math.round(stepValue)) > 0.0001;
        zoomSlider.step = fractional ? stepValue.toFixed(2) : String(Math.round(stepValue));
      } else {
        const clamped = Math.max(stepValue, 0.001);
        zoomSlider.step = clamped.toFixed(3);
      }
    }

    function updateZoomSliderAvailability() {
      if (!zoomSlider || !zoomControl) {
        return;
      }
      const value = state.cameraSettings.zoom ?? 0;
      const formatted = formatCameraSettingValue(value, 'zoom');
      const available = cameraZoomCapabilityKnown && Boolean(cameraZoomCapability);
      zoomSlider.disabled = !available;
      if (available) {
        zoomControl.hidden = false;
        zoomControl.setAttribute('aria-hidden', 'false');
        setZoomSliderStepFromCapability();
        zoomSlider.removeAttribute('aria-disabled');
        updateZoomScaleOptions();
      } else {
        zoomControl.hidden = true;
        zoomControl.setAttribute('aria-hidden', 'true');
        zoomSlider.step = '1';
        zoomSlider.setAttribute('aria-disabled', 'true');
        stopZoomMeterInertia({ finalize: false });
        if (zoomScaleTrack) {
          zoomScaleTrack.textContent = '';
          setZoomScaleTranslate(0, { animate: false });
        }
        zoomScaleMarks = [];
        zoomScaleItems = [];
        zoomMeterLastAppliedIndex = -1;
        setZoomMeterExpanded(false);
      }
      zoomSlider.value = String(value);
      zoomSlider.setAttribute('aria-valuenow', String(value));
      zoomSlider.setAttribute('aria-valuetext', formatted);
      refreshZoomMeterVisuals(value);
    }

    async function applyCameraSettingsToTrack() {
      const track = getActiveVideoTrack();
      if (!track || typeof track.applyConstraints !== 'function' || typeof track.getCapabilities !== 'function') {
        return false;
      }
      let capabilities;
      try {
        capabilities = track.getCapabilities();
      } catch (error) {
        if (!cameraConstraintErrorLogged) {
          console.warn('カメラ設定の取得に失敗しました', error);
          cameraConstraintErrorLogged = true;
        }
        return false;
      }
      if (!capabilities) {
        return false;
      }
      const hadKnownZoomCapability = cameraZoomCapabilityKnown;
      cameraZoomCapabilityKnown = true;
      if (Object.prototype.hasOwnProperty.call(capabilities, 'zoom')) {
        cameraZoomCapability = capabilities.zoom;
      } else {
        cameraZoomCapability = null;
      }
      if (!hadKnownZoomCapability && cameraZoomCapability) {
        syncZoomStateFromTrack(track);
      }
      updateZoomSliderAvailability();
      const constraint = {};
      let hasConstraint = false;
      CAMERA_SETTING_KEYS.forEach((key) => {
        const capabilityName = CAMERA_TRACK_CAPABILITY_MAP[key];
        if (!capabilityName || !(capabilityName in capabilities)) {
          return;
        }
        const capability = capabilities[capabilityName];
        const mappedValue = mapSliderValueToCapability(state.cameraSettings[key], capability, key);
        if (mappedValue == null) {
          return;
        }
        constraint[capabilityName] = mappedValue;
        hasConstraint = true;
      });
      if (!hasConstraint) {
        return false;
      }
      try {
        await track.applyConstraints({ advanced: [constraint] });
        cameraConstraintErrorLogged = false;
        return true;
      } catch (error) {
        if (!cameraConstraintErrorLogged) {
          console.warn('カメラ設定の適用に失敗しました', error);
          cameraConstraintErrorLogged = true;
        }
        return false;
      }
    }

    function updateStampEmptyState(isEmpty) {
      if (stampList) {
        stampList.hidden = Boolean(isEmpty);
      }
      if (stampEmptyMessage) {
        stampEmptyMessage.hidden = !isEmpty;
      }
    }

    async function handleStampSelection(stamp, button) {
      if (!stamp || !stamp.src) {
        return;
      }
      const targetButton = button || null;
      if (targetButton) {
        targetButton.disabled = true;
        targetButton.classList.add('is-loading');
      }
      try {
        const result = await createOverlayFromImageSource(stamp.src);
        if (!result) {
          throw new Error('Failed to create overlay from stamp');
        }
      } catch (error) {
        console.error('スタンプの読み込みに失敗しました', error);
        setStatus('スタンプを読み込めませんでした');
      } finally {
        if (targetButton) {
          targetButton.disabled = false;
          targetButton.classList.remove('is-loading');
        }
      }
    }

    function populateStampPanel() {
      if (!stampList) {
        return;
      }
      stampList.textContent = '';
      const stamps = Array.isArray(STAMP_LIBRARY) ? STAMP_LIBRARY : [];
      if (!stamps.length) {
        updateStampEmptyState(true);
        return;
      }
      updateStampEmptyState(false);
      stamps.forEach((stamp) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'stamp-button';
        button.dataset.stampId = stamp.id || '';
        button.setAttribute('aria-label', `スタンプ ${stamp.label || stamp.id || ''}`.trim());
        const preview = document.createElement('span');
        preview.className = 'stamp-button__preview';
        const image = document.createElement('img');
        image.src = stamp.src;
        image.alt = '';
        image.draggable = false;
        preview.appendChild(image);
        button.appendChild(preview);
        ['pointerdown', 'mousedown', 'touchstart'].forEach((type) => {
          button.addEventListener(type, (event) => event.stopPropagation(), { passive: false });
        });
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          void handleStampSelection(stamp, button);
        });
        stampList.appendChild(button);
      });
    }

    populateStampPanel();
    initializeCameraSettingsUI();

    function setSelectEnabled(selectElement, enabled) {
      if (!selectElement) {
        return;
      }
      const desired = Boolean(enabled);
      selectElement.disabled = !desired;
      if (desired) {
        selectElement.removeAttribute('aria-disabled');
      } else {
        selectElement.setAttribute('aria-disabled', 'true');
      }
    }

    function setDotScalePanelOpen(open) {
      if (!dotSettingsPanel) {
        dotScalePanelOpen = false;
        return;
      }
      const desired = Boolean(open && state.dotMode);
      dotScalePanelOpen = desired;
      dotSettingsPanel.hidden = !desired;
      dotSettingsPanel.classList.toggle('is-open', desired);
      if (dotModeBtn) {
        dotModeBtn.setAttribute('aria-expanded', desired ? 'true' : 'false');
      }
      if (!desired && paletteDisplayEnabled) {
        setPaletteDisplayEnabled(false);
      }
      if (desired) {
        openMenuKey = 'dotScale';
      } else if (openMenuKey === 'dotScale') {
        openMenuKey = null;
      }
    }

    function setDotSettingsOpen(open) {
      const desired = Boolean(open);
      setDotScalePanelOpen(desired);
    }

    function setMenuOpen(key, open) {
      const entry = menus[key];
      if (!entry || !entry.button || !entry.panel) {
        return;
      }
      if (open) {
        entry.panel.classList.add('is-open');
        entry.panel.hidden = false;
        entry.button.setAttribute('aria-expanded', 'true');
        openMenuKey = key;
      } else {
        entry.panel.classList.remove('is-open');
        entry.panel.hidden = true;
        entry.button.setAttribute('aria-expanded', 'false');
        if (openMenuKey === key) {
          openMenuKey = null;
        }
      }
    }

    function closeAllMenus(exceptKey = null) {
      if (exceptKey !== 'dotScale') {
        setDotSettingsOpen(false);
      }
      Object.keys(menus).forEach((key) => {
        if (key !== exceptKey) {
          setMenuOpen(key, false);
        }
      });
    }

    function openMenuExclusive(key) {
      if (key === 'dotScale') {
        if (!state.dotMode) {
          return;
        }
        closeAllMenus('dotScale');
        setDotSettingsOpen(true);
        return;
      }
      closeAllMenus(key);
      setMenuOpen(key, true);
    }

    function toggleMenu(key) {
      if (key === 'dotScale') {
        if (!state.dotMode) {
          return;
        }
        const isOpen = dotScalePanelOpen && dotSettingsPanel && !dotSettingsPanel.hidden;
        if (isOpen) {
          setDotSettingsOpen(false);
        } else {
          openMenuExclusive('dotScale');
        }
        return;
      }
      const entry = menus[key];
      if (!entry || !entry.panel) {
        return;
      }
      const isOpen = entry.panel.classList.contains('is-open');
      if (isOpen) {
        setMenuOpen(key, false);
        return;
      }
      openMenuExclusive(key);
    }

    function closeMenu(key) {
      if (key === 'dotScale') {
        setDotSettingsOpen(false);
        return;
      }
      setMenuOpen(key, false);
    }

    function updateControlPlacement() {
      if (!captureBtn || !captureButtonOriginalParent) {
        return;
      }
      const isLandscape = window.innerWidth > window.innerHeight;
      if (isLandscape) {
        document.body.classList.add('is-landscape');
        if (landscapeCaptureSlot) {
          if (captureBtn.parentElement !== landscapeCaptureSlot) {
            landscapeCaptureSlot.appendChild(captureBtn);
          }
          landscapeCaptureSlot.setAttribute('aria-hidden', 'false');
        }
      } else {
        document.body.classList.remove('is-landscape');
        if (captureBtn.parentElement !== captureButtonOriginalParent) {
          captureButtonOriginalParent.appendChild(captureBtn);
        }
        if (landscapeCaptureSlot) {
          landscapeCaptureSlot.setAttribute('aria-hidden', 'true');
        }
      }
      if (zoomControl && !zoomControl.hidden) {
        updateZoomScaleDisplay(state.cameraSettings.zoom ?? 0, { animate: false });
      }
    }

    function setStatus(message) {
      if (hudTopBar) {
        hudTopBar.dataset.status = message || '';
      }
    }

    function setIconButtonLabel(button, label) {
      if (!button) {
        return;
      }
      button.setAttribute('aria-label', label);
      const hidden = button.querySelector('.icon-button__label');
      if (hidden) {
        hidden.textContent = label;
      }
    }

    function setCameraStatus(message) {
      cameraStatusMessage = message;
      if (!activeOverlay || !activeOverlay.hasImage) {
        setStatus(message);
      }
    }

    const CAMERA_ICON_SWITCH_CONTENT = [
      '<rect x="5" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="13" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="4" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="14" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="4" y="2" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="15" y="2" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="19" y="2" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="8" y="3" width="1" height="3" fill="#FFFFFF"></rect>',
      '<rect x="5" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="9" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="18" y="4" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="6" y="5" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="5" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="13" y="5" width="5" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="7" width="8" height="1" fill="#FFFFFF"></rect>',
      '<rect x="3" y="8" width="3" height="2" fill="#FFFFFF"></rect>',
      '<rect x="7" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="6" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="9" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="9" width="7" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="23" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="9" y="12" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="7" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="16" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="8" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="9" y="21" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>'
    ].join('');

    const CAMERA_ICON_RESUME_CONTENT = [
      '<rect x="17" y="0" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="1" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="2" width="1" height="5" fill="#FFFFFF"></rect>',
      '<rect x="21" y="2" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="23" y="2" width="1" height="5" fill="#FFFFFF"></rect>',
      '<rect x="20" y="3" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="19" y="4" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="5" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="17" y="6" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="6" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="8" y="7" width="8" height="1" fill="#FFFFFF"></rect>',
      '<rect x="18" y="7" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="3" y="8" width="3" height="2" fill="#FFFFFF"></rect>',
      '<rect x="7" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="8" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="6" y="9" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="10" y="9" width="4" height="1" fill="#FFFFFF"></rect>',
      '<rect x="16" y="9" width="7" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="22" y="10" width="2" height="1" fill="#FFFFFF"></rect>',
      '<rect x="0" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="23" y="11" width="1" height="12" fill="#FFFFFF"></rect>',
      '<rect x="9" y="12" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="8" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="13" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="7" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="16" y="14" width="1" height="6" fill="#FFFFFF"></rect>',
      '<rect x="8" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="15" y="20" width="1" height="1" fill="#FFFFFF"></rect>',
      '<rect x="9" y="21" width="6" height="1" fill="#FFFFFF"></rect>',
      '<rect x="1" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="22" y="22" width="1" height="2" fill="#FFFFFF"></rect>',
      '<rect x="2" y="23" width="20" height="1" fill="#FFFFFF"></rect>'
    ].join('');

    let cameraActionMode = 'resume';

    function setCameraActionIcon(mode) {
      if (!cameraActionIcon) {
        return;
      }
      cameraActionIcon.innerHTML = mode === 'switch' ? CAMERA_ICON_SWITCH_CONTENT : CAMERA_ICON_RESUME_CONTENT;
    }

    function updateCameraActionState() {
      if (!cameraActionBtn) {
        return;
      }
      const allowSwitch = cameraReady && !cameraPermissionDenied;
      cameraActionMode = allowSwitch ? 'switch' : 'resume';

      cameraActionBtn.dataset.mode = cameraActionMode;
      cameraActionBtn.disabled = state.restarting;
      setCameraActionIcon(cameraActionMode);

      if (cameraActionMode === 'switch') {
        const label = state.useFrontCamera ? '背面カメラに切替' : 'フロントカメラに切替';
        setIconButtonLabel(cameraActionBtn, label);
      } else {
        setIconButtonLabel(cameraActionBtn, '再接続');
      }
    }

    updateCameraActionState();

    function refreshOverlayStatus() {
      if (activeOverlay && activeOverlay.hasImage) {
        const overlayIndex = overlays.indexOf(activeOverlay);
        const prefix = overlays.length > 1 ? `ドット絵 ${overlayIndex + 1}/${overlays.length}` : 'ドット絵';
        setStatus(`${prefix}: ${activeOverlay.baseWidth}×${activeOverlay.baseHeight}px / x${activeOverlay.scale}`);
      } else if (state.dotMode && dotState.width && dotState.height) {
        const dotCount = dotState.width * dotState.height;
        let depthLabel;
        if (state.colorDepth === 'full') {
          depthLabel = 'フルカラー';
        } else if (state.colorDepth === 'gray') {
          depthLabel = 'グレースケール';
        } else {
          depthLabel = `${state.colorDepth}色`;
        }
        setStatus(`ドットモード: ${dotState.width}×${dotState.height}px (${dotCount.toLocaleString()} ドット) / x${state.dotScale} / ${depthLabel}`);
      } else if (cameraStatusMessage) {
        setStatus(cameraStatusMessage);
      }
    }

    const ASPECT_RATIOS = {
      '1:1': { width: 1, height: 1 },
      '3:2': () => {
        const isLandscape = window.innerWidth >= window.innerHeight;
        return isLandscape ? { width: 3, height: 2 } : { width: 2, height: 3 };
      },
      '4:3': () => {
        const isLandscape = window.innerWidth >= window.innerHeight;
        return isLandscape ? { width: 4, height: 3 } : { width: 3, height: 4 };
      },
      '16:9': () => {
        const isLandscape = window.innerWidth >= window.innerHeight;
        return isLandscape ? { width: 16, height: 9 } : { width: 9, height: 16 };
      }
    };

    const COLOR_DEPTHS = ['full', 'gray', '4', '2'];
    const BLACK_COLOR = { r: 0, g: 0, b: 0 };
    const WHITE_COLOR = { r: 255, g: 255, b: 255 };
    const FIXED_FOUR_COLOR_PALETTE = [
      { r: 224, g: 248, b: 208 }, // lightest green
      { r: 168, g: 192, b: 112 }, // light green
      { r: 88, g: 120, b: 48 },   // dark green
      { r: 32, g: 56, b: 16 }     // darkest green
    ];
    const FIXED_TWO_COLOR_PALETTE = [
      { r: 0, g: 0, b: 0 },
      { r: 255, g: 255, b: 255 }
    ];
    const FOUR_COLOR_DARK_THRESHOLD = 96;

    function updateAspectLayout() {
      if (!aspectOverlay || !aspectCenter || !aspectFrame || !aspectShadeTop || !aspectShadeBottom || !aspectShadeLeft || !aspectShadeRight) {
        return;
      }
      const metrics = getViewportMetrics();
      const viewportWidth = metrics.width;
      const viewportHeight = metrics.height;
      const ratioEntry = ASPECT_RATIOS[state.aspectMode];
      const ratio = typeof ratioEntry === 'function' ? ratioEntry() : ratioEntry;
      if (!ratio) {
        aspectOverlay.hidden = true;
        aspectFrame.style.width = '';
        aspectFrame.style.height = '';
        if (aspectCenter) {
          aspectCenter.style.height = '';
        }
        if (aspectShadeTop) {
          aspectShadeTop.style.height = '0px';
        }
        if (aspectShadeBottom) {
          aspectShadeBottom.style.height = '0px';
        }
        if (aspectShadeLeft) {
          aspectShadeLeft.style.width = '0px';
        }
        if (aspectShadeRight) {
          aspectShadeRight.style.width = '0px';
        }
        updateDotCanvasLayout();
        return;
      }
      aspectOverlay.hidden = false;
      const ratioWidth = Math.max(1, ratio.width);
      const ratioHeight = Math.max(1, ratio.height);
      const scaleBase = Math.min(
        viewportWidth / ratioWidth,
        viewportHeight / ratioHeight
      );
      const scale = Number.isFinite(scaleBase) && scaleBase > 0 ? scaleBase : 1;
      const targetWidth = Math.max(1, Math.round(ratioWidth * scale));
      const targetHeight = Math.max(1, Math.round(ratioHeight * scale));
      const shadeHeight = Math.max(0, (viewportHeight - targetHeight) / 2);
      const shadeWidth = Math.max(0, (viewportWidth - targetWidth) / 2);

      aspectCenter.style.height = `${Math.round(targetHeight)}px`;
      aspectFrame.style.width = `${Math.round(targetWidth)}px`;
      aspectFrame.style.height = `${Math.round(targetHeight)}px`;
      aspectShadeTop.style.height = `${Math.floor(shadeHeight)}px`;
      aspectShadeBottom.style.height = `${Math.ceil(shadeHeight)}px`;
      aspectShadeLeft.style.width = `${Math.floor(shadeWidth)}px`;
      aspectShadeRight.style.width = `${Math.ceil(shadeWidth)}px`;
      updateDotCanvasLayout(targetWidth, targetHeight, shadeWidth, shadeHeight);
    }

    function setAspectMode(mode) {
      if (!Object.prototype.hasOwnProperty.call(ASPECT_RATIOS, mode)) {
        mode = '3:2';
      }
      state.aspectMode = mode;
      aspectButtons.forEach((button) => {
        const isActive = button.dataset.aspect === mode;
      button.classList.toggle('is-active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
    updateAspectLayout();
    closeMenu('aspect');
    if (state.dotMode) {
      ensureDotResolution();
    }
  }

    function getDotResolution() {
      const scaleMap = {
        1: 256,
        2: 128,
        3: 64,
        4: 32
      };
      const basePixels = scaleMap[state.dotScale] || 64;
      const minPixels = 16;
      const layout = dotState.layout || {};
      const layoutRatio = layout.width && layout.height ? layout.width / layout.height : null;

      if (state.aspectMode === '1:1') {
        return {
          width: Math.max(minPixels, basePixels),
          height: Math.max(minPixels, basePixels)
        };
      }

      let ratio = layoutRatio;
      if (!Number.isFinite(ratio) || ratio <= 0) {
        const sourceWidth = video.videoWidth || 0;
        const sourceHeight = video.videoHeight || 0;
        if (sourceWidth > 0 && sourceHeight > 0) {
          ratio = sourceWidth / sourceHeight;
        } else {
          ratio = 1;
        }
      }

      let width = basePixels;
      let height = Math.round(width / ratio);

      if (height < minPixels) {
        height = minPixels;
        width = Math.round(height * ratio);
      }

      if (width < minPixels) {
        width = minPixels;
        height = Math.round(width / ratio);
      }

      return {
        width: Math.max(minPixels, width),
        height: Math.max(minPixels, height)
      };
    }

    function getContainLayout() {
      const metrics = getViewportMetrics();
      const viewportWidth = metrics.width;
      const viewportHeight = metrics.height;
      const sourceWidth = video.videoWidth || viewportWidth;
      const sourceHeight = video.videoHeight || viewportHeight;
      if (!sourceWidth || !sourceHeight) {
        return {
          width: viewportWidth,
          height: viewportHeight,
          offsetX: metrics.offsetLeft,
          offsetY: metrics.offsetTop
        };
      }
      const scale = Math.min(
        viewportWidth / sourceWidth,
        viewportHeight / sourceHeight
      );
      const width = Math.max(1, Math.round(sourceWidth * scale));
      const height = Math.max(1, Math.round(sourceHeight * scale));
      const offsetX = metrics.offsetLeft + Math.round((viewportWidth - width) / 2);
      const offsetY = metrics.offsetTop + Math.round((viewportHeight - height) / 2);
      return { width, height, offsetX, offsetY };
    }

    function getViewportMetrics() {
      const viewportWidth = Math.max(1, Math.round(window.innerWidth || 0));
      const viewportHeight = Math.max(1, Math.round(window.innerHeight || 0));
      if (window.visualViewport) {
        const vv = window.visualViewport;
        return {
          width: Math.max(1, Math.round(vv.width)),
          height: Math.max(1, Math.round(vv.height)),
          offsetLeft: Math.round(vv.offsetLeft || 0),
          offsetTop: Math.round(vv.offsetTop || 0),
          pageWidth: viewportWidth,
          pageHeight: viewportHeight
        };
      }
      return {
        width: viewportWidth,
        height: viewportHeight,
        offsetLeft: 0,
        offsetTop: 0,
        pageWidth: viewportWidth,
        pageHeight: viewportHeight
      };
    }

    function updateDotCanvasLayout(targetWidth, targetHeight, shadeWidth, shadeHeight) {
      if (!dotCanvas) {
        return;
      }
      const metrics = getViewportMetrics();
      let width;
      let height;
      let offsetX;
      let offsetY;

      if (Number.isFinite(targetWidth) && Number.isFinite(targetHeight) && Number.isFinite(shadeWidth) && Number.isFinite(shadeHeight)) {
        width = Math.max(1, Math.round(targetWidth));
        height = Math.max(1, Math.round(targetHeight));
        offsetX = Math.round(shadeWidth) + metrics.offsetLeft;
        offsetY = Math.round(shadeHeight) + metrics.offsetTop;
      } else {
        const contain = getContainLayout();
        width = contain.width;
        height = contain.height;
        offsetX = contain.offsetX;
        offsetY = contain.offsetY;
      }

      dotCanvas.style.width = `${width}px`;
      dotCanvas.style.height = `${height}px`;
      dotCanvas.style.left = `${offsetX}px`;
      dotCanvas.style.top = `${offsetY}px`;
      dotCanvas.style.right = '';
      dotCanvas.style.bottom = '';
      dotState.layout = { width, height, offsetX, offsetY, mode: 'contain' };
      resnapAllOverlaysToDotGrid();
    }

    function applyDotCanvasLayoutFromState() {
      if (!dotCanvas) {
        return;
      }
      const { width, height, offsetX, offsetY } = dotState.layout || {};
      if (!width || !height) {
        const contain = getContainLayout();
        dotCanvas.style.width = `${contain.width}px`;
        dotCanvas.style.height = `${contain.height}px`;
        dotCanvas.style.left = `${contain.offsetX}px`;
        dotCanvas.style.top = `${contain.offsetY}px`;
        dotCanvas.style.right = '';
        dotCanvas.style.bottom = '';
        return;
      }
      dotCanvas.style.width = `${width}px`;
      dotCanvas.style.height = `${height}px`;
      dotCanvas.style.left = `${offsetX}px`;
      dotCanvas.style.top = `${offsetY}px`;
      dotCanvas.style.right = '';
      dotCanvas.style.bottom = '';
    }

    function ensureDotResolution() {
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      const resolution = getDotResolution();
      if (!resolution.width || !resolution.height) {
        return;
      }
      if (resolution.width !== dotState.width || resolution.height !== dotState.height) {
        dotState.width = resolution.width;
        dotState.height = resolution.height;
        dotCanvas.width = resolution.width;
        dotCanvas.height = resolution.height;
      }
      if (state.dotMode) {
        refreshOverlayStatus();
        resnapAllOverlaysToDotGrid();
      }
    }

    function getDotSourceRect() {
      if (!dotCanvas || !dotCanvasCtx) {
        return null;
      }
      const videoWidth = video.videoWidth || 0;
      const videoHeight = video.videoHeight || 0;
      if (!videoWidth || !videoHeight) {
        return null;
      }
      const targetRatio = dotCanvas.width && dotCanvas.height
        ? dotCanvas.width / dotCanvas.height
        : videoWidth / videoHeight;
      if (!Number.isFinite(targetRatio) || targetRatio <= 0) {
        return { sx: 0, sy: 0, sw: videoWidth, sh: videoHeight };
      }
      const videoRatio = videoWidth / videoHeight;
      if (Math.abs(videoRatio - targetRatio) < 0.0001) {
        return { sx: 0, sy: 0, sw: videoWidth, sh: videoHeight };
      }
      if (videoRatio > targetRatio) {
        const targetWidth = videoHeight * targetRatio;
        const sx = Math.round((videoWidth - targetWidth) / 2);
        const sw = Math.round(targetWidth);
        return { sx, sy: 0, sw, sh: videoHeight };
      }
      const targetHeight = videoWidth / targetRatio;
      const sy = Math.round((videoHeight - targetHeight) / 2);
      const sh = Math.round(targetHeight);
      return { sx: 0, sy, sw: videoWidth, sh };
    }

    const COLOR_BIN_SIZE = 16;
    const COLOR_BIN_INTERVAL = 256 / COLOR_BIN_SIZE;
    const PRE_AVERAGE_RADIUS = 0;
    const SATURATION_BOOST = 1.22;
    const CONTRAST_STRENGTH = 1.35;
    const SHADOW_LIFT_THRESHOLD = 82;
    const SHADOW_LIFT_AMOUNT = 10;
    const PALETTE_HOLD_MS = 5000;
    const DOT_SMOOTHING_BLUR = 0.45;

    const paletteState = {
      depth: null,
      desired: 0,
      colors: [],
      originalColors: [],
      cache: new Map(),
      lastUpdated: 0,
      userEdited: false
    };
    let paletteDisplayKey = '';
    let paletteDisplayEnabled = false;
    const paletteEditState = {
      activeIndex: null,
      baseS: 0,
      baseL: 0,
      elements: {
        container: null,
        slider: null,
        value: null,
        preview: null,
        reset: null
      }
    };

    function applyNewPaletteColors(colors) {
      const next = Array.isArray(colors) ? colors.map((color) => ({ ...color })) : [];
      paletteState.colors = next;
      paletteState.originalColors = next.map((color) => ({ ...color }));
      paletteState.cache = new Map();
      paletteState.userEdited = false;
    }

    function getColorBinIndex(value) {
      return Math.max(0, Math.min(COLOR_BIN_SIZE - 1, Math.floor(value / COLOR_BIN_INTERVAL)));
    }

    function binIndexToColorValue(index) {
      const step = 255 / (COLOR_BIN_SIZE - 1);
      return Math.max(0, Math.min(255, Math.round(index * step)));
    }

    function resetPaletteDisplay() {
      if (!paletteDisplay) {
        return;
      }
      paletteDisplay.innerHTML = '';
      paletteDisplay.classList.remove('is-visible');
      paletteDisplay.setAttribute('aria-hidden', 'true');
      paletteDisplayKey = '';
      paletteEditState.activeIndex = null;
      paletteEditState.elements = {
        container: null,
        slider: null,
        value: null,
        preview: null,
        reset: null
      };
    }

    function updatePaletteDisplay(force = false) {
      if (!paletteDisplay) {
        return;
      }
      if (!state.dotMode || state.colorDepth === 'full' || !paletteDisplayEnabled) {
        if (force || paletteDisplayKey) {
          resetPaletteDisplay();
        }
        return;
      }
      const colors = paletteState.colors || [];
      if (!colors.length) {
        if (force || !paletteDisplayKey) {
          paletteDisplay.innerHTML = '<span class="palette-display__label">パレットを計算中…</span>';
          paletteDisplay.classList.add('is-visible');
          paletteDisplay.setAttribute('aria-hidden', 'false');
          paletteDisplayKey = '';
        }
        return;
      }
      const key = colors.map((color) => `${color.r},${color.g},${color.b}`).join('|');
      if (!force && key === paletteDisplayKey) {
        return;
      }
      paletteDisplayKey = key;
      const swatchesHtml = colors.map((color, index) => {
        const rgb = `rgb(${color.r}, ${color.g}, ${color.b})`;
        return `
          <button type="button" class="palette-swatch" data-palette-index="${index}" aria-label="パレット色 ${index + 1}" aria-pressed="false">
            <span class="palette-swatch__chip" style="background:${rgb}"></span>
          </button>
        `;
      }).join('');
      paletteDisplay.innerHTML = `
        <div class="palette-display__swatches" role="list">${swatchesHtml}</div>
        <div class="palette-editor" hidden>
          <div class="palette-editor__header">
            <div class="palette-editor__preview" aria-hidden="true"></div>
            <div class="palette-editor__value" aria-live="polite">0°</div>
          </div>
          <label class="palette-editor__slider">
            <span class="palette-editor__label">色相</span>
            <input type="range" min="0" max="360" step="1" value="0" aria-label="色相を調整">
          </label>
          <button type="button" class="palette-editor__reset">リセット</button>
        </div>
      `;
      paletteDisplay.classList.add('is-visible');
      paletteDisplay.setAttribute('aria-hidden', 'false');
      setupPaletteDisplayInteractions();
    }

    function setPaletteDisplayEnabled(enabled) {
      const canEnable = Boolean(enabled)
        && state.dotMode
        && state.colorDepth !== 'full'
        && state.colorDepth !== 'gray';
      paletteDisplayEnabled = canEnable;
      if (paletteToggleBtn) {
        paletteToggleBtn.classList.toggle('is-active', canEnable);
        paletteToggleBtn.setAttribute('aria-pressed', canEnable ? 'true' : 'false');
      }
      if (canEnable) {
        updatePaletteDisplay(true);
      } else {
        resetPaletteDisplay();
      }
    }

    function updateActivePaletteSwatch(index) {
      if (!paletteDisplay) {
        return;
      }
      const buttons = paletteDisplay.querySelectorAll('.palette-swatch');
      buttons.forEach((button) => {
        const targetIndex = Number(button.dataset.paletteIndex);
        const isActive = targetIndex === index;
        button.classList.toggle('palette-swatch--active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function setupPaletteDisplayInteractions() {
      if (!paletteDisplay) {
        return;
      }
      const swatches = Array.from(paletteDisplay.querySelectorAll('.palette-swatch'));
      const editor = paletteDisplay.querySelector('.palette-editor');
      const slider = editor ? editor.querySelector('input[type="range"]') : null;
      const valueLabel = editor ? editor.querySelector('.palette-editor__value') : null;
      const preview = editor ? editor.querySelector('.palette-editor__preview') : null;
      const resetButton = editor ? editor.querySelector('.palette-editor__reset') : null;

      paletteEditState.elements = {
        container: editor,
        slider,
        value: valueLabel,
        preview,
        reset: resetButton
      };
      paletteEditState.activeIndex = null;
      if (editor) {
        editor.hidden = true;
      }
      updateActivePaletteSwatch(-1);

      const stopEvent = (event) => event.stopPropagation();
      swatches.forEach((button) => {
        ['pointerdown', 'mousedown', 'touchstart'].forEach((type) => {
          button.addEventListener(type, stopEvent);
        });
        button.addEventListener('click', (event) => {
          stopEvent(event);
          const index = Number(button.dataset.paletteIndex);
          if (Number.isFinite(index)) {
            handlePaletteSwatchSelect(index);
          }
        });
      });

      if (slider) {
        ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
          slider.addEventListener(type, stopEvent);
        });
        slider.addEventListener('input', handlePaletteHueInput);
      }

      if (resetButton) {
        ['pointerdown', 'mousedown', 'touchstart', 'click'].forEach((type) => {
          resetButton.addEventListener(type, stopEvent);
        });
        resetButton.addEventListener('click', handlePaletteHueReset);
      }
    }

    function handlePaletteSwatchSelect(index) {
      if (!paletteState.colors || !paletteState.colors[index]) {
        return;
      }
      const editor = paletteEditState.elements.container;
      if (!editor) {
        return;
      }
      const original = paletteState.originalColors && paletteState.originalColors[index]
        ? paletteState.originalColors[index]
        : paletteState.colors[index];
      const current = paletteState.colors[index];
      const [baseHue, baseS, baseL] = rgbToHsl(original.r, original.g, original.b);
      const [currentHue] = rgbToHsl(current.r, current.g, current.b);
      paletteEditState.activeIndex = index;
      paletteEditState.baseS = baseS;
      paletteEditState.baseL = baseL;
      updateActivePaletteSwatch(index);
      editor.hidden = false;

      const slider = paletteEditState.elements.slider;
      const valueLabel = paletteEditState.elements.value;
      const preview = paletteEditState.elements.preview;
      const hueDegrees = Math.round((((currentHue % 1) + 1) % 1) * 360);
      if (slider) {
        slider.value = String(hueDegrees);
      }
      if (valueLabel) {
        valueLabel.textContent = `${hueDegrees}°`;
      }
      if (preview) {
        preview.style.background = `rgb(${current.r}, ${current.g}, ${current.b})`;
      }
    }

    function applyPaletteColorAtIndex(index, newColor) {
      if (!paletteState.colors || !paletteState.colors[index]) {
        return;
      }
      paletteState.colors[index] = { ...newColor };
      paletteState.cache = new Map();
      paletteState.lastUpdated = typeof performance !== 'undefined' ? performance.now() : Date.now();
      const originalColors = paletteState.originalColors || [];
      let isDifferent = originalColors.length !== paletteState.colors.length;
      if (!isDifferent) {
        for (let i = 0; i < paletteState.colors.length; i += 1) {
          const currentColor = paletteState.colors[i];
          const originalColor = originalColors[i];
          if (!originalColor || originalColor.r !== currentColor.r || originalColor.g !== currentColor.g || originalColor.b !== currentColor.b) {
            isDifferent = true;
            break;
          }
        }
      }
      paletteState.userEdited = isDifferent;
      paletteDisplayKey = '';
      const chip = paletteDisplay
        ? paletteDisplay.querySelector(`.palette-swatch[data-palette-index="${index}"] .palette-swatch__chip`)
        : null;
      if (chip) {
        chip.style.background = `rgb(${newColor.r}, ${newColor.g}, ${newColor.b})`;
      }
      if (paletteEditState.elements.preview) {
        paletteEditState.elements.preview.style.background = `rgb(${newColor.r}, ${newColor.g}, ${newColor.b})`;
      }
      if (state.dotMode) {
        refreshOverlayStatus();
      }
    }

    function handlePaletteHueInput(event) {
      if (paletteEditState.activeIndex == null) {
        return;
      }
      if (event) {
        event.stopPropagation();
      }
      const slider = event && event.target ? event.target : paletteEditState.elements.slider;
      if (!slider) {
        return;
      }
      const hueDeg = Number(slider.value) || 0;
      const normalizedDeg = ((hueDeg % 360) + 360) % 360;
      const hueNormalized = normalizedDeg / 360;
      const index = paletteEditState.activeIndex;
      const newColor = hslToRgb(hueNormalized, paletteEditState.baseS, paletteEditState.baseL);
      applyPaletteColorAtIndex(index, newColor);
      if (paletteEditState.elements.value) {
        paletteEditState.elements.value.textContent = `${Math.round(normalizedDeg)}°`;
      }
    }

    function handlePaletteHueReset(event) {
      if (paletteEditState.activeIndex == null) {
        return;
      }
      if (event) {
        event.stopPropagation();
      }
      const index = paletteEditState.activeIndex;
      const original = paletteState.originalColors && paletteState.originalColors[index]
        ? paletteState.originalColors[index]
        : paletteState.colors[index];
      if (!original) {
        return;
      }
      const [origHue, origS, origL] = rgbToHsl(original.r, original.g, original.b);
      paletteEditState.baseS = origS;
      paletteEditState.baseL = origL;
      const normalizedDeg = Math.round((((origHue % 1) + 1) % 1) * 360);
      if (paletteEditState.elements.slider) {
        paletteEditState.elements.slider.value = String(normalizedDeg);
      }
      if (paletteEditState.elements.value) {
        paletteEditState.elements.value.textContent = `${normalizedDeg}°`;
      }
      applyPaletteColorAtIndex(index, { ...original });
    }
    function updatePaletteToggleAvailability() {
      if (!paletteToggleBtn) {
        return;
      }
      const canShow = state.dotMode
        && state.colorDepth !== 'full'
        && state.colorDepth !== 'gray';
      paletteToggleBtn.disabled = !canShow;
      if (canShow) {
        paletteToggleBtn.removeAttribute('aria-disabled');
      } else {
        paletteToggleBtn.setAttribute('aria-disabled', 'true');
      }
      if (!canShow && paletteDisplayEnabled) {
        setPaletteDisplayEnabled(false);
      }
    }

    function ensurePaletteColor(palette, target) {
      if (palette.some((entry) => entry.r === target.r && entry.g === target.g && entry.b === target.b)) {
        return;
      }
      const color = { ...target };
      if (typeof color.count !== 'number') {
        color.count = Number.MAX_SAFE_INTEGER;
      }
      palette.push(color);
    }

    function applyPreAverage(imageData) {
      if (PRE_AVERAGE_RADIUS <= 0) {
        return;
      }
      const width = imageData.width || 0;
      const height = imageData.height || 0;
      if (!width || !height) {
        return;
      }
      const radius = Math.floor(PRE_AVERAGE_RADIUS);
      const source = new Uint8ClampedArray(imageData.data);
      const data = imageData.data;
      for (let y = 0; y < height; y += 1) {
        const yMin = Math.max(0, y - radius);
        const yMax = Math.min(height - 1, y + radius);
        for (let x = 0; x < width; x += 1) {
          const xMin = Math.max(0, x - radius);
          const xMax = Math.min(width - 1, x + radius);
          let rSum = 0;
          let gSum = 0;
          let bSum = 0;
          let count = 0;
          for (let yy = yMin; yy <= yMax; yy += 1) {
            const base = yy * width;
            for (let xx = xMin; xx <= xMax; xx += 1) {
              const idx = (base + xx) * 4;
              rSum += source[idx];
              gSum += source[idx + 1];
              bSum += source[idx + 2];
              count += 1;
            }
          }
          const target = (y * width + x) * 4;
          data[target] = Math.round(rSum / count);
          data[target + 1] = Math.round(gSum / count);
          data[target + 2] = Math.round(bSum / count);
        }
      }
    }

    function boostSaturation(imageData) {
      if (SATURATION_BOOST <= 1) {
        return;
      }
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        data[i] = Math.max(0, Math.min(255, Math.round(luminance + (r - luminance) * SATURATION_BOOST)));
        data[i + 1] = Math.max(0, Math.min(255, Math.round(luminance + (g - luminance) * SATURATION_BOOST)));
        data[i + 2] = Math.max(0, Math.min(255, Math.round(luminance + (b - luminance) * SATURATION_BOOST)));
      }
    }

    function adjustChannelContrast(value) {
      if (CONTRAST_STRENGTH <= 1) {
        return value;
      }
      const normalized = value / 255;
      const contrasted = ((normalized - 0.5) * CONTRAST_STRENGTH) + 0.5;
      return Math.max(0, Math.min(255, Math.round(contrasted * 255)));
    }

    function applyContrastToImageData(imageData) {
      if (CONTRAST_STRENGTH <= 1) {
        return;
      }
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = adjustChannelContrast(data[i]);
        data[i + 1] = adjustChannelContrast(data[i + 1]);
        data[i + 2] = adjustChannelContrast(data[i + 2]);
      }
    }

    function liftShadows(imageData) {
      if (SHADOW_LIFT_AMOUNT <= 0) {
        return;
      }
      const threshold = Math.max(1, SHADOW_LIFT_THRESHOLD);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (luminance >= threshold) {
          continue;
        }
        const lift = SHADOW_LIFT_AMOUNT * (1 - luminance / threshold);
        data[i] = Math.max(0, Math.min(255, Math.round(r + lift)));
        data[i + 1] = Math.max(0, Math.min(255, Math.round(g + lift)));
        data[i + 2] = Math.max(0, Math.min(255, Math.round(b + lift)));
      }
    }

    function rgbToHsl(r, g, b) {
      const rn = r / 255;
      const gn = g / 255;
      const bn = b / 255;
      const max = Math.max(rn, gn, bn);
      const min = Math.min(rn, gn, bn);
      const chroma = max - min;
      let hue = 0;
      if (chroma !== 0) {
        if (max === rn) {
          hue = ((gn - bn) / chroma + (gn < bn ? 6 : 0)) / 6;
        } else if (max === gn) {
          hue = ((bn - rn) / chroma + 2) / 6;
        } else {
          hue = ((rn - gn) / chroma + 4) / 6;
        }
      }
      const lightness = (max + min) / 2;
      const saturation = chroma === 0 ? 0 : chroma / (1 - Math.abs(2 * lightness - 1));
      return [hue, saturation, lightness];
    }

    function clampByte(value) {
      return Math.max(0, Math.min(255, Math.round(value)));
    }

    function hslToRgb(h, s, l) {
      let hue = h;
      if (!Number.isFinite(hue)) {
        hue = 0;
      }
      hue = ((hue % 1) + 1) % 1;
      const saturation = Math.max(0, Math.min(1, s));
      const lightness = Math.max(0, Math.min(1, l));
      if (saturation === 0) {
        const value = clampByte(lightness * 255);
        return { r: value, g: value, b: value };
      }
      const q = lightness < 0.5
        ? lightness * (1 + saturation)
        : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      const hueToRgb = (t) => {
        let temp = t;
        if (temp < 0) {
          temp += 1;
        }
        if (temp > 1) {
          temp -= 1;
        }
        if (temp < 1 / 6) {
          return p + (q - p) * 6 * temp;
        }
        if (temp < 1 / 2) {
          return q;
        }
        if (temp < 2 / 3) {
          return p + (q - p) * (2 / 3 - temp) * 6;
        }
        return p;
      };
      const r = hueToRgb(hue + 1 / 3);
      const g = hueToRgb(hue);
      const b = hueToRgb(hue - 1 / 3);
      return {
        r: clampByte(r * 255),
        g: clampByte(g * 255),
        b: clampByte(b * 255)
      };
    }

    function refinePaletteForDepth(palette, depth, desired) {
      return palette;
    }



    function buildPaletteFromImage(imageData, desired, depth) {
      const bins = new Map();
      const data = imageData.data;
      const totalPixels = data.length / 4;
      const minCount = Math.max(1, Math.floor(totalPixels * 0.005));
      for (let i = 0; i < data.length; i += 4) {
        const rIndex = getColorBinIndex(data[i]);
        const gIndex = getColorBinIndex(data[i + 1]);
        const bIndex = getColorBinIndex(data[i + 2]);
        const key = (rIndex << 8) | (gIndex << 4) | bIndex;
        const existing = bins.get(key);
        if (existing) {
          existing.count += 1;
        } else {
          bins.set(key, {
            rIndex,
            gIndex,
            bIndex,
            count: 1
          });
        }
      }
      const sortedBins = Array.from(bins.values()).sort((a, b) => b.count - a.count);
      const palette = [];
      for (const bin of sortedBins) {
        const color = {
          r: binIndexToColorValue(bin.rIndex),
          g: binIndexToColorValue(bin.gIndex),
          b: binIndexToColorValue(bin.bIndex),
          count: bin.count
        };
        if (bin.count < minCount && palette.length >= 2) {
          continue;
        }
        palette.push(color);
        if (palette.length >= desired) {
          break;
        }
      }

      ensurePaletteColor(palette, BLACK_COLOR);
      ensurePaletteColor(palette, WHITE_COLOR);

      palette.sort((a, b) => b.count - a.count);
      while (palette.length > desired) {
        palette.pop();
      }

      const trimmed = palette.map(({ r, g, b }) => ({ r, g, b }));
      const refined = refinePaletteForDepth(trimmed, depth, desired);
      return refined.map(({ r, g, b }) => ({ r, g, b }));
    }

    function shouldRebuildPalette(depth, desired) {
      if (depth !== paletteState.depth || desired !== paletteState.desired) {
        return true;
      }
      if (paletteState.userEdited) {
        return false;
      }
      const now = typeof performance !== 'undefined' ? performance.now() : Date.now();
      return now - paletteState.lastUpdated >= PALETTE_HOLD_MS;
    }

    function applyColorDepth(imageData) {
      const depth = state.colorDepth || '4';
      if (depth === 'full') {
        applyPreAverage(imageData);
        boostSaturation(imageData);
        applyContrastToImageData(imageData);
        liftShadows(imageData);
        paletteState.colors = [];
        paletteState.originalColors = [];
        paletteState.cache = new Map();
        paletteState.depth = null;
        paletteState.desired = 0;
        paletteState.lastUpdated = 0;
        paletteState.userEdited = false;
        resetPaletteDisplay();
        return;
      }
      applyPreAverage(imageData);
      boostSaturation(imageData);
      applyContrastToImageData(imageData);
      liftShadows(imageData);
      const timestamp = typeof performance !== 'undefined' ? performance.now() : Date.now();
      if (depth === '4') {
        const needsUpdate = paletteState.depth !== '4'
          || paletteState.colors.length !== FIXED_FOUR_COLOR_PALETTE.length
          || paletteState.originalColors.length !== FIXED_FOUR_COLOR_PALETTE.length;
        if (needsUpdate) {
          applyNewPaletteColors(FIXED_FOUR_COLOR_PALETTE);
          paletteState.depth = '4';
          paletteState.desired = FIXED_FOUR_COLOR_PALETTE.length;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      } else if (depth === '2') {
        const needsUpdate = paletteState.depth !== '2'
          || paletteState.colors.length !== FIXED_TWO_COLOR_PALETTE.length
          || paletteState.originalColors.length !== FIXED_TWO_COLOR_PALETTE.length;
        if (needsUpdate) {
          applyNewPaletteColors(FIXED_TWO_COLOR_PALETTE);
          paletteState.depth = '2';
          paletteState.desired = FIXED_TWO_COLOR_PALETTE.length;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      } else if (depth === 'gray') {
        const dataArr = imageData.data;
        for (let i = 0; i < dataArr.length; i += 4) {
          const value = Math.round(
            0.2126 * dataArr[i] +
            0.7152 * dataArr[i + 1] +
            0.0722 * dataArr[i + 2]
          );
          const clamped = Math.max(0, Math.min(255, value));
          dataArr[i] = clamped;
          dataArr[i + 1] = clamped;
          dataArr[i + 2] = clamped;
        }
        paletteState.colors = [];
        paletteState.originalColors = [];
        paletteState.cache = new Map();
        paletteState.depth = 'gray';
        paletteState.desired = 0;
        paletteState.lastUpdated = timestamp;
        paletteState.userEdited = false;
        resetPaletteDisplay();
        return;
      } else {
        const desiredColors = Math.max(2, Number(depth) || 4);
        if (shouldRebuildPalette(depth, desiredColors)) {
          let palette = buildPaletteFromImage(imageData, desiredColors, depth);
          applyNewPaletteColors(palette);
          paletteState.depth = depth;
          paletteState.desired = desiredColors;
          paletteState.lastUpdated = timestamp;
          updatePaletteDisplay(true);
        }
      }
      const palette = paletteState.colors;
      if (!palette || !palette.length) {
        return;
      }
      const data = imageData.data;
      const cache = paletteState.cache;

      const findNearestColor = (r, g, b, key) => {
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (depth !== '4' && luminance < 48) {
          cache.set(key, BLACK_COLOR);
          return BLACK_COLOR;
        }
        if (depth !== '4' && luminance > 224) {
          cache.set(key, WHITE_COLOR);
          return WHITE_COLOR;
        }
        if (depth === '4' && luminance < FOUR_COLOR_DARK_THRESHOLD) {
          const darkest = palette[palette.length - 1] || { r: 0, g: 0, b: 0 };
          cache.set(key, darkest);
          return darkest;
        }
        let cached = cache.get(key);
        if (cached) {
          return cached;
        }
        let bestIndex = 0;
        let bestDistance = Number.POSITIVE_INFINITY;
        for (let i = 0; i < palette.length; i += 1) {
          const color = palette[i];
          const dr = r - color.r;
          const dg = g - color.g;
          const db = b - color.b;
          const dist = dr * dr + dg * dg + db * db;
          if (dist < bestDistance) {
            bestDistance = dist;
            bestIndex = i;
          }
        }
        cached = palette[bestIndex];
        cache.set(key, cached);
        return cached;
      };

      for (let i = 0; i < data.length; i += 4) {
        const rIndex = getColorBinIndex(data[i]);
        const gIndex = getColorBinIndex(data[i + 1]);
        const bIndex = getColorBinIndex(data[i + 2]);
        const key = (rIndex << 8) | (gIndex << 4) | bIndex;
        const nearest = findNearestColor(data[i], data[i + 1], data[i + 2], key);
        data[i] = nearest.r;
        data[i + 1] = nearest.g;
        data[i + 2] = nearest.b;
      }
    }

    function updateDotModeUI() {
      if (dotModeBtn) {
        dotModeBtn.classList.add('is-active');
        dotModeBtn.setAttribute('aria-pressed', 'true');
        setIconButtonLabel(dotModeBtn, 'ドット設定を開く');
      }
      setDotSettingsOpen(dotScalePanelOpen && state.dotMode);
      if (dotScaleSelect) {
        const value = String(state.dotScale);
        if (dotScaleSelect.value !== value) {
          dotScaleSelect.value = value;
        }
      }
      if (colorDepthSelect) {
        const depthValue = state.colorDepth;
        if (colorDepthSelect.value !== depthValue) {
          colorDepthSelect.value = depthValue;
        }
      }
      updatePaletteToggleAvailability();
      if (paletteDisplayEnabled) {
        updatePaletteDisplay(true);
      } else {
        resetPaletteDisplay();
      }
    }

    function renderDotFrame() {
      if (!state.dotMode || !dotCanvas || !dotCanvasCtx) {
        dotState.frameHandle = null;
        return;
      }
      ensureDotResolution();
      const crop = getDotSourceRect();
      if (video.readyState >= 2 && crop) {
        const targetWidth = dotCanvas.width;
        const targetHeight = dotCanvas.height;
        if (!targetWidth || !targetHeight) {
          dotState.frameHandle = requestAnimationFrame(renderDotFrame);
          return;
        }
        if (smoothingCanvas && smoothingCtx) {
          if (smoothingCanvas.width !== targetWidth || smoothingCanvas.height !== targetHeight) {
            smoothingCanvas.width = targetWidth;
            smoothingCanvas.height = targetHeight;
          }
          smoothingCtx.save();
          smoothingCtx.imageSmoothingEnabled = true;
          smoothingCtx.imageSmoothingQuality = 'high';
          const smoothingFilter = currentCameraFilterString
            ? `blur(${DOT_SMOOTHING_BLUR}px) ${currentCameraFilterString}`
            : `blur(${DOT_SMOOTHING_BLUR}px)`;
          smoothingCtx.filter = smoothingFilter;
          smoothingCtx.clearRect(0, 0, targetWidth, targetHeight);
          if (state.useFrontCamera) {
            smoothingCtx.translate(targetWidth, 0);
            smoothingCtx.scale(-1, 1);
          }
          smoothingCtx.drawImage(
            video,
            crop.sx,
            crop.sy,
            crop.sw,
            crop.sh,
            0,
            0,
            targetWidth,
            targetHeight
          );
          smoothingCtx.restore();
          const imageData = smoothingCtx.getImageData(0, 0, targetWidth, targetHeight);
          applyColorDepth(imageData);
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          dotCanvasCtx.putImageData(imageData, 0, 0);
        } else {
          dotCanvasCtx.save();
          dotCanvasCtx.imageSmoothingEnabled = false;
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          if (state.useFrontCamera) {
            dotCanvasCtx.translate(targetWidth, 0);
            dotCanvasCtx.scale(-1, 1);
          }
          dotCanvasCtx.drawImage(
            video,
            crop.sx,
            crop.sy,
            crop.sw,
            crop.sh,
            0,
            0,
            targetWidth,
            targetHeight
          );
          const imageData = dotCanvasCtx.getImageData(0, 0, targetWidth, targetHeight);
          applyColorDepth(imageData);
          dotCanvasCtx.clearRect(0, 0, targetWidth, targetHeight);
          dotCanvasCtx.putImageData(imageData, 0, 0);
          dotCanvasCtx.restore();
        }
      }
      dotState.frameHandle = requestAnimationFrame(renderDotFrame);
    }

    function startDotRendering() {
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      dotCanvas.hidden = false;
      applyDotCanvasLayoutFromState();
      ensureDotResolution();
      resnapAllOverlaysToDotGrid();
      if (dotState.frameHandle == null) {
        dotState.frameHandle = requestAnimationFrame(renderDotFrame);
      }
    }

    function stopDotRendering() {
      if (dotState.frameHandle != null) {
        cancelAnimationFrame(dotState.frameHandle);
        dotState.frameHandle = null;
      }
      if (dotCanvas) {
        dotCanvas.hidden = true;
      }
    }

    function setDotMode(enabled = true) {
      if (!enabled) {
        return;
      }
      state.dotMode = true;
      updateDotModeUI();
      if (!dotCanvas || !dotCanvasCtx) {
        return;
      }
      startDotRendering();
      resnapAllOverlaysToDotGrid();
      refreshOverlayStatus();
      updatePaletteDisplay(true);
    }

    function getDotGridInfo() {
      if (!state.dotMode || !dotCanvas || !pixelPreview) {
        return null;
      }
      const gridWidth = Number.isFinite(dotState.width) ? dotState.width : 0;
      const gridHeight = Number.isFinite(dotState.height) ? dotState.height : 0;
      if (!gridWidth || !gridHeight) {
        return null;
      }
      const dotRect = dotCanvas.getBoundingClientRect();
      const previewRect = pixelPreview.getBoundingClientRect();
      const layoutWidth = dotRect.width;
      const layoutHeight = dotRect.height;
      const offsetX = dotRect.left - previewRect.left;
      const offsetY = dotRect.top - previewRect.top;
      if (!Number.isFinite(layoutWidth) || !Number.isFinite(layoutHeight) || layoutWidth <= 0 || layoutHeight <= 0) {
        return null;
      }
      const cellWidth = layoutWidth / gridWidth;
      const cellHeight = layoutHeight / gridHeight;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
        return null;
      }
      const cellSize = Math.min(cellWidth, cellHeight);
      return {
        offsetX,
        offsetY,
        cellWidth,
        cellHeight,
        cellSize
      };
    }

    function snapOverlayScale(overlay, scale, constraints = {}) {
      if (!overlay || !overlay.baseWidth || !overlay.baseHeight) {
        return {
          scale: Math.round(Number.isFinite(scale) ? scale : 1),
          snapped: false
        };
      }
      const grid = getDotGridInfo();
      const fallbackScale = Math.round(Number.isFinite(scale) ? scale : overlay.scale || 1);
      if (!grid) {
        return {
          scale: fallbackScale,
          snapped: false
        };
      }
      const { cellWidth, cellHeight, cellSize } = grid;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || !Number.isFinite(cellSize) || cellWidth <= 0 || cellHeight <= 0 || cellSize <= 0) {
        return {
          scale: fallbackScale,
          snapped: false
        };
      }
      const { maxScale: maxConstraint, minScale: minConstraint } = constraints || {};
      const EPSILON = 1e-6;
      const targetScale = Number.isFinite(scale) && scale > 0 ? scale : overlay.scale || cellSize;
      const lowerBound = Number.isFinite(minConstraint)
        ? Math.max(minConstraint, cellSize)
        : cellSize;
      let upperBound = Number.isFinite(maxConstraint)
        ? Math.max(lowerBound, maxConstraint)
        : Number.POSITIVE_INFINITY;
      if (upperBound < cellSize - EPSILON && Number.isFinite(maxConstraint)) {
        return {
          scale: Math.max(overlay.minScale, Math.min(maxConstraint, fallbackScale)),
          snapped: false
        };
      }
      const clampedTarget = Math.max(lowerBound, Math.min(upperBound, targetScale));
      let multiplier = Math.max(1, Math.round(clampedTarget / cellSize));
      let snappedScale = multiplier * cellSize;
      if (Number.isFinite(upperBound) && snappedScale > upperBound + EPSILON) {
        multiplier = Math.max(1, Math.floor(upperBound / cellSize));
        snappedScale = multiplier * cellSize;
      }
      if (!Number.isFinite(snappedScale) || snappedScale <= 0) {
        snappedScale = lowerBound;
      }
      snappedScale = Math.max(lowerBound, Math.min(upperBound, snappedScale));
      return {
        scale: snappedScale,
        snapped: true
      };
    }

    function snapOverlayPosition(overlay, x, y) {
      const targetX = Number.isFinite(x) ? x : overlay.offsetX || 0;
      const targetY = Number.isFinite(y) ? y : overlay.offsetY || 0;
      const grid = getDotGridInfo();
      if (!grid) {
        return {
          x: Math.round(targetX),
          y: Math.round(targetY),
          snapped: false
        };
      }
      const { offsetX, offsetY, cellWidth, cellHeight } = grid;
      if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
        return {
          x: Math.round(targetX),
          y: Math.round(targetY),
          snapped: false
        };
      }
      const relativeX = targetX - offsetX;
      const relativeY = targetY - offsetY;
      const snappedX = offsetX + Math.round(relativeX / cellWidth) * cellWidth;
      const snappedY = offsetY + Math.round(relativeY / cellHeight) * cellHeight;
      return {
        x: Number.isFinite(snappedX) ? snappedX : Math.round(targetX),
        y: Number.isFinite(snappedY) ? snappedY : Math.round(targetY),
        snapped: true
      };
    }

    function getViewportScaleLimit(width, height) {
      if (!width || !height) {
        return 64;
      }
      const widthLimit = Math.max(1, Math.floor((window.innerWidth * 0.9) / width));
      const heightLimit = Math.max(1, Math.floor((window.innerHeight * 0.85) / height));
      return Math.max(1, Math.min(widthLimit, heightLimit));
    }

    function getAnchorPoint(handle, rect) {
      switch (handle) {
        case 'nw':
          return { x: rect.right, y: rect.bottom };
        case 'ne':
          return { x: rect.left, y: rect.bottom };
        case 'sw':
          return { x: rect.right, y: rect.top };
        case 'se':
        default:
          return { x: rect.left, y: rect.top };
      }
    }

    function attachGlobalInteractionListeners() {
      if (interactionState.listenersAttached) {
        return;
      }
      window.addEventListener('pointermove', handleWindowPointerMove, { passive: false });
      window.addEventListener('pointerup', handleWindowPointerUp);
      window.addEventListener('pointercancel', handleWindowPointerUp);
      interactionState.listenersAttached = true;
    }

    function detachGlobalInteractionListeners() {
      if (!interactionState.listenersAttached) {
        return;
      }
      if (interactionState.dragOverlay || interactionState.resizeOverlay) {
        return;
      }
      window.removeEventListener('pointermove', handleWindowPointerMove);
      window.removeEventListener('pointerup', handleWindowPointerUp);
      window.removeEventListener('pointercancel', handleWindowPointerUp);
      interactionState.listenersAttached = false;
    }

    function handleWindowPointerMove(event) {
      if (interactionState.resizeOverlay) {
        if (handleOverlayResizeMove(interactionState.resizeOverlay, event)) {
          return;
        }
      }
      if (interactionState.dragOverlay) {
        handleOverlayDragMove(interactionState.dragOverlay, event);
      }
    }

    function handleWindowPointerUp(event) {
      if (interactionState.resizeOverlay) {
        finishOverlayResize(interactionState.resizeOverlay, event);
      }
      if (interactionState.dragOverlay) {
        finishOverlayDrag(interactionState.dragOverlay, event);
      }
    }

    function createOverlayElements() {
      const wrap = document.createElement('div');
      wrap.className = 'pixel-canvas-wrap';
      wrap.style.left = '24px';
      wrap.style.top = '24px';

      const moveHandle = document.createElement('button');
      moveHandle.type = 'button';
      moveHandle.className = 'pixel-move-handle';
      moveHandle.setAttribute('aria-label', 'ドット絵を移動');
      wrap.appendChild(moveHandle);

      const image = document.createElement('img');
      image.className = 'pixel-canvas';
      image.alt = '';
      wrap.appendChild(image);

      const labelMap = {
        nw: '左上ハンドル',
        ne: '右上ハンドル',
        se: '右下ハンドル',
        sw: '左下ハンドル'
      };

      const handles = ['nw', 'ne', 'se', 'sw'].map((dir) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `pixel-handle pixel-handle--${dir}`;
        button.dataset.handle = dir;
        button.setAttribute('aria-label', labelMap[dir] || 'ハンドル');
        wrap.appendChild(button);
        return button;
      });

      return { wrap, moveHandle, image, handles };
    }

    function updateOverlayStacking() {
      overlays.forEach((item, index) => {
        item.elements.wrap.style.zIndex = String(100 + index);
        pixelPreview.appendChild(item.elements.wrap);
      });
    }

    function promoteOverlay(overlay) {
      const currentIndex = overlays.indexOf(overlay);
      if (currentIndex === -1) {
        return;
      }
      if (currentIndex !== overlays.length - 1) {
        overlays.splice(currentIndex, 1);
        overlays.push(overlay);
      }
      updateOverlayStacking();
    }

    function setActiveOverlay(overlay) {
      if (overlay) {
        promoteOverlay(overlay);
      } else {
        updateOverlayStacking();
      }
      activeOverlay = overlay || null;
      overlays.forEach((item, index) => {
        const isActive = item === activeOverlay;
        item.elements.wrap.classList.toggle('is-active', isActive);
        if (isActive) {
          item.elements.wrap.style.zIndex = String(200 + index);
        } else {
          item.elements.wrap.style.zIndex = String(100 + index);
        }
      });
      const hasOverlays = overlays.length > 0;
      pixelPreview.hidden = !hasOverlays;
      clearPixelBtn.classList.toggle('is-visible', hasOverlays);
      clearPixelBtn.setAttribute('aria-hidden', hasOverlays ? 'false' : 'true');
      clearPixelBtn.disabled = !hasOverlays;
      refreshOverlayStatus();
    }

    function applyOverlayScale(overlay) {
      if (!overlay.hasImage) {
        return;
      }
      const displayWidth = overlay.baseWidth * overlay.scale;
      const displayHeight = overlay.baseHeight * overlay.scale;
      const grid = getDotGridInfo();
      let appliedWidth = displayWidth;
      let appliedHeight = displayHeight;
      let appliedX = overlay.offsetX;
      let appliedY = overlay.offsetY;
      const EPSILON = 1e-6;
      if (grid && Number.isFinite(grid.cellWidth) && Number.isFinite(grid.cellHeight) && grid.cellWidth > EPSILON && grid.cellHeight > EPSILON) {
        appliedWidth = Math.max(grid.cellWidth, Math.round(displayWidth / grid.cellWidth) * grid.cellWidth);
        appliedHeight = Math.max(grid.cellHeight, Math.round(displayHeight / grid.cellHeight) * grid.cellHeight);
        const relativeX = overlay.offsetX - grid.offsetX;
        const relativeY = overlay.offsetY - grid.offsetY;
        appliedX = grid.offsetX + Math.round(relativeX / grid.cellWidth) * grid.cellWidth;
        appliedY = grid.offsetY + Math.round(relativeY / grid.cellHeight) * grid.cellHeight;
      }
      overlay.elements.image.style.width = `${appliedWidth}px`;
      overlay.elements.image.style.height = `${appliedHeight}px`;
      overlay.elements.wrap.style.width = `${appliedWidth}px`;
      overlay.elements.wrap.style.height = `${appliedHeight}px`;
      overlay.elements.wrap.style.left = `${appliedX}px`;
      overlay.elements.wrap.style.top = `${appliedY}px`;
      overlay.offsetX = appliedX;
      overlay.offsetY = appliedY;
    }

    function setOverlayScale(overlay, scale) {
      if (!overlay.hasImage) {
        return;
      }
      const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
      const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
      const limited = Math.max(overlay.minScale, Math.min(maxScale, Number.isFinite(scale) ? scale : overlay.scale || overlay.minScale));
      const snappedScale = snapOverlayScale(overlay, limited, { maxScale, minScale: overlay.minScale });
      let desiredScale = snappedScale.scale;
      if (!snappedScale.snapped) {
        desiredScale = Math.round(desiredScale);
      }
      let clamped = Math.max(overlay.minScale, Math.min(maxScale, desiredScale));
      if (!Number.isFinite(clamped) || clamped <= 0) {
        clamped = overlay.minScale;
      }
      if (clamped !== overlay.scale) {
        overlay.scale = clamped;
      }
      const snappedPosition = snapOverlayPosition(overlay, overlay.offsetX, overlay.offsetY);
      const finalX = Number.isFinite(snappedPosition.x) ? snappedPosition.x : overlay.offsetX;
      const finalY = Number.isFinite(snappedPosition.y) ? snappedPosition.y : overlay.offsetY;
      overlay.offsetX = finalX;
      overlay.offsetY = finalY;
      applyOverlayScale(overlay);
      if (overlay === activeOverlay) {
        refreshOverlayStatus();
      }
    }

    function resnapAllOverlaysToDotGrid() {
      if (!state.dotMode || !dotState.width || !dotState.height) {
        return;
      }
      overlays.forEach((overlay) => {
        if (!overlay.hasImage) {
          return;
        }
        setOverlayScale(overlay, overlay.scale);
      });
    }

    function startOverlayDrag(overlay, event, captureTarget) {
      if (!overlay.hasImage || overlay.resize) {
        return;
      }
      if (typeof event.button === 'number' && event.button !== 0) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setActiveOverlay(overlay);
      if (overlay.resize) {
        overlay.resize = null;
        if (interactionState.resizeOverlay === overlay) {
          interactionState.resizeOverlay = null;
        }
      }
      overlay.drag = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        originX: overlay.offsetX,
        originY: overlay.offsetY,
        captureTarget: captureTarget || overlay.elements.wrap
      };
      interactionState.dragOverlay = overlay;
      try {
        overlay.drag.captureTarget.setPointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay pointer capture failed', error);
      }
      attachGlobalInteractionListeners();
    }

    function handleOverlayDragMove(overlay, event) {
      const drag = overlay.drag;
      if (!drag || event.pointerId !== drag.pointerId) {
        return false;
      }
      event.preventDefault();
      const deltaX = event.clientX - drag.startX;
      const deltaY = event.clientY - drag.startY;
      const snapped = snapOverlayPosition(overlay, drag.originX + deltaX, drag.originY + deltaY);
      overlay.offsetX = Number.isFinite(snapped.x) ? snapped.x : drag.originX + deltaX;
      overlay.offsetY = Number.isFinite(snapped.y) ? snapped.y : drag.originY + deltaY;
      overlay.elements.wrap.style.left = `${overlay.offsetX}px`;
      overlay.elements.wrap.style.top = `${overlay.offsetY}px`;
      return true;
    }

    function finishOverlayDrag(overlay, event) {
      const drag = overlay.drag;
      if (!drag || event.pointerId !== drag.pointerId) {
        return false;
      }
      try {
        drag.captureTarget.releasePointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay pointer release failed', error);
      }
      overlay.drag = null;
      if (interactionState.dragOverlay === overlay) {
        interactionState.dragOverlay = null;
      }
      const snappedPosition = snapOverlayPosition(overlay, overlay.offsetX, overlay.offsetY);
      if (Number.isFinite(snappedPosition.x)) {
        overlay.offsetX = snappedPosition.x;
      }
      if (Number.isFinite(snappedPosition.y)) {
        overlay.offsetY = snappedPosition.y;
      }
      applyOverlayScale(overlay);
      detachGlobalInteractionListeners();
      refreshOverlayStatus();
      return true;
    }

    function startOverlayResize(overlay, handle, event) {
      if (!overlay.hasImage || !overlay.baseWidth || !overlay.baseHeight) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      setActiveOverlay(overlay);
      if (overlay.drag) {
        overlay.drag = null;
        if (interactionState.dragOverlay === overlay) {
          interactionState.dragOverlay = null;
        }
      }
      const rect = overlay.elements.wrap.getBoundingClientRect();
      const anchor = getAnchorPoint(handle.dataset.handle, rect);
      overlay.resize = {
        pointerId: event.pointerId,
        handle,
        anchorX: anchor.x,
        anchorY: anchor.y
      };
      interactionState.resizeOverlay = overlay;
      try {
        handle.setPointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay resize capture failed', error);
      }
      attachGlobalInteractionListeners();
    }

    function handleOverlayResizeMove(overlay, event) {
      const resize = overlay.resize;
      if (!resize || event.pointerId !== resize.pointerId) {
        return false;
      }
      if (!overlay.baseWidth || !overlay.baseHeight) {
        return false;
      }
      event.preventDefault();
      event.stopPropagation();
      const distX = Math.abs(event.clientX - resize.anchorX);
      const distY = Math.abs(event.clientY - resize.anchorY);
      const targetWidth = Math.max(distX, 1);
      const targetHeight = Math.max(distY, 1);
      const desiredScale = Math.max(
        targetWidth / overlay.baseWidth,
        targetHeight / overlay.baseHeight
      );
      setOverlayScale(overlay, desiredScale);
      return true;
    }

    function finishOverlayResize(overlay, event) {
      const resize = overlay.resize;
      if (!resize || event.pointerId !== resize.pointerId) {
        return false;
      }
      event.preventDefault();
      event.stopPropagation();
      try {
        resize.handle.releasePointerCapture(event.pointerId);
      } catch (error) {
        console.debug('overlay resize release failed', error);
      }
      overlay.resize = null;
      if (interactionState.resizeOverlay === overlay) {
        interactionState.resizeOverlay = null;
      }
      setOverlayScale(overlay, overlay.scale);
      detachGlobalInteractionListeners();
      refreshOverlayStatus();
      return true;
    }

    function setupOverlayEvents(overlay) {
      const { wrap, moveHandle, handles } = overlay.elements;

      wrap.addEventListener('pointerdown', (event) => {
        if (!overlay.hasImage || overlay.resize) {
          return;
        }
        if (handles.includes(event.target) || event.target === moveHandle) {
          return;
        }
        if (typeof event.button === 'number' && event.button !== 0) {
          return;
        }
        startOverlayDrag(overlay, event, wrap);
      });

      wrap.addEventListener('pointermove', (event) => {
        handleOverlayDragMove(overlay, event);
      });

      wrap.addEventListener('pointerup', (event) => {
        finishOverlayDrag(overlay, event);
      });

      wrap.addEventListener('pointercancel', (event) => {
        finishOverlayDrag(overlay, event);
      });

      wrap.addEventListener('contextmenu', (event) => {
        if (overlay.hasImage) {
          event.preventDefault();
        }
      });

      wrap.addEventListener('click', (event) => {
        if (!overlay.hasImage) {
          return;
        }
        setActiveOverlay(overlay);
        event.stopPropagation();
      });

      moveHandle.addEventListener('pointerdown', (event) => {
        if (!overlay.hasImage || overlay.resize) {
          return;
        }
        startOverlayDrag(overlay, event, moveHandle);
      });

      moveHandle.addEventListener('pointermove', (event) => {
        handleOverlayDragMove(overlay, event);
      });

      moveHandle.addEventListener('pointerup', (event) => {
        finishOverlayDrag(overlay, event);
      });

      moveHandle.addEventListener('pointercancel', (event) => {
        finishOverlayDrag(overlay, event);
      });

      moveHandle.addEventListener('click', (event) => {
        event.stopPropagation();
      });

      handles.forEach((handle) => {
        handle.addEventListener('pointerdown', (event) => startOverlayResize(overlay, handle, event));
        handle.addEventListener('pointermove', (event) => handleOverlayResizeMove(overlay, event));
        handle.addEventListener('pointerup', (event) => finishOverlayResize(overlay, event));
        handle.addEventListener('pointercancel', (event) => finishOverlayResize(overlay, event));
        handle.addEventListener('click', (event) => event.stopPropagation());
      });
    }

    function removeOverlay(overlay) {
      if (!overlay) {
        return;
      }
      const index = overlays.indexOf(overlay);
      if (index === -1) {
        return;
      }
      if (interactionState.dragOverlay === overlay) {
        interactionState.dragOverlay = null;
      }
      if (interactionState.resizeOverlay === overlay) {
        interactionState.resizeOverlay = null;
      }
      if (overlay.drag && overlay.drag.captureTarget) {
        try {
          overlay.drag.captureTarget.releasePointerCapture(overlay.drag.pointerId);
        } catch (error) {
          console.debug('overlay pointer release cleanup failed', error);
        }
      }
      if (overlay.resize && overlay.resize.handle) {
        try {
          overlay.resize.handle.releasePointerCapture(overlay.resize.pointerId);
        } catch (error) {
          console.debug('overlay resize release cleanup failed', error);
        }
      }
      overlay.drag = null;
      overlay.resize = null;
      overlays.splice(index, 1);
      updateOverlayStacking();
      if (overlay.objectUrl) {
        URL.revokeObjectURL(overlay.objectUrl);
      }
      if (overlay.elements.wrap.parentElement === pixelPreview) {
        pixelPreview.removeChild(overlay.elements.wrap);
      }
      if (activeOverlay === overlay) {
        activeOverlay = null;
      }
      if (overlays.length > 0) {
        setActiveOverlay(overlays[overlays.length - 1]);
      } else {
        pixelPreview.hidden = true;
        clearPixelBtn.classList.remove('is-visible');
        clearPixelBtn.setAttribute('aria-hidden', 'true');
        clearPixelBtn.disabled = true;
        refreshOverlayStatus();
      }
      detachGlobalInteractionListeners();
    }

    function clearActiveOverlay() {
      if (!activeOverlay) {
        return;
      }
      removeOverlay(activeOverlay);
    }

    function createOverlayFromImageSource(imageSrc, { objectUrl = null } = {}) {
      if (!imageSrc) {
        return Promise.resolve(false);
      }
      return new Promise((resolve) => {
        const overlay = {
          id: `overlay-${Date.now()}-${Math.random().toString(16).slice(2)}`,
          objectUrl,
          hasImage: false,
          baseWidth: 0,
          baseHeight: 0,
          scale: 1,
          minScale: 1,
          maxScale: 64,
          offsetX: 24,
          offsetY: 24,
          drag: null,
          resize: null,
          elements: createOverlayElements()
        };

        setupOverlayEvents(overlay);
        pixelPreview.appendChild(overlay.elements.wrap);
        pixelPreview.hidden = false;
        overlays.push(overlay);
        setActiveOverlay(overlay);

        overlay.elements.image.onload = () => {
          overlay.elements.image.onload = null;
          overlay.elements.image.onerror = null;
          overlay.hasImage = true;
          overlay.baseWidth = overlay.elements.image.naturalWidth || overlay.elements.image.width;
          overlay.baseHeight = overlay.elements.image.naturalHeight || overlay.elements.image.height;
          const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
          const initialScaleCandidate = Math.min(
            viewportLimit,
            Math.max(1, Math.floor((window.innerWidth * 0.35) / overlay.baseWidth)),
            Math.max(1, Math.floor((window.innerHeight * 0.35) / overlay.baseHeight))
          ) || 1;
          const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
          overlay.scale = Math.max(overlay.minScale, Math.min(maxScale, initialScaleCandidate));
          const displayWidth = overlay.baseWidth * overlay.scale;
          const displayHeight = overlay.baseHeight * overlay.scale;
          const offsetStep = Math.min(overlays.length - 1, 5) * 32;
          overlay.offsetX = Math.round((window.innerWidth - displayWidth) / 2 + offsetStep);
          overlay.offsetY = Math.round((window.innerHeight - displayHeight) / 2 + offsetStep);
          if (!Number.isFinite(overlay.offsetX)) {
            overlay.offsetX = 24;
          }
          if (!Number.isFinite(overlay.offsetY)) {
            overlay.offsetY = 24;
          }
          setOverlayScale(overlay, overlay.scale);
          overlay.elements.wrap.classList.add('is-active');
          clearPixelBtn.classList.add('is-visible');
          clearPixelBtn.setAttribute('aria-hidden', 'false');
          clearPixelBtn.disabled = false;
          refreshOverlayStatus();
          resolve(true);
        };

        overlay.elements.image.onerror = () => {
          overlay.elements.image.onload = null;
          overlay.elements.image.onerror = null;
          removeOverlay(overlay);
          setStatus('ドット絵を読み込めませんでした');
          resolve(false);
        };

        overlay.elements.image.src = imageSrc;
      });
    }

    function loadPixelArt(file) {
      if (!file) {
        return Promise.resolve(false);
      }
      const objectUrl = URL.createObjectURL(file);
      return createOverlayFromImageSource(objectUrl, { objectUrl });
    }

    pixelArtBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      closeAllMenus();
      pixelArtInput.click();
    });

    pixelArtInput.addEventListener('change', async (event) => {
      const files = Array.from(event.target.files || []);
      for (const file of files) {
        await loadPixelArt(file);
      }
      pixelArtInput.value = '';
    });

    clearPixelBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      closeAllMenus();
      clearActiveOverlay();
    });

    if (cameraActionBtn) {
      cameraActionBtn.addEventListener('click', async () => {
        if (state.restarting) {
          return;
        }
        closeAllMenus();
        if (cameraActionMode === 'switch') {
          state.useFrontCamera = !state.useFrontCamera;
        }
        await startCamera();
      });
    }

    if (aspectMenuBtn) {
      aspectMenuBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('aspect');
      });
    }

    if (stampBtn) {
      stampBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('stamps');
      });
    }

    if (cameraSettingsBtn) {
      cameraSettingsBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu('cameraSettings');
      });
    }

    cameraSettingSliders.forEach((slider) => {
      const key = slider.dataset.setting;
      if (!key) {
        return;
      }
      slider.addEventListener('input', (event) => {
        event.stopPropagation();
        setCameraSettingValue(key, slider.value);
        slider.setAttribute('aria-valuenow', slider.value);
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(Number(slider.value), key));
      });
      slider.addEventListener('change', (event) => {
        event.stopPropagation();
        setCameraSettingValue(key, slider.value);
        slider.setAttribute('aria-valuenow', slider.value);
        slider.setAttribute('aria-valuetext', formatCameraSettingValue(Number(slider.value), key));
      });
      slider.addEventListener('pointerdown', (event) => {
        event.stopPropagation();
      });
      slider.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });

    if (cameraSettingsResetBtn) {
      cameraSettingsResetBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        resetCameraSettings();
      });
    }

    if (paletteToggleBtn) {
      paletteToggleBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (paletteToggleBtn.disabled) {
          return;
        }
        const nextState = !paletteDisplayEnabled;
        if (nextState && !dotScalePanelOpen) {
          openMenuExclusive('dotScale');
        }
        setPaletteDisplayEnabled(nextState);
      });
    }

    if (dotModeBtn) {
      dotModeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        setDotMode(true);
        if (dotScalePanelOpen && dotSettingsPanel && !dotSettingsPanel.hidden) {
          closeAllMenus();
        } else {
          openMenuExclusive('dotScale');
        }
      });
    }

    function getVideoCoverSourceRect(viewportWidth, viewportHeight) {
      if (!video) {
        return null;
      }
      const videoWidth = Number.isFinite(video.videoWidth) ? video.videoWidth : 0;
      const videoHeight = Number.isFinite(video.videoHeight) ? video.videoHeight : 0;
      if (!videoWidth || !videoHeight) {
        return null;
      }
      const displayWidth = Math.max(1, Number.isFinite(viewportWidth) ? viewportWidth : videoWidth);
      const displayHeight = Math.max(1, Number.isFinite(viewportHeight) ? viewportHeight : videoHeight);
      const scale = Math.max(displayWidth / videoWidth, displayHeight / videoHeight);
      if (!Number.isFinite(scale) || scale <= 0) {
        return null;
      }
      const visibleWidth = displayWidth / scale;
      const visibleHeight = displayHeight / scale;
      const sx = Math.max(0, (videoWidth - visibleWidth) / 2);
      const sy = Math.max(0, (videoHeight - visibleHeight) / 2);
      return {
        sx,
        sy,
        sw: Math.min(videoWidth, visibleWidth),
        sh: Math.min(videoHeight, visibleHeight)
      };
    }

    function drawVideoLayer(ctx, viewportWidth, viewportHeight) {
      if (!video || video.readyState < 2) {
        return false;
      }
      const source = getVideoCoverSourceRect(viewportWidth, viewportHeight);
      if (!source) {
        return false;
      }
      ctx.save();
      ctx.filter = currentCameraFilterString || 'none';
      if (state.useFrontCamera) {
        ctx.translate(viewportWidth, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(
        video,
        source.sx,
        source.sy,
        source.sw,
        source.sh,
        0,
        0,
        viewportWidth,
        viewportHeight
      );
      ctx.restore();
      return true;
    }

    function drawDotLayer(ctx) {
      if (!state.dotMode || !dotCanvas || dotCanvas.hidden) {
        return;
      }
      const rect = dotCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(dotCanvas, rect.left, rect.top, rect.width, rect.height);
      ctx.restore();
    }

    function drawPixelOverlaysLayer(ctx) {
      if (!overlays.length) {
        return;
      }
      overlays.forEach((overlay) => {
        if (!overlay || !overlay.hasImage || !overlay.elements || !overlay.elements.image) {
          return;
        }
        const width = overlay.baseWidth * overlay.scale;
        const height = overlay.baseHeight * overlay.scale;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
          return;
        }
        const x = Number.isFinite(overlay.offsetX) ? overlay.offsetX : 0;
        const y = Number.isFinite(overlay.offsetY) ? overlay.offsetY : 0;
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(overlay.elements.image, x, y, width, height);
        ctx.restore();
      });
    }

    function drawCaptureLayers(ctx, viewportWidth, viewportHeight) {
      const videoDrawn = drawVideoLayer(ctx, viewportWidth, viewportHeight);
      drawDotLayer(ctx);
      drawPixelOverlaysLayer(ctx);
      return videoDrawn || (state.dotMode && dotCanvas && !dotCanvas.hidden) || overlays.length > 0;
    }

    function getCaptureViewportRect(viewportWidth, viewportHeight) {
      const width = Math.max(1, Number.isFinite(viewportWidth) ? viewportWidth : 0);
      const height = Math.max(1, Number.isFinite(viewportHeight) ? viewportHeight : 0);
      if (!width || !height) {
        return { x: 0, y: 0, width: 0, height: 0 };
      }
      const layout = dotState.layout || {};
      if (!layout.width || !layout.height) {
        return { x: 0, y: 0, width, height };
      }
      const offsetX = Number.isFinite(layout.offsetX) ? layout.offsetX : 0;
      const offsetY = Number.isFinite(layout.offsetY) ? layout.offsetY : 0;
      const cropWidth = Math.max(1, Math.min(width, Math.round(layout.width)));
      const cropHeight = Math.max(1, Math.min(height, Math.round(layout.height)));
      const x = Math.max(0, Math.min(width - 1, Math.round(offsetX)));
      const y = Math.max(0, Math.min(height - 1, Math.round(offsetY)));
      const adjustedWidth = Math.max(1, Math.min(cropWidth, width - x));
      const adjustedHeight = Math.max(1, Math.min(cropHeight, height - y));
      return {
        x,
        y,
        width: adjustedWidth,
        height: adjustedHeight
      };
    }

    function canvasToBlobWithFallback(canvas) {
      return new Promise((resolve) => {
        if (!canvas) {
          resolve({ blob: null, dataUrl: null });
          return;
        }
        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (blob) {
              resolve({ blob, dataUrl: null });
            } else {
              resolve({ blob: null, dataUrl: canvas.toDataURL('image/png') });
            }
          }, 'image/png');
          return;
        }
        resolve({ blob: null, dataUrl: canvas.toDataURL('image/png') });
      });
    }

    function composeCaptureFrame() {
      const viewportWidth = Math.max(1, Math.round(window.innerWidth || 0));
      const viewportHeight = Math.max(1, Math.round(window.innerHeight || 0));
      if (!viewportWidth || !viewportHeight) {
        return Promise.resolve(null);
      }
      const deviceRatio = window.devicePixelRatio || 1;
      const pixelRatio = Math.min(Math.max(deviceRatio, 1), 2.5);
      const viewportCanvas = document.createElement('canvas');
      viewportCanvas.width = Math.max(1, Math.round(viewportWidth * pixelRatio));
      viewportCanvas.height = Math.max(1, Math.round(viewportHeight * pixelRatio));
      const ctx = viewportCanvas.getContext('2d', { willReadFrequently: false });
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, viewportCanvas.width, viewportCanvas.height);
      ctx.save();
      ctx.scale(pixelRatio, pixelRatio);
      const hasContent = drawCaptureLayers(ctx, viewportWidth, viewportHeight);
      ctx.restore();
      if (!hasContent) {
        return Promise.resolve(null);
      }
      const captureRect = getCaptureViewportRect(viewportWidth, viewportHeight);
      const cropX = Math.max(0, Math.min(viewportWidth, captureRect.x));
      const cropY = Math.max(0, Math.min(viewportHeight, captureRect.y));
      const cropWidth = Math.max(1, Math.min(viewportWidth - cropX, captureRect.width));
      const cropHeight = Math.max(1, Math.min(viewportHeight - cropY, captureRect.height));
      const isFullViewport =
        Math.abs(cropX) < 0.5 &&
        Math.abs(cropY) < 0.5 &&
        Math.abs(cropWidth - viewportWidth) < 0.5 &&
        Math.abs(cropHeight - viewportHeight) < 0.5;
      let outputCanvas = viewportCanvas;
      let outputWidth = viewportCanvas.width;
      let outputHeight = viewportCanvas.height;
      if (!isFullViewport) {
        const sx = Math.max(0, Math.min(viewportCanvas.width - 1, Math.round(cropX * pixelRatio)));
        const sy = Math.max(0, Math.min(viewportCanvas.height - 1, Math.round(cropY * pixelRatio)));
        const sw = Math.max(1, Math.min(viewportCanvas.width - sx, Math.round(cropWidth * pixelRatio)));
        const sh = Math.max(1, Math.min(viewportCanvas.height - sy, Math.round(cropHeight * pixelRatio)));
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = sw;
        croppedCanvas.height = sh;
        const croppedCtx = croppedCanvas.getContext('2d', { willReadFrequently: false });
        croppedCtx.drawImage(
          viewportCanvas,
          sx,
          sy,
          sw,
          sh,
          0,
          0,
          sw,
          sh
        );
        outputCanvas = croppedCanvas;
        outputWidth = sw;
        outputHeight = sh;
      }
      return canvasToBlobWithFallback(outputCanvas).then((payload) => ({
        ...payload,
        width: outputWidth,
        height: outputHeight,
        cssWidth: Math.round(outputWidth / pixelRatio),
        cssHeight: Math.round(outputHeight / pixelRatio)
      }));
    }

    function getCaptureFilename() {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      return `pixiee-lens-${timestamp}.png`;
    }

    function downloadCaptureResult(result, filename) {
      if (!result) {
        return false;
      }
      let linkTarget = null;
      let objectUrl = null;
      if (result.blob instanceof Blob) {
        objectUrl = URL.createObjectURL(result.blob);
        linkTarget = objectUrl;
      } else if (typeof result.dataUrl === 'string' && result.dataUrl.startsWith('data:image/png')) {
        linkTarget = result.dataUrl;
      }
      if (!linkTarget) {
        return false;
      }
      const canUseDownloadAttr = 'download' in HTMLAnchorElement.prototype;
      const isIOS = /iP(hone|ad|od)/i.test(navigator.userAgent);
      if (!canUseDownloadAttr || isIOS) {
        const fallbackWindow = window.open('', '_blank', 'noopener');
        if (!fallbackWindow) {
          if (objectUrl) {
            setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
          }
          return false;
        }
        fallbackWindow.document.title = 'PiXiEED Capture';
        fallbackWindow.document.body.style.margin = '0';
        fallbackWindow.document.body.style.display = 'flex';
        fallbackWindow.document.body.style.flexDirection = 'column';
        fallbackWindow.document.body.style.alignItems = 'center';
        fallbackWindow.document.body.style.justifyContent = 'center';
        fallbackWindow.document.body.style.background = '#050812';
        fallbackWindow.document.body.style.color = '#e7eeff';
        const instructions = fallbackWindow.document.createElement('div');
        instructions.style.fontFamily = 'system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        instructions.style.padding = '16px';
        instructions.style.textAlign = 'center';
        instructions.innerHTML = `
          <p>この画像を長押しして「写真に追加」または「保存」してください。</p>
        `;
        const image = fallbackWindow.document.createElement('img');
        image.src = linkTarget;
        image.alt = 'Captured photo';
        image.style.maxWidth = '100%';
        image.style.height = 'auto';
        image.style.display = 'block';
        image.style.borderRadius = '12px';
        fallbackWindow.document.body.appendChild(instructions);
        fallbackWindow.document.body.appendChild(image);
        if (objectUrl) {
          fallbackWindow.addEventListener('pagehide', () => {
            setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
          });
        }
        return true;
      }
      const anchor = document.createElement('a');
      anchor.href = linkTarget;
      anchor.download = filename;
      anchor.rel = 'noopener';
      anchor.style.position = 'absolute';
      anchor.style.left = '-9999px';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      if (objectUrl) {
        setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
      }
      return true;
    }

    async function handleCaptureAction() {
      if (captureInProgress) {
        return;
      }
      if (!cameraReady || !state.stream || !video || video.readyState < 2) {
        setStatus('カメラの準備が完了してから撮影してください');
        return;
      }
      captureInProgress = true;
      if (captureBtn) {
        captureBtn.disabled = true;
        captureBtn.setAttribute('aria-busy', 'true');
      }
      try {
        const result = await composeCaptureFrame();
        if (!result || (!result.blob && !result.dataUrl)) {
          setStatus('撮影に失敗しました');
          return;
        }
        const filename = getCaptureFilename();
        const saved = downloadCaptureResult(result, filename);
        if (!saved) {
          setStatus('撮影データを保存できませんでした');
          return;
        }
        setStatus(`撮影しました: ${result.width}×${result.height}px`);
      } catch (error) {
        console.error(error);
        setStatus('撮影に失敗しました');
      } finally {
        captureInProgress = false;
        if (captureBtn) {
          captureBtn.disabled = false;
          captureBtn.removeAttribute('aria-busy');
        }
      }
    }

    if (captureBtn) {
      captureBtn.addEventListener('click', async (event) => {
        event.stopPropagation();
        closeAllMenus();
        await handleCaptureAction();
      });
    }

    aspectButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const mode = button.dataset.aspect || '3:2';
        setAspectMode(mode);
      });
    });

    if (dotScaleSelect) {
      ['mousedown', 'touchstart', 'pointerdown', 'click'].forEach((type) => {
        dotScaleSelect.addEventListener(type, (event) => {
          event.stopPropagation();
        });
      });
      dotScaleSelect.addEventListener('change', () => {
        const value = Number(dotScaleSelect.value);
        if (!Number.isFinite(value)) {
          return;
        }
        if (value === state.dotScale) {
          return;
        }
        state.dotScale = Math.max(1, Math.min(4, Math.round(value)));
        ensureDotResolution();
        if (state.dotMode) {
          refreshOverlayStatus();
        }
        updateDotModeUI();
      });
    }

    if (colorDepthSelect) {
      ['mousedown', 'touchstart', 'pointerdown', 'click'].forEach((type) => {
        colorDepthSelect.addEventListener(type, (event) => {
          event.stopPropagation();
        });
      });
      colorDepthSelect.addEventListener('change', () => {
        const value = colorDepthSelect.value;
        if (!COLOR_DEPTHS.includes(value)) {
          return;
        }
        if (value === state.colorDepth) {
          return;
        }
        state.colorDepth = value;
        if (state.dotMode) {
          refreshOverlayStatus();
        }
        updateDotModeUI();
      });
    }

    pixelPreview.addEventListener('click', (event) => {
      event.stopPropagation();
    });

    document.addEventListener('click', (event) => {
      if (!openMenuKey) {
        return;
      }
      if (openMenuKey === 'dotScale') {
        if (!dotSettingsPanel || !dotModeBtn) {
          openMenuKey = null;
          return;
        }
        if (!dotSettingsPanel.contains(event.target) && !dotModeBtn.contains(event.target)) {
          setDotSettingsOpen(false);
        }
        return;
      }
      const entry = menus[openMenuKey];
      if (!entry || !entry.panel || !entry.button) {
        openMenuKey = null;
        return;
      }
      if (!entry.panel.contains(event.target) && !entry.button.contains(event.target)) {
        closeMenu(openMenuKey);
      }
    });

    document.addEventListener('click', (event) => {
      if (!overlays.length) {
        return;
      }
      if (pixelArtBtn.contains(event.target) || clearPixelBtn.contains(event.target)) {
        return;
      }
      const clickedOverlay = overlays.find((overlay) => overlay.elements.wrap.contains(event.target));
      if (clickedOverlay) {
        setActiveOverlay(clickedOverlay);
        return;
      }
      if (interactionState.dragOverlay || interactionState.resizeOverlay) {
        return;
      }
      setActiveOverlay(null);
    });

    function stopCamera() {
      if (state.stream) {
        state.stream.getTracks().forEach((track) => track.stop());
        state.stream = null;
      }
      video.srcObject = null;
      stopDotRendering();
      cameraReady = false;
      cameraZoomCapability = null;
      cameraZoomCapabilityKnown = false;
      updateZoomSliderAvailability();
      updateCameraActionState();
    }

    async function startCamera() {
      if (state.restarting) {
        return;
      }
      state.restarting = true;
      setCameraStatus('カメラを初期化しています…');
      cameraReady = false;
      updateCameraActionState();
      cameraZoomCapability = null;
      cameraZoomCapabilityKnown = false;
      updateZoomSliderAvailability();

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setCameraStatus('このブラウザはカメラアクセスに対応していません。');
        cameraPermissionDenied = false;
        updateCameraActionState();
        state.restarting = false;
        updateCameraActionState();
        return;
      }

      try {
        stopCamera();
        const constraints = {
          video: {
            facingMode: state.useFrontCamera ? 'user' : { ideal: 'environment' },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        state.stream = stream;
        cameraConstraintErrorLogged = false;
        video.srcObject = stream;
        const track = getActiveVideoTrack();
        if (track && typeof track.getCapabilities === 'function') {
          try {
            const capabilities = track.getCapabilities();
            cameraZoomCapabilityKnown = true;
            if (capabilities && Object.prototype.hasOwnProperty.call(capabilities, 'zoom')) {
              cameraZoomCapability = capabilities.zoom;
              syncZoomStateFromTrack(track);
            } else {
              cameraZoomCapability = null;
            }
          } catch (error) {
            cameraZoomCapability = null;
            cameraZoomCapabilityKnown = false;
          }
        }
        updateZoomSliderAvailability();
        await video.play().catch(() => {});
        video.style.transform = state.useFrontCamera ? 'scaleX(-1)' : 'scaleX(1)';
        applyCameraSettings();
        cameraPermissionDenied = false;
        cameraReady = true;
        updateCameraActionState();
        const cameraStatus = state.useFrontCamera ? 'フロントカメラ表示中' : '';
        setCameraStatus(cameraStatus);
        updateAspectLayout();
        if (state.dotMode) {
          startDotRendering();
        } else {
          stopDotRendering();
        }
      } catch (error) {
        console.error(error);
        const isPermissionError = error && (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError');
        cameraPermissionDenied = Boolean(isPermissionError);
        cameraReady = false;
        setStatus('カメラにアクセスできませんでした。設定をご確認ください。');
        setCameraStatus('カメラにアクセスできませんでした。設定をご確認ください。');
        updateCameraActionState();
        stopDotRendering();
      } finally {
        state.restarting = false;
        updateCameraActionState();
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopCamera();
      } else {
        startCamera();
      }
    });

    window.addEventListener('beforeunload', stopCamera);
    window.addEventListener('pagehide', stopCamera);

    window.addEventListener('resize', () => {
      updateAspectLayout();
      if (state.dotMode) {
        ensureDotResolution();
      }
      updateControlPlacement();
      overlays.forEach((overlay) => {
        if (!overlay.hasImage) {
          return;
        }
        const viewportLimit = getViewportScaleLimit(overlay.baseWidth, overlay.baseHeight);
        const maxScale = Math.max(overlay.minScale, Math.min(overlay.maxScale, viewportLimit));
        if (overlay.scale > maxScale) {
          setOverlayScale(overlay, maxScale);
        } else {
          setOverlayScale(overlay, overlay.scale);
        }
      });
      refreshOverlayStatus();
    });

    if (window.visualViewport) {
      const handleViewportChange = () => {
        updateAspectLayout();
        if (state.dotMode) {
          ensureDotResolution();
        }
        updateControlPlacement();
      };
      window.visualViewport.addEventListener('resize', handleViewportChange);
      window.visualViewport.addEventListener('scroll', handleViewportChange);
    }

    const handleOrientationChange = () => {
      updateControlPlacement();
    };

    window.addEventListener('orientationchange', handleOrientationChange);
    if (window.screen && window.screen.orientation && typeof window.screen.orientation.addEventListener === 'function') {
      window.screen.orientation.addEventListener('change', handleOrientationChange);
    }

    updatePaletteToggleAvailability();
    setDotMode(true);
    updateDotModeUI();
    setAspectMode(state.aspectMode);
    updateControlPlacement();
    startCamera();
  </script>
</body>
</html>
    .icon-button--ghost {
      background: transparent;
      border-color: transparent;
      box-shadow: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease;
    }
    .icon-button--ghost.is-visible {
      pointer-events: auto;
      opacity: 1;
      background: rgba(123, 207, 255, 0.2);
      border-color: rgba(123, 207, 255, 0.35);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.32);
    }
