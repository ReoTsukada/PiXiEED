<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>QRコードメーカー | PiXiEED</title>
<meta content="URLやテキストをブラウザ上で即座にQRコード化。サイズ・余白・誤り訂正・色を調整してPNG保存できる軽量ツールです。" name="description"/>
<meta content="website" property="og:type"/>
<meta content="QRコードメーカー | PiXiEED" property="og:title"/>
<meta content="URLやテキストをブラウザ上で即座にQRコード化。サイズ・余白・誤り訂正・色を調整してPNG保存できる軽量ツールです。" property="og:description"/>
<meta content="https://pixieed.jp/qr-maker/qrogp.png" property="og:image"/>
<meta content="https://pixieed.jp/qr-maker/" property="og:url"/>
<meta content="summary_large_image" name="twitter:card"/>
<meta content="https://pixieed.jp/qr-maker/qrogp.png" name="twitter:image"/>
<meta content="#080d1f" name="theme-color"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700&family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet"/>
<link href="../character-dots/mao1.png" rel="icon" type="image/png"/>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-SZPVXMX85G"></script>
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9801602250480253"></script>
<script>
  const GA_MEASUREMENT_ID = 'G-SZPVXMX85G';
  const GA_PAGE_PATH = '/qr-maker/';
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', GA_MEASUREMENT_ID, {
    page_path: GA_PAGE_PATH,
    page_title: document.title
  });
  gtag('event', 'project_open', {
    project_slug: 'qr-maker',
    project_type: 'tool',
    project_name: 'QRコードメーカー'
  });
  gtag('event', 'qr_maker_open');
  </script>
<style>
  :root {
    color-scheme: dark;
    --bg: radial-gradient(circle at 18% 16%, rgba(123, 207, 255, 0.18), transparent 40%), radial-gradient(circle at 82% 10%, rgba(255, 170, 118, 0.14), transparent 38%), #080d1f;
    --panel: rgba(7, 11, 24, 0.82);
    --panel-strong: rgba(10, 16, 32, 0.94);
    --border: rgba(126, 154, 255, 0.28);
    --accent: #7bcfff;
    --accent-2: #ffa95c;
    --text: #eaf1ff;
    --muted: #98a7c7;
    --input: rgba(11, 17, 32, 0.9);
    --shadow: 0 20px 70px rgba(0, 0, 0, 0.45);
    --radius: 18px;
    --gap: clamp(16px, 2vw, 22px);
    font-family: "Montserrat", "Noto Sans JP", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    display: flex;
    justify-content: center;
    align-items: stretch;
    padding: clamp(8px, 2.5vw, 18px);
    user-select: none;
    -webkit-user-select: none;
  }
  textarea, input, select { user-select: text; -webkit-user-select: text; }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }
  .qr-shell {
    width: min(1100px, 100%);
    background: linear-gradient(145deg, rgba(10, 18, 36, 0.9), rgba(8, 14, 30, 0.92));
    border: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 26px;
    box-shadow: var(--shadow);
    padding: clamp(14px, 2vw, 22px);
    backdrop-filter: blur(8px);
    height: calc(100vh - 2 * clamp(12px, 3vw, 24px));
    max-height: 100%;
    display: grid;
    grid-template-rows: auto auto 1fr auto;
    gap: 12px;
    overflow: hidden;
  }
  header {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    min-width: 0;
    width: 100%;
  }
  .brand {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
  }
  .brand__logo {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 38px;
    height: 38px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(123, 207, 255, 0.4), rgba(123, 207, 255, 0.16)), #0c142d;
    color: #0c142d;
    border: 1px solid rgba(255, 255, 255, 0.06);
    font-weight: 700;
    font-size: 0.9rem;
  }
  .brand__name {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .brand__name small {
    color: var(--muted);
    font-weight: 600;
    letter-spacing: 0.04em;
  }
  .brand__name strong {
    font-size: 1.02rem;
    letter-spacing: 0.02em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  h1 {
    font-size: clamp(1.3rem, 3.4vw, 1.8rem);
    margin: 6px 0 4px;
    letter-spacing: 0.01em;
  }
  .lead {
    margin: 0 0 10px;
    color: var(--muted);
    line-height: 1.5;
    font-weight: 500;
  }
  .hero-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin: 2px 0 4px;
    padding-right: 4px;
  }
  .header-actions {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    min-width: max-content;
    justify-content: flex-end;
  }
  .header-actions .btn {
    white-space: nowrap;
    padding: 7px 9px;
    font-size: 0.9rem;
  }
  .hero-heading {
    display: block;
    min-width: 0;
  }
  .hero-heading h1 {
    margin: 8px 0 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .btn {
    appearance: none;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px 14px;
    font-weight: 700;
    background: linear-gradient(135deg, rgba(123, 207, 255, 0.3), rgba(90, 125, 255, 0.24));
    color: var(--text);
    cursor: pointer;
    transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
  }
  .btn:hover, .btn:focus-visible {
    transform: translateY(-1px);
    border-color: rgba(123, 207, 255, 0.65);
    outline: none;
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
  }
  .btn.secondary {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.12);
  }
  .qr-grid {
    display: grid;
    grid-template-columns: 1.05fr 0.95fr;
    gap: clamp(12px, 2vw, 18px);
    margin-top: 10px;
    min-height: 0;
  }
  .panel {
    background: var(--panel);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: var(--radius);
    padding: clamp(16px, 2vw, 20px);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
  }
  [hidden] {
    display: none !important;
  }
  .panel-head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
  }
  .mode-switch {
    display: inline-flex;
    gap: 6px;
    padding: 4px;
    border-radius: 12px;
    background: rgba(9, 14, 28, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.06);
  }
  .mode-btn {
    appearance: none;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.06);
    color: var(--muted);
    border-radius: 9px;
    padding: 6px 12px;
    font-weight: 700;
    cursor: pointer;
  }
  .mode-btn.is-active {
    background: linear-gradient(135deg, rgba(123, 207, 255, 0.6), rgba(255, 169, 92, 0.5));
    color: #0b1022;
    border-color: transparent;
  }
  .mode-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
  }
  .hash-text {
    font-size: 0.85rem;
    word-break: break-all;
  }
  .panel h2 {
    margin: 0 0 8px;
    font-size: 1.15rem;
    letter-spacing: 0.02em;
  }
  .panel p {
    margin: 0 0 14px;
    color: var(--muted);
    line-height: 1.6;
  }
  label {
    display: block;
    font-weight: 700;
    margin-bottom: 6px;
    letter-spacing: 0.01em;
  }
  textarea, select, input[type="color"], input[type="range"] {
    width: 100%;
    font-family: inherit;
  }
  textarea, select {
    background: var(--input);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--text);
    border-radius: 12px;
    padding: 12px;
    font-size: 1rem;
    transition: border-color 0.12s ease, box-shadow 0.12s ease;
  }
  textarea:focus, select:focus {
    outline: none;
    border-color: rgba(123, 207, 255, 0.6);
    box-shadow: 0 0 0 3px rgba(123, 207, 255, 0.16);
  }
  textarea {
    resize: vertical;
    min-height: 120px;
  }
  .field-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 12px;
    margin: 12px 0;
  }
  .range-wrap {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;
  }
  input[type="range"] {
    accent-color: var(--accent);
  }
  .range-value {
    color: var(--muted);
    font-weight: 600;
    min-width: 64px;
    text-align: right;
  }
.color-field {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }
  input[type="color"] {
    background: none;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    width: 70px;
    height: 52px;
    cursor: pointer;
    padding: 0;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 6px 18px rgba(0,0,0,0.28);
  }
  .meta-row {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    color: var(--muted);
    font-size: 0.92rem;
  }
  .meta-row span {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .status {
    font-weight: 700;
    color: var(--accent);
  }
  .qr-preview {
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 14px;
  }
  .qr-canvas {
    background: var(--panel-strong);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: var(--radius);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: clamp(10px, 1.5vw, 14px);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    min-height: 260px;
  }
  .pix-canvas-note {
    font-size: 0.78rem;
    color: rgba(226, 232, 240, 0.78);
    text-align: center;
    max-width: 240px;
    line-height: 1.4;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(8, 12, 24, 0.35);
  }
  canvas {
    width: min(100%, 300px);
    height: auto;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 14px 30px rgba(0, 0, 0, 0.3);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  .pix-code-canvas {
    width: auto;
    height: auto;
    max-width: none;
    border-radius: 0;
    box-shadow: none;
  }
  .qr-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }
  .small {
    font-size: 0.9rem;
    color: var(--muted);
  }
  .ad-slot {
    width: 100%;
    max-width: 960px;
    min-height: 60px;
    padding: 6px 0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 14px;
  }
  .ad-slot ins {
    display: block;
    width: 100%;
    max-width: 900px;
    height: 60px;
  }
  @media (max-width: 940px) {
    .qr-grid {
      grid-template-columns: 1fr;
    }
    .qr-shell {
      grid-template-rows: auto auto 1fr auto;
    }
    .qr-canvas {
      min-height: 260px;
    }
  }
  @media (max-width: 540px) {
    header { grid-template-columns: auto 1fr auto; }
    body { padding: 10px; }
    .qr-shell { padding: 14px; }
    .hero-actions { flex-direction: column; }
    .hero-heading { gap: 4px; }
    .hero-heading h1 { font-size: 1.2rem; }
    .header-actions .btn { padding: 7px 9px; font-size: 0.88rem; }
  }
</style>
  <style id="ads-safe">
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .adsbygoogle,
    ins.adsbygoogle {
      display: block !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box;
      overflow: hidden;
    }
    .adsbygoogle iframe,
    ins.adsbygoogle iframe {
      display: block;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
  </style>
  <style id="interaction-guard">
    * {
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    input,
    textarea,
    [contenteditable] {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  <script id="interaction-guard-js">
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    document.addEventListener('dragstart', (event) => {
      event.preventDefault();
    });
  </script>
  <script id="ads-lazy">
    (function() {
      if (window.pixieedObserveAds) return;
      const pending = [];
      const hasObserverSupport = 'IntersectionObserver' in window;
      let observer = null;
      const isLoaded = (ins) => (
        ins.dataset.adsLazyLoaded === '1' ||
        ins.getAttribute('data-adsbygoogle-status') === 'done' ||
        ins.getAttribute('data-ad-status') === 'filled'
      );
      const loadAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyLoaded = '1';
        try {
          (window.adsbygoogle = window.adsbygoogle || []).push({});
        } catch (err) {
          ins.dataset.adsLazyLoaded = '';
        }
      };
      const observeAd = (ins) => {
        if (!ins || !(ins instanceof HTMLElement)) return;
        if (ins.dataset.adsLazyObserved === '1') return;
        if (isLoaded(ins)) return;
        ins.dataset.adsLazyObserved = '1';
        if (!observer) {
          if (!hasObserverSupport) {
            loadAd(ins);
          } else {
            pending.push(ins);
          }
          return;
        }
        observer.observe(ins);
      };
      const observeAds = (root) => {
        const scope = root && root.querySelectorAll ? root : document;
        scope.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
      };
      window.pixieedObserveAds = observeAds;
      const setupObserver = () => {
        if (hasObserverSupport) {
          observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting || entry.intersectionRatio > 0) {
                const target = entry.target;
                if (observer) observer.unobserve(target);
                loadAd(target);
              }
            });
          }, { rootMargin: '200px 0px', threshold: 0.01 });
        }
        const queued = pending.splice(0);
        queued.forEach((ins) => {
          if (observer) {
            observer.observe(ins);
          } else {
            loadAd(ins);
          }
        });
        observeAds(document);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
      const mo = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (!(node instanceof HTMLElement)) return;
            if (node.matches && node.matches('ins.adsbygoogle')) {
              observeAd(node);
              return;
            }
            if (node.querySelectorAll) {
              node.querySelectorAll('ins.adsbygoogle').forEach(observeAd);
            }
          });
        });
      });
      const startObserver = () => {
        if (!document.body) return;
        mo.observe(document.body, { childList: true, subtree: true });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startObserver);
      } else {
        startObserver();
      }
    })();
  </script>
</head>
<body>
<div class="qr-shell">
<header>
<div class="brand">
<div aria-hidden="true" class="brand__logo">QR</div>
<div class="brand__name">
<small>PiXiEED Tool</small>
<strong>QRコードメーカー</strong>
</div>
</div>
<div class="header-actions">
<a class="btn secondary" href="../projects/qr-maker/index.html">一覧へ戻る</a>
</div>
</header>
<div class="ad-slot">
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9801602250480253"
     data-ad-slot="2141591954"></ins>
<script>
  if (window.pixieedObserveAds) {
    window.pixieedObserveAds();
  }
</script>
</div>
<main style="overflow:auto; min-height:0; padding-bottom:6px;">
<div class="hero-heading" aria-hidden="true">
<h1 style="visibility:hidden;height:0;margin:0;padding:0;">&nbsp;</h1>
</div>
<div class="qr-grid">
<section class="panel">
<div class="panel-head">
<h2>1. 内容を設定</h2>
<div class="mode-switch" role="tablist" aria-label="モード">
<button class="mode-btn is-active" data-mode="qr" type="button" role="tab" aria-selected="true">QR</button>
<button class="mode-btn" data-mode="pix" type="button" role="tab" aria-selected="false">PiXiEEDコード</button>
</div>
</div>
<div class="mode-section" id="qrControls">
<label for="qrInput">エンコードする内容</label>
<textarea id="qrInput" maxlength="1200" placeholder="https://example.com や テキストを入力…">https://pixieed.jp/</textarea>
<div class="meta-row" aria-live="polite">
<span>文字数: <span id="charCount">0</span> / 900 推奨</span>
<span>状態: <span class="status" id="qrStatus">未生成</span></span>
</div>
<div class="field-row">
<div>
<label for="qrLevel">誤り訂正レベル</label>
<select id="qrLevel">
<option value="M">M（標準）</option>
<option value="L">L（軽量）</option>
<option value="Q">Q（高耐性）</option>
<option value="H">H（最高耐性）</option>
</select>
</div>
<div>
<label for="qrSize">サイズ</label>
<div class="range-wrap">
<input id="qrSize" max="640" min="180" step="10" type="range" value="320"/>
<span class="range-value" id="qrSizeValue">320px</span>
</div>
</div>
</div>
<div class="field-row">
<div>
<label for="qrMargin">余白（クワイエットゾーン）</label>
<div class="range-wrap">
<input id="qrMargin" max="12" min="0" step="1" type="range" value="4"/>
<span class="range-value" id="qrMarginValue">4px</span>
</div>
</div>
<div>
<label>色</label>
<div class="color-field">
<div>
<span class="small">黒側</span>
<input id="qrDark" type="color" value="#0f172a"/>
</div>
<div>
<span class="small">背景</span>
<input id="qrLight" type="color" value="#ffffff"/>
</div>
</div>
</div>
</div>
</div>
<div class="mode-section" id="pixControls" hidden>
<label for="pixInput">16×16 白黒ドット絵（PNG / GIF）</label>
<input id="pixInput" type="file" accept="image/png,image/gif"/>
<p class="small">16×16推奨。色は白黒に変換されます。</p>
<div class="field-row">
<div>
<label for="pixPayloadType">返す内容</label>
<select id="pixPayloadType">
<option value="url">URL</option>
<option value="text">テキスト</option>
</select>
</div>
<div>
<label for="pixSize">出力サイズ</label>
<div class="range-wrap">
<input id="pixSize" max="640" min="480" step="20" type="range" value="520"/>
<span class="range-value" id="pixSizeValue">520px</span>
</div>
</div>
</div>
<label for="pixPayload">内容</label>
<textarea id="pixPayload" maxlength="800" placeholder="URL または テキストを入力…"></textarea>
<div class="meta-row" aria-live="polite">
<span>ハッシュ: <span class="hash-text" id="pixHash">--</span></span>
<span>状態: <span class="status" id="pixStatus">未生成</span></span>
</div>
</div>
</section>
<section class="panel qr-preview">
<div>
<h2>2. プレビュー</h2>
<p class="small">モードに合わせてプレビューされます。</p>
</div>
<div class="qr-canvas">
<canvas height="280" id="qrCanvas" width="280"></canvas>
<canvas height="280" id="pixCanvas" class="pix-code-canvas" width="280" hidden></canvas>
<div class="pix-canvas-note" id="pixCanvasNote" hidden>このコードはPiXiEELENSでのみ読み取り可能です</div>
</div>
<div class="qr-actions" id="qrActions">
<button class="btn" id="downloadBtn" type="button">PNGを保存</button>
<button class="btn secondary" id="copyDataBtn" type="button">テキストをコピー</button>
</div>
<div class="qr-actions" id="pixActions" hidden>
<button class="btn" id="pixDownloadBtn" type="button">PNGを保存</button>
<button class="btn secondary" id="pixCopyHashBtn" type="button">ハッシュをコピー</button>
<button class="btn secondary" id="pixRegisterBtn" type="button">DBへ登録</button>
</div>
</section>
</div>
<div class="ad-slot">
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9801602250480253"
     data-ad-slot="2141591954"></ins>
<script>
  if (window.pixieedObserveAds) {
    window.pixieedObserveAds();
  }
</script>
</div>
</div>
<script src="./qrcode.min.js"></script>
<script>
  const input = document.getElementById('qrInput');
  const qrCanvas = document.getElementById('qrCanvas');
  const qrStatus = document.getElementById('qrStatus');
  const charCount = document.getElementById('charCount');
  const sizeInput = document.getElementById('qrSize');
  const sizeValue = document.getElementById('qrSizeValue');
  const marginInput = document.getElementById('qrMargin');
  const marginValue = document.getElementById('qrMarginValue');
  const levelSelect = document.getElementById('qrLevel');
  const colorDark = document.getElementById('qrDark');
  const colorLight = document.getElementById('qrLight');
  const downloadBtn = document.getElementById('downloadBtn');
  const copyBtn = document.getElementById('copyDataBtn');
  const qrActions = document.getElementById('qrActions');
  const pixActions = document.getElementById('pixActions');
  const pixCanvas = document.getElementById('pixCanvas');
  const pixCanvasNote = document.getElementById('pixCanvasNote');
  const pixInput = document.getElementById('pixInput');
  const pixPayloadType = document.getElementById('pixPayloadType');
  const pixPayload = document.getElementById('pixPayload');
  const pixStatus = document.getElementById('pixStatus');
  const pixHash = document.getElementById('pixHash');
  const pixSize = document.getElementById('pixSize');
  const pixSizeValue = document.getElementById('pixSizeValue');
  const pixDownloadBtn = document.getElementById('pixDownloadBtn');
  const pixCopyHashBtn = document.getElementById('pixCopyHashBtn');
  const pixRegisterBtn = document.getElementById('pixRegisterBtn');
  const modeButtons = document.querySelectorAll('.mode-btn');
  const qrControls = document.getElementById('qrControls');
  const pixControls = document.getElementById('pixControls');

  const DEFAULT_TEXT = 'https://pixieed.jp/';
  const TEXT_LIMIT = 900;
  const SUPABASE_URL = 'https://kyyiuakrqomzlikfaire.supabase.co';
  const SUPABASE_ANON_KEY = 'sb_publishable_gnc61sD2hZvGHhEW8bQMoA_lrL07SN4';
  const PIXCODE_TABLE = 'pixfind_codes';
  const PIX_CLIENT_KEY = 'pixfind_client_id';
  const PIX_ART_SIZE = 16;
  const FINDER_SIZE = 7; // 1:1:3:1:1 finder
  const FINDER_GAP = 2;
  const PIX_FRAME_OFFSET = FINDER_SIZE + FINDER_GAP;
  const PIX_FRAME_SIZE = PIX_ART_SIZE + (PIX_FRAME_OFFSET * 2);
  const PIX_QUIET_ZONE = 6;
  const PIX_RENDER_SIZE = PIX_FRAME_SIZE + PIX_QUIET_ZONE * 2;
  const PIX_TIMING_ROW = FINDER_SIZE - 1;
  const PIX_TIMING_COL = FINDER_SIZE - 1;
  const PIX_TIMING_START = FINDER_SIZE + 1;
  const PIX_TIMING_END = PIX_FRAME_SIZE - FINDER_SIZE - 2;
  const PIX_FORMAT_ROW = FINDER_SIZE + 1;
  const PIX_FORMAT_COL = FINDER_SIZE + 1;
  const PIX_FORMAT_START = PIX_TIMING_START;
  const PIX_FORMAT_END = PIX_TIMING_END;
  const PIX_FORMAT_LENGTH = PIX_FORMAT_END - PIX_FORMAT_START + 1;
  const PIX_FORMAT_PATTERN = '10100111001011011001011100101101';
  const PIX_FORMAT_BITS = Array.from({ length: PIX_FORMAT_LENGTH }, (_, i) => PIX_FORMAT_PATTERN[i % PIX_FORMAT_PATTERN.length] === '1');
  const PIX_ALIGN_SIZE = 2;
  const PIX_ALIGN_START = PIX_FRAME_OFFSET + PIX_ART_SIZE;
  const PIX_ALIGN_POINTS = [
    { x: PIX_ALIGN_START, y: PIX_ALIGN_START }
  ];
  const PIX_ALIGN_COLOR = '#000000';
  const FINDER_INNER_COLOR = '#000000';

  const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
  let currentMode = 'qr';
  let pixQuantized = null;
  let pixHashValue = '';
  let supportsPixClientId = true;

  function syncLabels() {
    charCount.textContent = input.value.length;
    sizeValue.textContent = sizeInput.value + 'px';
    marginValue.textContent = marginInput.value + 'px';
  }

  async function renderQRCode() {
    if (!window.QRCode || typeof QRCode.toCanvas !== 'function') {
      qrStatus.textContent = 'QRライブラリを読み込めませんでした';
      qrStatus.style.color = '#ffa95c';
      return;
    }
    const text = (input.value.trim() || DEFAULT_TEXT).slice(0, TEXT_LIMIT);
    const width = clamp(parseInt(sizeInput.value || '320', 10), 180, 640);
    const margin = clamp(parseInt(marginInput.value || '4', 10), 0, 24);
    const options = {
      errorCorrectionLevel: levelSelect.value,
      width,
      margin,
      color: {
        dark: colorDark.value || '#0f172a',
        light: colorLight.value || '#ffffff'
      }
    };
    try {
      await QRCode.toCanvas(qrCanvas, text, options);
      qrStatus.textContent = '更新しました';
      qrStatus.style.color = '#7bcfff';
    } catch (err) {
      qrStatus.textContent = '生成に失敗しました';
      qrStatus.style.color = '#ffa95c';
      console.error(err);
    }
  }

  function syncPixLabels() {
    if (!pixSizeValue || !pixSize) return;
    pixSizeValue.textContent = pixSize.value + 'px';
  }

  function setPixStatus(message, color) {
    if (!pixStatus) return;
    pixStatus.textContent = message;
    pixStatus.style.color = color || '#7bcfff';
  }

  function setMode(mode) {
    currentMode = mode;
    modeButtons.forEach(btn => {
      const isActive = btn.dataset.mode === mode;
      btn.classList.toggle('is-active', isActive);
      btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
    });
    if (qrControls) qrControls.hidden = mode !== 'qr';
    if (pixControls) pixControls.hidden = mode !== 'pix';
    if (qrCanvas) qrCanvas.hidden = mode !== 'qr';
    if (pixCanvas) pixCanvas.hidden = mode !== 'pix';
    if (pixCanvasNote) pixCanvasNote.hidden = mode !== 'pix';
    if (qrActions) qrActions.hidden = mode !== 'qr';
    if (pixActions) pixActions.hidden = mode !== 'pix';
    if (mode === 'qr') {
      syncLabels();
      renderQRCode();
    } else if (pixQuantized) {
      renderPixCode();
    }
  }

  function computeLuma(r, g, b) {
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  function buildQuantizedArt(imageData) {
    const total = PIX_ART_SIZE * PIX_ART_SIZE;
    const quantized = new Uint8Array(total);
    let min = 255;
    let max = 0;
    for (let i = 0; i < total; i++) {
      const idx = i * 4;
      const alpha = imageData[idx + 3];
      const r = alpha < 128 ? 255 : imageData[idx];
      const g = alpha < 128 ? 255 : imageData[idx + 1];
      const b = alpha < 128 ? 255 : imageData[idx + 2];
      const lum = computeLuma(r, g, b);
      if (lum < min) {
        min = lum;
      }
      if (lum > max) {
        max = lum;
      }
    }
    const threshold = (min + max) / 2;
    for (let i = 0; i < total; i++) {
      const idx = i * 4;
      const alpha = imageData[idx + 3];
      const r = alpha < 128 ? 255 : imageData[idx];
      const g = alpha < 128 ? 255 : imageData[idx + 1];
      const b = alpha < 128 ? 255 : imageData[idx + 2];
      const lum = computeLuma(r, g, b);
      quantized[i] = lum < threshold ? 0 : 1;
    }
    return quantized;
  }

  async function hashQuantized(quantized) {
    if (!crypto?.subtle?.digest) return '';
    const digest = await crypto.subtle.digest('SHA-256', quantized);
    return Array.from(new Uint8Array(digest))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  async function loadPixImage(file) {
    if (!file) return null;
    const blobUrl = URL.createObjectURL(file);
    try {
      const img = new Image();
      img.decoding = 'sync';
      img.src = blobUrl;
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
      });
      const temp = document.createElement('canvas');
      temp.width = PIX_ART_SIZE;
      temp.height = PIX_ART_SIZE;
      const ctx = temp.getContext('2d');
      if (!ctx) return null;
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, temp.width, temp.height);
      ctx.drawImage(img, 0, 0, PIX_ART_SIZE, PIX_ART_SIZE);
      const data = ctx.getImageData(0, 0, PIX_ART_SIZE, PIX_ART_SIZE).data;
      return { data, width: img.naturalWidth || img.width, height: img.naturalHeight || img.height };
    } finally {
      URL.revokeObjectURL(blobUrl);
    }
  }

  function drawFrameCell(ctx, x, y, cellSize, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
  }

  function drawFinderBlock(ctx, startX, startY, cellSize) {
    const edge = FINDER_SIZE - 1;
    for (let y = 0; y < FINDER_SIZE; y++) {
      for (let x = 0; x < FINDER_SIZE; x++) {
        let color = '#ffffff';
        if (x === 0 || y === 0 || x === edge || y === edge) {
          color = '#000000';
        } else if (x === 1 || y === 1 || x === edge - 1 || y === edge - 1) {
          color = '#ffffff';
        } else {
          color = FINDER_INNER_COLOR;
        }
        drawFrameCell(ctx, startX + x, startY + y, cellSize, color);
      }
    }
  }

  function drawFinderSeparator(ctx, startX, startY, cellSize, frameOffset) {
    const sepStartX = startX - 1;
    const sepStartY = startY - 1;
    const sepEndX = startX + FINDER_SIZE;
    const sepEndY = startY + FINDER_SIZE;
    for (let y = sepStartY; y <= sepEndY; y++) {
      for (let x = sepStartX; x <= sepEndX; x++) {
        if (x < 0 || y < 0 || x >= PIX_FRAME_SIZE || y >= PIX_FRAME_SIZE) {
          continue;
        }
        if (x >= startX && x < startX + FINDER_SIZE && y >= startY && y < startY + FINDER_SIZE) {
          continue;
        }
        drawFrameCell(ctx, frameOffset + x, frameOffset + y, cellSize, '#ffffff');
      }
    }
  }

  function drawTimingPatterns(ctx, cellSize, frameOffset) {
    for (let x = PIX_TIMING_START; x <= PIX_TIMING_END; x++) {
      const isDark = (x - PIX_TIMING_START) % 2 === 0;
      drawFrameCell(ctx, frameOffset + x, frameOffset + PIX_TIMING_ROW, cellSize, isDark ? '#000000' : '#ffffff');
    }
    for (let y = PIX_TIMING_START; y <= PIX_TIMING_END; y++) {
      const isDark = (y - PIX_TIMING_START) % 2 === 0;
      drawFrameCell(ctx, frameOffset + PIX_TIMING_COL, frameOffset + y, cellSize, isDark ? '#000000' : '#ffffff');
    }
  }

  function drawFormatBand(ctx, cellSize, frameOffset) {
    for (let x = PIX_FORMAT_START; x <= PIX_FORMAT_END; x++) {
      const idx = x - PIX_FORMAT_START;
      const isDark = PIX_FORMAT_BITS[idx];
      drawFrameCell(ctx, frameOffset + x, frameOffset + PIX_FORMAT_ROW, cellSize, isDark ? '#000000' : '#ffffff');
      drawFrameCell(ctx, frameOffset + PIX_FORMAT_COL, frameOffset + PIX_FORMAT_START + idx, cellSize, isDark ? '#000000' : '#ffffff');
    }
  }

  function drawAlignmentMarker(ctx, cellSize, frameOffset) {
    PIX_ALIGN_POINTS.forEach((point) => {
      for (let y = 0; y < PIX_ALIGN_SIZE; y++) {
        for (let x = 0; x < PIX_ALIGN_SIZE; x++) {
          drawFrameCell(
            ctx,
            frameOffset + point.x + x,
            frameOffset + point.y + y,
            cellSize,
            PIX_ALIGN_COLOR
          );
        }
      }
    });
  }

  function drawPixCode() {
    if (!pixCanvas || !pixQuantized) return;
    const targetSize = clamp(parseInt(pixSize.value || '320', 10), 200, 640);
    const cellSize = Math.max(1, Math.floor(targetSize / PIX_RENDER_SIZE));
    const canvasSize = cellSize * PIX_RENDER_SIZE;
    pixCanvas.width = canvasSize;
    pixCanvas.height = canvasSize;
    pixCanvas.style.width = `${canvasSize}px`;
    pixCanvas.style.height = `${canvasSize}px`;
    pixCanvas.style.maxWidth = 'none';
    const ctx = pixCanvas.getContext('2d');
    if (!ctx) return;
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvasSize, canvasSize);
    const frameOffset = PIX_QUIET_ZONE;
    const tlStartX = 0;
    const tlStartY = 0;
    const trStartX = PIX_FRAME_SIZE - FINDER_SIZE;
    const trStartY = 0;
    const blStartX = 0;
    const blStartY = PIX_FRAME_SIZE - FINDER_SIZE;
    const tlX = frameOffset;
    const tlY = frameOffset;
    const trX = frameOffset + trStartX;
    const trY = frameOffset + trStartY;
    const blX = frameOffset + blStartX;
    const blY = frameOffset + blStartY;
    drawFinderBlock(ctx, tlX, tlY, cellSize);
    drawFinderBlock(ctx, trX, trY, cellSize);
    drawFinderBlock(ctx, blX, blY, cellSize);
    drawFinderSeparator(ctx, tlStartX, tlStartY, cellSize, frameOffset);
    drawFinderSeparator(ctx, trStartX, trStartY, cellSize, frameOffset);
    drawFinderSeparator(ctx, blStartX, blStartY, cellSize, frameOffset);
    drawTimingPatterns(ctx, cellSize, frameOffset);
    drawFormatBand(ctx, cellSize, frameOffset);
    drawAlignmentMarker(ctx, cellSize, frameOffset);
    for (let y = 0; y < PIX_ART_SIZE; y++) {
      for (let x = 0; x < PIX_ART_SIZE; x++) {
        const idx = y * PIX_ART_SIZE + x;
        ctx.fillStyle = pixQuantized[idx] ? '#ffffff' : '#000000';
        ctx.fillRect(
          (x + PIX_FRAME_OFFSET + frameOffset) * cellSize,
          (y + PIX_FRAME_OFFSET + frameOffset) * cellSize,
          cellSize,
          cellSize
        );
      }
    }
  }

  async function renderPixCode() {
    if (!pixQuantized) return;
    drawPixCode();
    if (pixHash) pixHash.textContent = pixHashValue || '--';
    setPixStatus('更新しました', '#7bcfff');
  }

  function ensurePixClientId() {
    try {
      let id = localStorage.getItem(PIX_CLIENT_KEY);
      if (!id) {
        id = `pix-${Math.random().toString(36).slice(2)}${Date.now().toString(36)}`;
        localStorage.setItem(PIX_CLIENT_KEY, id);
      }
      return id;
    } catch {
      return null;
    }
  }

  async function fetchPixCodeByHash(hash) {
    if (!hash) {
      return null;
    }
    try {
      const res = await fetch(`${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}?hash=eq.${hash}&select=hash,client_id&limit=1`, {
        headers: {
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`
        }
      });
      if (!res.ok) {
        return null;
      }
      const data = await res.json();
      return Array.isArray(data) && data[0] ? data[0] : null;
    } catch {
      return null;
    }
  }

  async function registerPixCode() {
    if (!pixHashValue) {
      setPixStatus('先に画像を読み込んでください', '#ffa95c');
      return;
    }
    const payload = (pixPayload?.value || '').trim();
    if (!payload) {
      setPixStatus('内容を入力してください', '#ffa95c');
      return;
    }
    const clientId = ensurePixClientId();
    if (supportsPixClientId && !clientId) {
      setPixStatus('この環境では登録できません', '#ffa95c');
      return;
    }
    const existing = await fetchPixCodeByHash(pixHashValue);
    if (existing) {
      const existingClientId = typeof existing.client_id === 'string' ? existing.client_id : '';
      const canClaim = supportsPixClientId && clientId && !existingClientId;
      const canOverwrite = supportsPixClientId && clientId && existingClientId && existingClientId === clientId;
      if (!canOverwrite && !canClaim) {
        setPixStatus('このコードはすでに登録されています', '#ffa95c');
        return;
      }
      try {
        const updatePayload = {
          payload_type: pixPayloadType?.value || 'url',
          payload_value: payload,
          updated_at: new Date().toISOString()
        };
        if (canClaim) {
          updatePayload.client_id = clientId;
        }
        const res = await fetch(`${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}?hash=eq.${pixHashValue}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            apikey: SUPABASE_ANON_KEY,
            Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
            Prefer: 'return=representation'
          },
          body: JSON.stringify(updatePayload)
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        setPixStatus('更新しました', '#7bcfff');
        return;
      } catch (err) {
        console.warn(err);
        setPixStatus('更新に失敗しました', '#ffa95c');
        return;
      }
    }
    const basePayload = {
      hash: pixHashValue,
      payload_type: pixPayloadType?.value || 'url',
      payload_value: payload,
      updated_at: new Date().toISOString()
    };
    if (supportsPixClientId && clientId) {
      basePayload.client_id = clientId;
    }
    const registerUrl = supportsPixClientId && clientId
      ? `${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}?on_conflict=client_id`
      : `${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}`;
    try {
      const res = await fetch(registerUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
          Prefer: 'resolution=merge-duplicates'
        },
        body: JSON.stringify(basePayload)
      });
      if (!res.ok) {
        const text = await res.text();
        if (res.status === 409 || text.includes('duplicate key') || text.includes('pixfind_codes_pkey')) {
          setPixStatus('このコードはすでに登録されています', '#ffa95c');
          return;
        }
        if (supportsPixClientId && text.includes('client_id')) {
          supportsPixClientId = false;
          delete basePayload.client_id;
          const retry = await fetch(`${SUPABASE_URL}/rest/v1/${PIXCODE_TABLE}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              apikey: SUPABASE_ANON_KEY,
              Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
              Prefer: 'resolution=merge-duplicates'
            },
            body: JSON.stringify(basePayload)
          });
          if (!retry.ok) throw new Error(await retry.text());
        } else {
          throw new Error(text);
        }
      }
      setPixStatus('登録しました', '#7bcfff');
    } catch (err) {
      console.warn(err);
      setPixStatus('登録に失敗しました', '#ffa95c');
    }
  }

  function downloadPNG() {
    const link = document.createElement('a');
    link.download = 'pixieed-qr.png';
    link.href = qrCanvas.toDataURL('image/png');
    link.click();
  }

  function copyData() {
    const text = input.value.trim() || DEFAULT_TEXT;
    if (!navigator.clipboard || !navigator.clipboard.writeText) {
      qrStatus.textContent = 'クリップボード非対応の環境です';
      qrStatus.style.color = '#ffa95c';
      return;
    }
    navigator.clipboard.writeText(text).then(() => {
      qrStatus.textContent = 'テキストをコピーしました';
      qrStatus.style.color = '#7bcfff';
    }).catch(() => {
      qrStatus.textContent = 'クリップボードにコピーできませんでした';
      qrStatus.style.color = '#ffa95c';
    });
  }

  input.addEventListener('input', () => {
    syncLabels();
    if (currentMode === 'qr') {
      renderQRCode();
    }
  });
  [sizeInput, marginInput, levelSelect, colorDark, colorLight].forEach(el => {
    el.addEventListener('input', () => {
      syncLabels();
      if (currentMode === 'qr') {
        renderQRCode();
      }
    });
  });
  if (pixInput) {
    pixInput.addEventListener('change', async () => {
      const file = pixInput.files?.[0];
      if (!file) {
        pixQuantized = null;
        pixHashValue = '';
        if (pixHash) pixHash.textContent = '--';
        setPixStatus('未生成', '#7bcfff');
        return;
      }
      setPixStatus('読み込み中...', '#ffa95c');
      try {
        const info = await loadPixImage(file);
        if (!info) throw new Error('画像を読み込めませんでした');
        if (info.width !== PIX_ART_SIZE || info.height !== PIX_ART_SIZE) {
          setPixStatus('16×16に近似しました', '#ffa95c');
        }
        pixQuantized = buildQuantizedArt(info.data);
        pixHashValue = await hashQuantized(pixQuantized);
        if (pixHash) pixHash.textContent = pixHashValue || '--';
        drawPixCode();
        setPixStatus('更新しました', '#7bcfff');
      } catch (err) {
        console.error(err);
        pixQuantized = null;
        pixHashValue = '';
        if (pixHash) pixHash.textContent = '--';
        setPixStatus('画像の読み込みに失敗しました', '#ffa95c');
      }
    });
  }
  if (pixSize) {
    pixSize.addEventListener('input', () => {
      syncPixLabels();
      if (currentMode === 'pix' && pixQuantized) {
        drawPixCode();
      }
    });
  }
  if (pixDownloadBtn) {
    pixDownloadBtn.addEventListener('click', () => {
      if (!pixCanvas || !pixQuantized) {
        setPixStatus('画像を読み込んでください', '#ffa95c');
        return;
      }
      const link = document.createElement('a');
      link.download = 'pixfind-code.png';
      link.href = pixCanvas.toDataURL('image/png');
      link.click();
    });
  }
  if (pixCopyHashBtn) {
    pixCopyHashBtn.addEventListener('click', () => {
      if (!pixHashValue) {
        setPixStatus('ハッシュがありません', '#ffa95c');
        return;
      }
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        setPixStatus('クリップボード非対応です', '#ffa95c');
        return;
      }
      navigator.clipboard.writeText(pixHashValue).then(() => {
        setPixStatus('ハッシュをコピーしました', '#7bcfff');
      }).catch(() => {
        setPixStatus('コピーに失敗しました', '#ffa95c');
      });
    });
  }
  if (pixRegisterBtn) {
    pixRegisterBtn.addEventListener('click', () => {
      registerPixCode();
    });
  }
  modeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      setMode(btn.dataset.mode || 'qr');
    });
  });
  // 初期描画
  downloadBtn.addEventListener('click', downloadPNG);
  copyBtn.addEventListener('click', copyData);

  syncLabels();
  syncPixLabels();
  renderQRCode();
  setMode(currentMode);
</script>
</body>
</html>
